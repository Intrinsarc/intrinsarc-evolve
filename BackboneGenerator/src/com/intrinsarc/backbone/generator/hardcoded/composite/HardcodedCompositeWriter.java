package com.intrinsarc.backbone.generator.hardcoded.composite;

import static com.intrinsarc.backbone.generator.hardcoded.common.WriterHelper.*;

import java.io.*;
import java.util.*;

import com.intrinsarc.backbone.generator.*;
import com.intrinsarc.backbone.generator.hardcoded.common.*;
import com.intrinsarc.backbone.nodes.*;
import com.intrinsarc.backbone.runtime.implementation.*;
import com.intrinsarc.deltaengine.base.*;

public class HardcodedCompositeWriter
{
	public static String FACTORY_NUMBER = "factoryNumber";
	private CompositeUniqueNamer namer;
	private DEStratum perspective;
	private DEComponent next;
	private File base;
	private String prefixPkg;
	private Set<DEComponent> created;
	private Set<DEComponent> toCreate;

	public HardcodedCompositeWriter(CompositeUniqueNamer namer, DEStratum perspective, DEComponent next, File base,
			String prefixPkg, Set<DEComponent> created, Set<DEComponent> toCreate)
	{
		this.namer = namer;
		this.perspective = perspective;
		this.next = next;
		this.base = base;
		this.prefixPkg = prefixPkg;
		this.created = created;
		this.toCreate = toCreate;
	}

	public void writeComposite(FileTracker tracker) throws BackboneGenerationException
	{
		// get the full file name
		String full = getFullElementName(namer, next);
		String compName = getLast(full, null);
		String pkgName = getFullPackageName(namer, next.getHomeStratum()).replace('/', '.');

		// create the class
		File write = new File(base, full + ".java");
		write.getParentFile().mkdirs();
		StringBuilder s = new StringBuilder();

		s.append("package " + (prefixPkg.length() > 0 ? prefixPkg + "." : "") + pkgName + ";\n\n");
		s.append("\nimport com.intrinsarc.backbone.runtime.api.*;\n\n");

		s.append("/** generated by Evolve */\n");
		s.append("public class " + compName + "\n");
		s.append("{\n");

		// write out any attributes and setters/getters
		writeAttributes(s);
		s.append("\n");

		// write out any parts
		if (!next.isFactory(perspective))
			writeParts(s);
		s.append("\n");

		// constructor
		s.append("  public " + compName + "()\n  {\n");
		s.append("  }\n\n");

		s.append("  public void setSlots()\n");
		s.append("  {\n");
		writeSlotSets(s);
		s.append("  }\n\n");
		
		writeConnectors(s);

		// write out any lifecycle actions for initialization
		s.append("  public " + compName + " init(boolean children)\n  {\n");
		writeAfterInits(s);
		s.append("    return this;\n");
		s.append("  }\n");

		s.append("}\n");

		try
		{
			tracker.recordNew(write);
			tracker.possiblyWrite(write, s.toString());
		} catch (IOException ex)
		{
			throw new BackboneGenerationException("Problem writing to file " + write + " when hardcoding composites", ex);
		}
	}

	private void writeAfterInits(StringBuilder s)
	{
		// set the slots from the top down
		// cache the provided interfaces (executed bottom up)
		// set the required interfaces from the top down
		s.append("    if (children)\n    {\n      setSlots();\n      cacheProvidedInterfaces();\n");
		s.append("      setRequiredInterfaces();\n    }\n");
		
		for (DeltaPair pair : next.getDeltas(ConstituentTypeEnum.DELTA_PART).getConstituents(perspective))
		{
			DEPart part = pair.getConstituent().asPart();
			boolean life = part.getType().hasLifecycleCallbacks(perspective);
			if (part.getType().isComposite(perspective) || life)
				s.append("    " + getUniqueConstituentName(next, pair.getOriginal(), ConstituentTypeEnum.DELTA_PART)
						+ (life ? ".afterInit(" : ".init(false") + ");\n");
		}
	}

	private void writeSlotSets(StringBuilder s)
	{
		// for each part generate any required slots
		for (DeltaPair pair : next.getDeltas(ConstituentTypeEnum.DELTA_PART).getConstituents(perspective))
		{
			DEPart part = pair.getConstituent().asPart();
			DEElement type = part.getType();
			if (!isFactoryPart(part))
			{
				for (DESlot slot : part.getSlots())
				{
					s.append("    " + getUniqueConstituentName(next, pair.getOriginal(), ConstituentTypeEnum.DELTA_PART));
					s.append(".set"
							+ upper(getUniqueConstituentName(type, slot.getAttribute(), ConstituentTypeEnum.DELTA_ATTRIBUTE)) + "(");
					// put in the translated parameters
					s.append(makeInitializer(
							slot.getAttribute(perspective, type).getType().asComponent(), slot.getValue(), false));
					if (type.asComponent().isLegacyBean(perspective))
						s.append(".get()");
					s.append(");\n");
				}
			}
		}
		
		// ask each part to do its bit...
		for (DeltaPair pair : next.getDeltas(ConstituentTypeEnum.DELTA_PART).getConstituents(perspective))
		{
			DEPart part = pair.getConstituent().asPart();
			if (part.getType().isComposite(perspective))
				s.append(
						"    " +
						getUniqueConstituentName(next, pair.getOriginal(), ConstituentTypeEnum.DELTA_PART)
						+ ".setSlots();\n");
		}
	}

	private void writeParts(StringBuilder s)
	{
		for (DeltaPair pair : next.getDeltas(ConstituentTypeEnum.DELTA_PART).getConstituents(perspective))
		{
			DEPart part = pair.getConstituent().asPart();
			if (!isFactoryPart(part))
			{
				String implName = getImplementationName(part.getType());
				s.append("  private " + implName + " "
						+ getUniqueConstituentName(next, pair.getOriginal(), ConstituentTypeEnum.DELTA_PART));
				s.append(" = new " + implName + "();\n");
			}
		}
	}

	private void writeAttributes(StringBuilder s)
	{
		for (DEAttribute attr : next.getToplogicallySortedAttributes(perspective))
		{
			String attrName = getUniqueConstituentName(next, attr, ConstituentTypeEnum.DELTA_ATTRIBUTE);
			if (!isFactoryNumber(attr))
			{
				String implName = getImplementationName(attr.getType());
				String strip = PrimitiveHelper.stripJavaLang(implName);
				s.append("  private Attribute<" + strip + "> " + attrName);
				s.append(makeInitializer(attr.getType().asComponent(), attr.getDefaultValue(), true));
				s.append(";\n");
	
				// possibly make a setter or getter function
				if (!attr.isReadOnly())
				{
					s.append("  public void set" + upper(attrName) + "(Attribute<" + strip + "> " + attrName + ") { this." + attrName
							+ " = " + attrName + "; }\n");
				}
				if (!attr.isWriteOnly())
				{
					s.append("  public Attribute<" + strip + "> get" + upper(attrName) + "() { return " + attrName + "; }\n");
				}
			}
		}
	}

	/** shouldn't matter if this is a constituent or an original */
	private boolean isFactoryNumber(DEAttribute attr)
	{
		return next.isFactory(perspective) && attr.getRawName().equals("factoryNumber");
	}
	
	private boolean isFactoryPart(DEPart part)
	{
		String implClass = part.getType().getImplementationClass(perspective);
		return Creator.class.getName().equals(implClass);
	}

	private String getImplementationName(DEElement elem)
	{
		// if this is composite, return the potential composite element
		if (elem.asComponent() != null)
		{
			DEComponent comp = elem.asComponent();
			if (comp.isComposite(perspective))
			{
				if (!created.contains(elem))
					toCreate.add(comp);
				return prefixPkg + "." + getFullElementName(namer, elem).replace('/', '.');
			}
		}
		return elem.getImplementationClass(perspective);
	}

	private String getUniqueConstituentName(DEElement elem, DEConstituent original, ConstituentTypeEnum type)
	{
		String key = elem.getUuid() + ":" + original.getUuid();
		String existing = namer.getAllocatedUniqueName(key);
		if (existing != null)
			return existing;

		// find the name of the element within the component
		for (DeltaPair p : elem.getDeltas(type).getConstituents(perspective))
		{
			if (p.getOriginal() == original || p.getConstituent() == original)
			{
				// uniquely name the combination of component and constituent
				return namer.getUniqueName(key, elem.getUuid() + "/" + type.name(), p.getConstituent().getName(), true);
			}
		}
		return null;
	}

	private String makeInitializer(DEComponent type, List<DEParameter> params, boolean addEquals)
	{
		String s = addEquals ? " = " : "";

		String implName = getImplementationName(type);
		String translatedImpl = PrimitiveHelper.translateLongToShortPrimitive(implName);
		String strip = PrimitiveHelper.stripJavaLang(implName);
		boolean primitive = !translatedImpl.equals(implName);

		int size = params.size();
		if (size == 1 && params.get(0).getAttribute() != null)
			return s + " new Attribute<" + strip + ">(" + translateParameter(params.get(0)) + ")";

		// is this primitive?
		if (primitive && size == 0)
			return "";
		if (primitive && size == 1)
			return s + "new Attribute<" + strip + ">(" + translateParameter(params.get(0)) + ")";
		else
		{
			s += "new Attribute<" + strip + ">(new " + implName + "(";
			boolean start = true;
			for (DEParameter p : params)
				if (start)
				{
					s += translateParameter(p);
					start = false;
				} else
					s += ", " + translateParameter(p);
			return s + "))";
		}
	}

	private String translateParameter(DEParameter parameter)
	{
		if (parameter.getLiteral() != null)
			return parameter.getLiteral();
		return getUniqueConstituentName(next, parameter.getAttribute(perspective, next),
				ConstituentTypeEnum.DELTA_ATTRIBUTE) + ".get()";
	}

	private String getLast(String full, Character separator)
	{
		if (separator == null)
			separator = '/';
		int ind = full.lastIndexOf(separator);
		if (ind == -1)
			return full;
		return full.substring(ind + 1);
	}

	private String getFullElementName(CompositeUniqueNamer namer, DEElement comp)
	{
		String full = getFullPackageName(namer, comp.getHomeStratum()) + "/" + getName(comp);
		return namer.getUniqueName(comp, full);
	}

	private String getFullPackageName(CompositeUniqueNamer namer, DEStratum pkg)
	{
		if (pkg.getParent() != null && pkg.getParent() != pkg.getEngine().getRoot())
		{
			String name = getFullPackageName(namer, pkg.getParent().asStratum()) + "/" + getName(pkg);
			return namer.getUniqueName(pkg, name);
		}
		return namer.getUniqueName(pkg, getName(pkg));
	}

	private String getName(DEStratum pkg)
	{
		String name = pkg.getName().trim().toLowerCase();
		if (name.length() == 0)
			return "pkg";
		return name;
	}

	private String getName(DEElement elem)
	{
		String name = upper(elem.getName().trim());
		if (name.length() == 0)
			if (elem.asComponent() != null)
				name = "Component";
			else
				name = "Interface";

		return namer.getUniqueName(elem.getUuid(), name, true);
	}

	private void writeConnectors(StringBuilder s)
	{
		// allow any provided required interfaces to be set
		// assume a single connector from an external port
		for (DeltaPair pair : next.getDeltas(ConstituentTypeEnum.DELTA_PORT).getConstituents(perspective))
		{
			DEPort port = pair.getConstituent().asPort();
			// can only be a single link to the outside port
			DEConnectorEnd otherSide = getOtherSides(port, null).iterator().next();
			DEComponent other = otherSide.getPart().getType();
			DEPort otherPort = otherSide.getPort();
			String portName = upper(getUniqueConstituentName(next, pair.getOriginal(), ConstituentTypeEnum.DELTA_PORT));
			String otherPartName = getUniqueConstituentName(next, otherSide.getPart(), ConstituentTypeEnum.DELTA_PART);
			String otherPortName = upper(getUniqueConstituentName(other, otherSide.getPort(), ConstituentTypeEnum.DELTA_PORT));
			boolean bean = other.isLegacyBean(perspective);
			if (bean)
				otherPortName = makeSingular(otherPortName);

			for (DEInterface iface : next.getProvidedInterfaces(perspective, port))
			{
				String fullImpl = getImplementationName(iface);
				String implName = getAfterLastDot(fullImpl);
				s.append("  public " + fullImpl + " get" + portName + "_" + implName + "(Class<?> required");
				
				// get the other side of the connector				
				if (port.isMany())
				{
					s.append(", int index)\n");
					s.append("  {\n");
					s.append("    return " + otherPartName + ".get" + otherPortName + "_" + implName + "(required, index);\n");
				}
				else
				{
					s.append(")\n");
					s.append("  {\n");
					if (bean)
						s.append("    return " + otherPartName + ";\n");
					else
					{
						// this is possibly a factory creation
						if (isFactoryPart(otherSide.getPart()))
							writeFactoryCreator(s, otherSide.getPart());
						else
							s.append("    return " + otherPartName + ".get" + otherPortName + "_" + implName + "(required);\n");
					}
				}
				s.append("  }\n\n");
			}

			for (DEInterface iface : next.getRequiredInterfaces(perspective, port))
			{
				String fullImpl = getImplementationName(iface);
				String implName = getAfterLastDot(fullImpl);
				s.append("  public void set" + portName + "_" + implName + "(");
				s.append(fullImpl + " iface");
				if (port.isMany())
					s.append(", int index");
				s.append(")\n");
				s.append("  {\n");
				if (port.isMany())
				{
					if (bean)
					{
						if (otherPort.isForceBeanMain())
							s.append("    " + otherPartName + ".add(iface);\n");
						else
							s.append("    " + otherPartName + ".add" + otherPortName + "(iface);\n");
					}
					else
						s.append("    " + otherPartName + ".set" + otherPortName + "_" + implName + "(iface, index);\n");
				}
				else
				{
					if (bean)
						s.append("    " + otherPartName + ".set" + otherPortName + "(iface);\n");
					else
						s.append("    " + otherPartName + ".set" + otherPortName + "_" + implName + "(iface);\n");
				}
				s.append("  }\n\n");
			}
		}
		
		// write the code to cache the provided interfaces
		s.append("  public void cacheProvidedInterfaces()\n");
		s.append("  {\n");
		
		// cache our provided interfaces
		
		// ask the children to cache their provided interfaces
		for (DeltaPair pair : next.getDeltas(ConstituentTypeEnum.DELTA_PART).getConstituents(perspective))
		{
			DEPart part = pair.getConstituent().asPart();
			if (part.getType().isComposite(perspective))
				s.append("    " + getUniqueConstituentName(next, pair.getOriginal(), ConstituentTypeEnum.DELTA_PART) + ".cacheProvidedInterfaces();\n");
		}		
		s.append("  }\n\n");
		
		
		// write the code to set the required interfaces
		s.append("  public void setRequiredInterfaces()\n");
		s.append("  {\n");
		
		// set our required interfaces
		for (DEConnectorEnd end : getSortedConnectorEnds())
		{
			// if the end has required interfaces, get them from the other side
			for (DEInterface iface : end.getPart().getType().getRequiredInterfaces(perspective, end.getPort()))
			{
				// get the connectors
				for (DEConnectorEnd otherEnd : getOtherSides(end))
					setRequired(s, end, iface, getProvided(otherEnd, iface));
			}
		}
		
		// ask the children to set their required interfaces
		for (DeltaPair pair : next.getDeltas(ConstituentTypeEnum.DELTA_PART).getConstituents(perspective))
		{
			DEPart part = pair.getConstituent().asPart();
			if (part.getType().isComposite(perspective))
				s.append("    " + getUniqueConstituentName(next, pair.getOriginal(), ConstituentTypeEnum.DELTA_PART) + ".setRequiredInterfaces();\n");
		}		

		s.append("  }\n\n");		
	}

	private void writeFactoryCreator(StringBuilder s, DEPart part)
	{
		s.append("    return new ICreate()\n");
		s.append("    {\n");
		writeParts(s);
		s.append("\n");
		s.append("      public Object create(Map<String, Object> values)\n");
		s.append("      {\n");
		s.append("        return new ICreate()\n");
		s.append("        {\n");
		// todo fix up factories
		s.append("        };\n");
		s.append("      }\n");
		s.append("      public void destroy(Object memento)\n");
		s.append("      {\n");
		s.append("      }\n");
		s.append("    };\n");
	}

	private Set<DEConnectorEnd> getOtherSides(DEConnectorEnd end)
	{
		Set<DEConnectorEnd> ends = new HashSet<DEConnectorEnd>();
		for (DeltaPair pair : next.getDeltas(ConstituentTypeEnum.DELTA_CONNECTOR).getConstituents(perspective))
		{
			DEConnector conn = pair.getConstituent().asConnector();
			for (int lp = 0; lp < 2; lp++)
			{
				DEConnectorEnd other = conn.makeConnectorEnd(perspective, next, lp);
				if (other.equals(end))
					ends.add(conn.makeConnectorEnd(perspective, next, 1-lp));
			}
		}
		return ends;
	}

	private Set<DEConnectorEnd> getOtherSides(DEPort port, DEPart part)
	{
		Set<DEConnectorEnd> ends = new HashSet<DEConnectorEnd>();
		for (DeltaPair pair : next.getDeltas(ConstituentTypeEnum.DELTA_CONNECTOR).getConstituents(perspective))
		{
			DEConnector conn = pair.getConstituent().asConnector();
			for (int lp = 0; lp < 2; lp++)
			{
				DEConnectorEnd other = conn.makeConnectorEnd(perspective, next, lp);
				if (other.getPort() == port && other.getPart() == part)
					ends.add(conn.makeConnectorEnd(perspective, next, 1-lp));
			}
		}
		return ends;
	}

	/**
	 * sort the ends by their possible indices NOTE: only returns internal ends --
	 * i.e. not to the port of the component
	 */
	public List<DEConnectorEnd> getSortedConnectorEnds()
	{
		List<DEConnectorEnd> ends = new ArrayList<DEConnectorEnd>();
		for (DeltaPair pair : next.getDeltas(ConstituentTypeEnum.DELTA_CONNECTOR).getConstituents(perspective))
		{
			DEConnector conn = pair.getConstituent().asConnector();
			for (int side = 0; side < 2; side++)
			{
				if (conn.makeConnectorEnd(perspective, next, side).getPart() != null
						&& conn.makeConnectorEnd(perspective, next, 1 - side).getPart() != null)
					ends.add(conn.makeConnectorEnd(perspective, next, side));
			}
		}

		Collections.sort(ends);
		return ends;
	}
	
	private void setRequired(StringBuilder s, DEConnectorEnd end, DEInterface iface, String get)
	{
		DEPort port = end.getPort();
		DEComponent other = end.getPart().getType();
		String partName = getUniqueConstituentName(next, end.getPart(), ConstituentTypeEnum.DELTA_PART);
		String portName = upper(getUniqueConstituentName(other, port, ConstituentTypeEnum.DELTA_PORT));
		boolean bean = other.isLegacyBean(perspective);
		if (bean)
			portName = makeSingular(portName);

		// get the interface on the other side
		String fullImpl = getImplementationName(iface);
		String implName = getAfterLastDot(fullImpl);
		if (port.isMany())
		{
			if (bean)
			{
				if (port.isForceBeanNoName())
					s.append("    " + partName + ".add(" + get + ");\n");
				else
					s.append("    " + partName + ".add" + portName + "(" + get + ");\n");
			}
			else
			{
				int setIndex = end.getIndex() == null ? -1 : end.getIndex();
				s.append("    " + partName + ".set" + portName + "_" + implName + "(" + get + ", " + setIndex + ");\n");
			}
		}
		else
		{
			if (bean)
				s.append("    " + partName + ".set" + portName + "(" + get + ");\n");
			else
				s.append("    " + partName + ".set" + portName + "_" + implName + "(" + get + ");\n");
		}
	}

	private String getProvided(DEConnectorEnd end, DEInterface iface)
	{
		StringBuilder s = new StringBuilder();
		DEPort port = end.getPort();
		DEComponent type = end.getPart().getType();
		String partName = getUniqueConstituentName(next, end.getPart(), ConstituentTypeEnum.DELTA_PART);
		String portName = upper(getUniqueConstituentName(type, port, ConstituentTypeEnum.DELTA_PORT));
		boolean bean = type.isLegacyBean(perspective);
		if (bean)
			portName = makeSingular(portName);

		Set<? extends DEInterface> ifaces = end.getPart().getType().getProvidedInterfaces(perspective, end.getPort());
		DEInterface provided = DEComponent.getOneMatch(perspective, iface, ifaces);		

		String fullImpl = getImplementationName(provided);
		String implName = getAfterLastDot(fullImpl);
		
		// get what should be provided
		List<DEPart> parts = new ArrayList<DEPart>();
		parts.add(end.getPart());
		Set<? extends DEInterface> required =
			next.getPortProvidedInterfacesInCompositionHierarchy(perspective, port, parts);
		String shouldProvide = DEComponent.getOneMatch(
				perspective,
				provided,
				required).getImplementationClass(perspective);
		
		if (port.isMany())
		{
			// won't be a bean
			int getIndex = end.getIndex() == null ? -1 : end.getIndex();
			s.append(partName + ".get" + portName + "_" + implName + "(" + shouldProvide + ".class, " + getIndex + ")");
		}
		else
		{
			if (bean)
			{
				if (port.isForceBeanMain())
					s.append(partName);
				else
					s.append(partName + ".get" + portName + "(" + shouldProvide + ".class)");
			}
			else
				s.append(partName + ".get" + portName + "_" + implName + "(" + shouldProvide + ".class)");
		}
		return s.toString();
	}
}
