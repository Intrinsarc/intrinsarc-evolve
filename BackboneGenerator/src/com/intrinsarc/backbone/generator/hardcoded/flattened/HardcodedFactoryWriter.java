package com.intrinsarc.backbone.generator.hardcoded.flattened;

import static com.intrinsarc.backbone.generator.hardcoded.common.WriterHelper.*;

import java.io.*;
import java.util.*;

import com.intrinsarc.backbone.generator.*;
import com.intrinsarc.backbone.generator.hardcoded.common.*;
import com.intrinsarc.backbone.nodes.*;
import com.intrinsarc.backbone.nodes.simple.*;
import com.intrinsarc.backbone.nodes.simple.internal.*;
import com.intrinsarc.backbone.runtime.api.*;
import com.intrinsarc.backbone.runtime.implementation.*;
import com.intrinsarc.deltaengine.base.*;

public class HardcodedFactoryWriter
{
	public int writeHardcodedFactory(
			BBSimpleElementRegistry registry,
			File real,
			File temp,
			String className,
			String pkgName,
			BBSimpleComponent simple,
			int factoryNumber,
			UniqueNamer namer,
			ExpandedTypeManager expander) throws BackboneGenerationException
	{
		// create the class
		BufferedWriter c = null;

		// register the initial classname, so we don't duplicate it
		namer.getUniqueName(className, className);

		try
		{
			c = new BufferedWriter(new FileWriter(temp));
			if (pkgName != null)
				c.write("package " + pkgName + ";");
			c.newLine();
			c.newLine();
			c.write("import com.intrinsarc.backbone.runtime.api.*;");
			c.newLine();
			c.newLine();
			c.write("/** generated by Evolve */");
			c.newLine();

			writeSingleFactory(registry, c, className, simple, factoryNumber, namer, expander);
			// possibly add in any expanded classes such as states and dispatchers
			c.write(expander.constructClasses());			
		}
		catch (IOException ex)
		{
			throw new BackboneGenerationException("Problem writing to file when writing hardcoded factory", null);
		}
		finally
		{
			try
			{
				if (c != null)
					c.close();
			} catch (IOException ex)
			{
				throw new BackboneGenerationException("Problem closing file when writing hardcoded factory", ex);
			}
		}
		
		// move the files over now to complete the generation
		if (real.exists() && LeafImplementationRefresher.identicalContents(real, temp))
		{
			temp.delete();
			return 0;
		}
		else
		{
			LeafImplementationRefresher.moveFile(temp, real);
			return 1;
		}
	}

	public void writeSingleFactory(BBSimpleElementRegistry registry, BufferedWriter c, String className,
			BBSimpleComponent simple, int factoryNumber, UniqueNamer namer, ExpandedTypeManager expander) throws IOException,
			BackboneGenerationException
	{
		List<Integer> referencedFactories = new ArrayList<Integer>();

		// create the class
		BBSimpleFactory factory = simple.getFactory(factoryNumber);
		BBSimpleComponent comp = factory.getComponent();

		if (factoryNumber == 0)
			c.write("public class " + className + " implements IHardcodedFactory");
		else
			c.write("class " + className + " implements IHardcodedFactory");
		c.newLine();
		c.write("{");
		c.newLine();
		if (factoryNumber != 0)
		{
			c.write("  private IHardcodedFactory parent;");
			c.newLine();
		}
		c.write("  private java.util.List<IHardcodedFactory> children;");
		c.newLine();

		// write out any attributes with default values and setters and getters
		if (factory.getAttributes() != null && !factory.getAttributes().isEmpty())
		{
			c.newLine();
			c.write("  // attributes");
			c.newLine();
			writeAttributes(c, factoryNumber, namer, factory, true);
		}

		// write out connection variables
		writeConnectors(registry, namer, factory, c, null, true);
		
		// handle the parts
		c.newLine();
		c.write(" // parts");
		c.newLine();
		Map<Integer, String> factoryClassNames = new HashMap<Integer, String>();
		for (BBSimplePart part : factory.getParts())
		{
			String partName = namer.getUniqueName(part);

			if (isFactoryPart(part))
			{
				// extract the factory number: perhaps look at simplifying
				int nextNumber = new Integer(part.getSlots().get(0).getEnvironmentAlias().getDefaultValue().get(0).getLiteral());
				referencedFactories.add(nextNumber);
				c.write("  private ICreate " + partName + " = new ICreate() {");
				c.newLine();
				c.write("    public Object create(java.util.Map<String, Object> values) {");
				c.newLine();
				// create the factory
				BBSimpleFactory nextFactory = simple.getFactory(nextNumber);
				BBSimpleComponent nextComp = nextFactory.getComponent();
				String nextClassName = namer.getUniqueName(new Object(), nextComp.getRawName() + "Factory");
				factoryClassNames.put(nextNumber, nextClassName);
				c.write("      " + nextClassName + " f = new " + nextClassName + "();");
				c.newLine();
				// NOTE: no need to set any slots -- they are catered for in the factory
				// itself
				c.write("      f.initialize(" + className + ".this, values);");
				c.newLine();
				c.write("      if (children == null)");
				c.newLine();
				c.write("        children = new java.util.ArrayList<IHardcodedFactory>();");
				c.newLine();
				c.write("      children.add(f);");
				c.newLine();
				c.newLine();
				c.write("      return f;");
				c.newLine();
				c.write("    }");
				c.newLine();
				// need to finish...
				c.write("    public void destroy(Object memento) { ((IHardcodedFactory) memento).destroy(); }");
				c.newLine();
				c.write("  };");
				c.newLine();
			}
			else
			{
				String implClass = part.getType().getImplementationClassName();
				String expanded = expander.formConstructionAndRemember(part, partName);
				if (expanded != null)
					c.write(expanded);
				else
					c.write("  private " + implClass + " " + partName + " = " + "new " + implClass + "()" + ";");
				c.newLine();
			}
		}

		// create methods for any ports which are visible to the outside
		// NOTE: the interface is not appended if this is factory 0, in order to
		// make the name more "robust"
		if (factoryNumber == 0)
		{
			String runPortGetMethod = writeVisiblePorts(registry, namer, factory, comp, c);
			
			// create a possible main for running
			if (runPortGetMethod != null)
			{
				c.newLine();
				c.write("  public static void main(String args[])");
				c.newLine();
				c.write("  {");
				c.newLine();
				c.write("    " + className + " factory = new " + className + "();");
				c.newLine();
				c.write("    if (factory.initialize(null, null)." + runPortGetMethod + "().run(args))");
				c.newLine();
				c.write("      factory.destroy(); // destroy the factory once the run method has completed");
				c.newLine();
				c.write("  }");
				c.newLine();
			}
		}
		
		c.newLine();
		c.write("  public " + className + "() {}");
		c.newLine();
		c.newLine();
		c.write("  public " + className + " initialize(IHardcodedFactory parent, java.util.Map<String, Object> values)");
		c.newLine();
		c.write("  {");
		c.newLine();
		if (factoryNumber != 0)
		{
			c.write("    this.parent = parent;");
			c.newLine();
		}

		// handle overriding the defaults using the hashmap
		if (factory.getAttributes() != null)
			for (BBSimpleAttribute attr : factory.getAttributes())
			{
				if (!isFactoryNumber(attr) && attr.getPosition() == PositionEnum.TOP)
				{
					String attrName = namer.getUniqueName(attr);
					String rawName = attr.getRawName();
					String impl = attr.getType().getImplementationClassName();
					String translated = PrimitiveHelper.stripJavaLang(impl);
					c.write("    if (values != null && values.containsKey(\"" + rawName + "\")) " + attrName +
							" = (" + translated + ") values.get(\"" + rawName + "\");");
					c.newLine();
				}
			}
		
		// handle initialization of non-top attributes
		writeAttributes(c, factoryNumber, namer, factory, false);
		
		// handle the slots
		for (BBSimplePart part : factory.getParts())
		{
			if (!isFactoryPart(part))
			{
				String partName = namer.getUniqueName(part);
				for (BBSimpleSlot slot : part.getSlots())
				{
					c.write("    " + partName + ".set" + upper(slot.getAttribute().getRawName()) + "(");
					c.write(namer.getUniqueName(slot.getEnvironmentAlias()));
					c.write(");");
					c.newLine();
				}
			}
		}

		// write the connectors
		StringWriter deletedConnectors = new StringWriter();
		BufferedWriter deleted = new BufferedWriter(deletedConnectors);
		writeConnectors(registry, namer, factory, c, deleted, false);

		// inform any lifecycle parts that we have initialized
		for (BBSimplePart part : factory.getParts())
			if (part.getType().hasLifecycleCallbacks())
			{
				String partName = namer.getUniqueName(part);
				c.write("    " + partName + ".afterInit();");
				c.newLine();
			}
		c.write("    return this;");
		c.newLine();
		c.write("  }");
		c.newLine();

		// write the destroy methods
		c.write("  public void childDestroyed(IHardcodedFactory child) { children.remove(child); }");
		c.newLine();
		c.newLine();
		
		c.write("  public void destroy()");
		c.newLine();
		c.write("  {");
		c.newLine();

		// tell the parent
		c.write("    destroyChildren(" + (factoryNumber == 0 ? "null" : "parent") + ", this, children);");
		c.newLine();

		// tell any parts we are about to delete them
		for (BBSimplePart part : factory.getParts())
			if (part.getType().hasLifecycleCallbacks())
			{
				String partName = namer.getUniqueName(part);
				c.write("    " + partName + ".beforeDelete();");
				c.newLine();
			}

		// remove any connectors
		deleted.flush();
		c.write(deletedConnectors.toString());

		// finish the destroy method
		c.write("  }");
		c.newLine();
		c.newLine();

		// a utility method
		if (factoryNumber == 0)
		{
			c.write("  static void destroyChildren(IHardcodedFactory parent, IHardcodedFactory me, java.util.List<IHardcodedFactory> children)");
			c.newLine();
			c.write("  {");
			c.newLine();
			// tell the parent
			c.write("    if (parent != null)");
			c.newLine();
			c.write("      parent.childDestroyed(me);");
			c.newLine();
			// tell any children to destroy themselves
			c.write("    if (children != null) {");
			c.newLine();
			c.write("      java.util.List<IHardcodedFactory> copy = new java.util.ArrayList<IHardcodedFactory>(children);"); c.newLine();
			c.write("      java.util.Collections.reverse(copy);"); c.newLine();
			c.write("      for (IHardcodedFactory f : copy)"); c.newLine();
			c.write("        f.destroy();"); c.newLine();
			c.write("    }");
			c.newLine();		
			c.write("  }");
			c.newLine();
		}

		// write any referenced factories
		if (!referencedFactories.isEmpty())
		{
			c.newLine();
			c.write("// flattened factories");
			c.newLine();
			for (Integer f : referencedFactories)
			{
				String nextClassName = factoryClassNames.get(f);
				writeSingleFactory(registry, c, nextClassName, simple, f, namer, expander);
			}
		}
		
		// finish off the class
		c.write("}");
		c.newLine();
	}

	private void writeAttributes(
			BufferedWriter c,
			int factoryNumber,
			UniqueNamer namer,
			BBSimpleFactory factory,
			boolean top) throws IOException
	{
		for (BBSimpleAttribute attr : factory.getAttributes())
		{
			PositionEnum position = attr.getPosition();
			if (!isFactoryNumber(attr) && (position != PositionEnum.TOP || top))
			{
				String attrName = namer.getUniqueName(attr);
				String impl = attr.getType().getImplementationClassName();
				String translatedImpl = PrimitiveHelper.stripJavaLang(PrimitiveHelper.translateLongToShortPrimitive(impl));
				if (top)
					c.write("  private " + translatedImpl + " ");
				else
					c.write("    ");
				c.write(attrName);
				List<BBSimpleParameter> def = attr.getDefaultValue();
				if (factoryNumber == 0 && attr.getDefaultValue() != null)
				{
					def = attr.getDefaultValue();
				}
				if (def == null || position != PositionEnum.TOP && top)
				{
					c.write(";");
					c.newLine();
				}
				else
				{
					c.write(" = ");
					writeInitializer(attr.getType(), namer, c, impl, def);
					c.newLine();

					if (top)
					{
						// make a setter or getter function for top attributes
						if (!attr.isReadOnly())
						{
							c.write("  public void set" + upper(attrName) + "(" + translatedImpl + " " + attrName + ") { this."
									+ attrName + " = " + attrName + "; }");
							c.newLine();
						}
						if (!attr.isWriteOnly())
						{
							c.write("  public " + translatedImpl + " get" + upper(attrName) + "() { return " + attrName + "; }");
							c.newLine();
						}
					}
				}
			}
		}
	}

	/** do this in a better way */
	private boolean isFactoryNumber(BBSimpleAttribute attr)
	{
		return attr.getRawName().equals("factoryNumber");
	}

	/** do this better */
	private boolean isFactoryPart(BBSimplePart part)
	{
		String implClass = part.getType().getImplementationClassName();
		return implClass.equals(Creator.class.getName());
	}

	private void writeConnectors(
			BBSimpleElementRegistry registry,
			UniqueNamer namer,
			BBSimpleFactory factory,
			BufferedWriter c,
			BufferedWriter d,
			boolean declarations) throws IOException
	{
		// handle the connectors
		// cache the provided for each port
		List<BBSimpleConnectorEnd> ends = factory.getInternalSortedConnectorEnds();
		if (ends.isEmpty())
			return;
		
		if (declarations)
		{
			c.newLine();
			c.write("  // connectors");
			c.newLine();
		}
		for (BBSimpleConnectorEnd end : ends)
		{
			String partName = namer.getUniqueName(end.getPart());
			BBSimplePort port = end.getPort();
			for (BBSimpleInterface p : port.getProvides())
			{
				String originalImpl = p.getImplementationClassName();
				String impl = end.getPart().getRequiredImplementationNameForProvided(registry, port, p);
				String shortOriginalImpl = getAfterLastDot(originalImpl);
				// generate a variable
				String vname = namer.getUniqueName("var_" + partName + "_" + namer.getUniqueName(port) + "_" + shortOriginalImpl + "_"
						+ namer.getUniqueName(end.getConnector()), "c");

				String cast = originalImpl.equals(impl) ? "" : ("(" + impl + ") ");
				if (declarations)
				{
					c.write("  private " + impl + " " + vname + ";");
					c.newLine();
				}
				else
				{
					if (port.isBeanMain())
					{
						c.write("    " + vname + " = " + partName + ";");
					}
					else
					{
						PortMethodHelper ph = new PortMethodHelper(registry.getPerspective(), port, originalImpl);
						ph.resolveGetMethodNames();

						String wants = port.isWantsRequiredWhenProviding() ? (impl + ".class") : ""; 
						if (!port.isIndexed())
						{							
							c.write("    " + vname + " = " + cast + partName + "." + ph.getGetSingleName() + "(" + wants);
						}
						else
						{
							c.write("    " + vname + " = " + cast + partName + "." + ph.getGetIndexedName() + "(" + wants);
							if (end.getIndex() != null)
							{
									c.write(", " + end.getIndex());
							}
							else
								if (end.getPort().isIndexed() && end.isTakeNext())
									c.write(", -1");
						}
						c.write(");");
					}

					c.newLine();
				}
			}
		}
		
		if (declarations)
			return;

		for (BBSimpleConnectorEnd end : ends)
		{
			String partName = namer.getUniqueName(end.getPart());
			BBSimplePort port = end.getPort();
			// look to the other side for the variable name
			BBSimpleConnectorEnd otherEnd = end.getConnector().makeSimpleConnectorEnd(1 - end.getSide());
			BBSimplePort otherPort = otherEnd.getPort();
			BBSimplePart otherPart = otherEnd.getPart();
			String otherPartName = namer.getUniqueName(otherPart);

			for (BBSimpleInterface p : port.getRequires())
			{
				PortMethodHelper ph = new PortMethodHelper(registry.getPerspective(), port, p.getImplementationClassName());
				ph.resolveSetMethodNames();

				Set<? extends DEInterface> provided =
					otherPort.getOwner().getComplex().asComponent().getProvidedInterfaces(
							registry.getPerspective(),
							otherPort.getComplexPort());
				BBSimpleInterface otherInterface = registry.retrieveInterface(
						DEComponent.getOneMatch(registry.getPerspective(), p.getComplex(), provided));
				String shortOtherSideImpl = getAfterLastDot(otherInterface.getImplementationClassName());

				// get back the reference
				String vname = namer.getUniqueName("var_" + otherPartName + "_" + namer.getUniqueName(otherPort) + "_"
						+ shortOtherSideImpl + "_" + namer.getUniqueName(end.getConnector()), "c");

				if (end.getIndex() != null)
				{
					c.write("    " + partName + "." + ph.getAddIndexedName() + "(" + vname);
					c.write(", " + end.getIndex());
				}
				else
				if (port.isIndexed())
				{
					c.write("    " + partName + "." + ph.getAddNoIndexedName() + "(" + vname);
				}
				else
				{
					c.write("    " + partName + "." + ph.getSetSingleName() + "(" + vname);
				}
				c.write(");");
				c.newLine();
				
				// handle removal
				if (port.isIndexed())
				{
					d.write("    " + partName + "." + ph.getRemoveManyName() + "(" + vname + ");");
				}
				else
					d.write("    " + partName + "." + ph.getSetSingleName() + "(null);");						
				possiblyRemoveOtherSide(registry, namer, d, otherEnd, vname, p);

				d.newLine();
			}
		}
	}

	private void possiblyRemoveOtherSide(BBSimpleElementRegistry registry, UniqueNamer namer, BufferedWriter d, BBSimpleConnectorEnd end, String vname, BBSimpleInterface provides)
		
	throws IOException
	{
		BBSimplePort port = end.getPort();
		PortMethodHelper ph = new PortMethodHelper(registry.getPerspective(), port, provides.getImplementationClassName());
		ph.resolveSetMethodNames();

		if (port.isBeanMain() || !port.isIndexed())
			return;
			
		BBSimplePart part = end.getPart();
		String partName = namer.getUniqueName(part);

		d.newLine();
		d.write("    " + partName + "." + ph.getRemoveManyName() + "(" + vname + ");");
	}

	private void writeInitializer(BBSimpleElement attrType, UniqueNamer namer, BufferedWriter c, String impl, List<BBSimpleParameter> def)
			throws IOException
	{
		String translated = PrimitiveHelper.translateLongToShortPrimitive(impl);
		String primTrans = PrimitiveHelper.stripJavaLang(translated);
		boolean primitive = !impl.equals(translated);

		BBSimpleAttribute oneAttr = def.size() == 1 ? def.get(0).getAttribute() : null;
		if (isDefault(def))
		{
			c.write("new " + primTrans + "()");
		}
		else
		if (isNull(def))
		{
			c.write("null");
		}
		else
		if ("String".equals(primTrans) && def.size() == 1 && def.get(0).getLiteral() != null)
		{
			c.write(def.get(0).getLiteral());
		}
		else
		if (oneAttr != null && oneAttr.getType() == attrType)
		{
			c.write(namer.getUniqueName(oneAttr));
		}
		else
		{
			if (!primitive)
				c.write("new " + primTrans + "(");
			boolean start = true;
			for (BBSimpleParameter p : def)
			{
				if (!start)
					c.write(", ");
				start = false;
				if (p.getLiteral() != null)
				{
					c.write(p.getLiteral());
				}
				else
				{
					c.write(namer.getUniqueName(p.getAttribute()));
				}
			}
			if (!primitive)
				c.write(")");
		}
		
		// finish the statement
		c.write(";");
	}

	private boolean isNull(List<BBSimpleParameter> def)
	{
		return def.size() == 1 && "null".equals(def.get(0).getLiteral()); 
	}

	/**
	 * has a default value been requested?
	 */
	private boolean isDefault(List<BBSimpleParameter> def)
	{
		return def.size() == 1 && "default".equals(def.get(0).getLiteral()); 
	}

	private String writeVisiblePorts(BBSimpleElementRegistry registry, UniqueNamer namer, BBSimpleFactory factory, BBSimpleComponent comp, BufferedWriter c) throws BackboneGenerationException, IOException
	{
		String runPortGetMethod = null;
		
		// handle visible ports
		for (BBSimplePort port : comp.getPorts())
		{
			BBSimpleConnector matchingConn = null;
			int matchingEnd = 0;

			// get the (hopefully) single connector for this
			for (BBSimpleConnector conn : factory.getConnectors())
			{
				int end = conn.getEndNumber(null, port);
				if (end != -1)
				{
					// if we already have a match, we have a problem
					if (matchingConn != null)
						throw new BackboneGenerationException(
								"Must have a single connector for external port " + port.getName(), comp);

					matchingConn = conn;
					matchingEnd = end;
				}
			}

			// if we don't have a connector, this is bad
			if (matchingConn == null)
				throw new BackboneGenerationException("Cannot find single connector for external port " + port.getName(), comp);

			// the ports must be non-indexed
			BBSimpleConnectorEnd end = matchingConn.makeSimpleConnectorEnd(1 - matchingEnd);
			if (port.isIndexed() || end.getPort().isIndexed())
				throw new BackboneGenerationException("External port cannot be indexed " + port.getName(), comp);

			// write out the port getter or setter
			String partName = namer.getUniqueName(end.getPart());

			for (BBSimpleInterface p : port.getProvides())
			{
				PortMethodHelper ph = new PortMethodHelper(registry.getPerspective(), port, p.getImplementationClassName());
				ph.resolveGetMethodNames();

				// is this the run port?
				if (p.getImplementationClassName().equals(IRun.class.getCanonicalName()))
				{
					runPortGetMethod = ph.getGetSingleName();
				}
					
				c.write("  public " + p.getImplementationClassName() + " " + ph.getGetSingleName() + "()");
				if (port.isBeanMain())
				{
					c.write(" { return " + partName + "; }");
				}
				else
				{
					c.write(" { return " + partName + "." + ph.getGetSingleName() + "(); }");
				}
				c.newLine();
			}
			for (BBSimpleInterface r : port.getRequires())
			{
				PortMethodHelper ph = new PortMethodHelper(registry.getPerspective(), port, r.getImplementationClassName());
				PortMethodHelper pho = new PortMethodHelper(registry.getPerspective(), end.getPort(), r.getImplementationClassName());
				ph.resolveSetMethodNames();
				pho.resolveSetMethodNames();

				c.write("  public void " + ph.getSetSingleName() + "(" + r.getImplementationClassName() + " val)");
				c.write(" { " + partName + "." + pho.getSetSingleName() + "(val); }");

				c.newLine();
			}
		}
		return runPortGetMethod;
	}
}
