package com.intrinsarc.backbone.generator.hardcoded.flattened;

import static com.intrinsarc.backbone.generator.hardcoded.common.WriterHelper.*;

import java.io.*;
import java.util.*;

import com.intrinsarc.backbone.generator.*;
import com.intrinsarc.backbone.generator.hardcoded.common.*;
import com.intrinsarc.backbone.nodes.*;
import com.intrinsarc.backbone.nodes.simple.*;
import com.intrinsarc.backbone.nodes.simple.internal.*;
import com.intrinsarc.backbone.runtime.implementation.*;
import com.intrinsarc.deltaengine.base.*;

public class HardcodedFactoryWriter
{
	public void writeHardcodedFactory(BBSimpleElementRegistry registry, File write, String className, String pkgName,
			BBSimpleComponent simple, int factoryNumber, UniqueNamer namer, ExpandedTypeManager expander)
			throws BackboneGenerationException
	{
		// create the class
		BufferedWriter c = null;

		// register the initial classname, so we don't duplicate it
		namer.getUniqueName(className, className);

		try
		{
			c = new BufferedWriter(new FileWriter(write));
			if (pkgName != null)
				c.write("package " + pkgName + ";");
			c.newLine();
			c.newLine();
			c.write("import com.intrinsarc.backbone.runtime.api.*;");
			c.newLine();
			c.newLine();
			c.write("/** generated by Evolve */");
			c.newLine();

			writeSingleFactory(registry, c, className, simple, factoryNumber, namer, expander);
			// possibly add in any expanded classes such as states and dispatchers
			c.write(expander.constructClasses());
		}
		catch (IOException ex)
		{
			throw new BackboneGenerationException("Problem writing to file when writing hardcoded factory", null);
		} finally
		{
			try
			{
				if (c != null)
					c.close();
			} catch (IOException ex)
			{
				throw new BackboneGenerationException("Problem closing file when writing hardcoded factory", ex);
			}
		}
	}

	public void writeSingleFactory(BBSimpleElementRegistry registry, BufferedWriter c, String className,
			BBSimpleComponent simple, int factoryNumber, UniqueNamer namer, ExpandedTypeManager expander) throws IOException,
			BackboneGenerationException
	{
		List<Integer> referencedFactories = new ArrayList<Integer>();

		// create the class
		BBSimpleFactory factory = simple.getFactory(factoryNumber);
		BBSimpleComponent comp = factory.getComponent();

		if (factoryNumber == 0)
			c.write("public class " + className + " implements IHardcodedFactory");
		else
			c.write("class " + className + " implements IHardcodedFactory");
		c.newLine();
		c.write("{");
		c.newLine();
		if (factoryNumber != 0)
		{
			c.write("  private IHardcodedFactory parent;");
			c.newLine();
		}
		c.write("  private java.util.List<IHardcodedFactory> children;");
		c.newLine();

		// write out any attributes with default values and setters and getters
		if (factory.getAttributes() != null && !factory.getAttributes().isEmpty())
		{
			c.newLine();
			c.write("  // attributes");
			c.newLine();
			writeAttributes(c, factoryNumber, namer, factory, true);
		}

		// write out connection variables
		writeConnectors(registry, namer, factory, c, null, true);

		// handle the parts
		c.newLine();
		c.write(" // parts");
		c.newLine();
		Map<Integer, String> factoryClassNames = new HashMap<Integer, String>();
		for (BBSimplePart part : factory.getParts())
		{
			String partName = namer.getUniqueName(part);

			if (isFactoryPart(part))
			{
				// extract the factory number: perhaps look at simplifying
				int nextNumber = new Integer(part.getSlots().get(0).getEnvironmentAlias().getDefaultValue().get(0).getLiteral());
				referencedFactories.add(nextNumber);
				c.write("  private ICreate " + partName + " = new ICreate() {");
				c.newLine();
				c.write("    public Object create(java.util.Map<String, Object> values) {");
				c.newLine();
				// create the factory
				BBSimpleFactory nextFactory = simple.getFactory(nextNumber);
				BBSimpleComponent nextComp = nextFactory.getComponent();
				String nextClassName = namer.getUniqueName(new Object(), nextComp.getRawName() + "Factory");
				factoryClassNames.put(nextNumber, nextClassName);
				c.write("      " + nextClassName + " f = new " + nextClassName + "();");
				c.newLine();
				// NOTE: no need to set any slots -- they are catered for in the factory
				// itself
				c.write("      f.initialize(" + className + ".this, values);");
				c.newLine();
				c.write("      if (children == null)");
				c.newLine();
				c.write("        children = new java.util.ArrayList<IHardcodedFactory>();");
				c.newLine();
				c.write("      children.add(f);");
				c.newLine();
				c.newLine();
				c.write("      return f;");
				c.newLine();
				c.write("    }");
				c.newLine();
				// need to finish...
				c.write("    public void destroy(Object memento) { ((IHardcodedFactory) memento).destroy(); }");
				c.newLine();
				c.write("  };");
				c.newLine();
			}
			else
			{
				String implClass = part.getType().getImplementationClassName();
				String expanded = expander.formConstructionAndRemember(part, partName);
				if (expanded != null)
					c.write(expanded);
				else
					c.write("  private " + implClass + " " + partName + " = " + "new " + implClass + "()" + ";");
				c.newLine();
			}
		}

		// create methods for any ports which are visible to the outside
		// NOTE: the interface is not appended if this is factory 0, in order to
		// make the name more "robust"
		if (factoryNumber == 0)
			writeVisiblePorts(namer, factory, comp, c, true);
		
		c.newLine();
		c.write("  public " + className + "() {}");
		c.newLine();
		c.newLine();
		c.write("  public " + className + " initialize(IHardcodedFactory parent, java.util.Map<String, Object> values)");
		c.newLine();
		c.write("  {");
		c.newLine();
		if (factoryNumber != 0)
		{
			c.write("    this.parent = parent;");
			c.newLine();
		}

		// handle overriding the defaults using the hashmap
		if (factory.getAttributes() != null)
			for (BBSimpleAttribute attr : factory.getAttributes())
			{
				if (!isFactoryNumber(attr) && attr.getPosition() == PositionEnum.TOP)
				{
					String attrName = namer.getUniqueName(attr);
					String rawName = attr.getRawName();
					String impl = attr.getType().getImplementationClassName();
					String translated = PrimitiveHelper.stripJavaLang(impl);
					c.write("    if (values != null && values.containsKey(\"" + rawName + "\")) " + attrName + " = new Attribute<" + translated + ">((" + translated
							+ ") values.get(\"" + rawName + "\"));");
					c.newLine();
				}
			}
		
		// handle initialization of non-top attributes
		writeAttributes(c, factoryNumber, namer, factory, false);
		
		// handle the slots
		for (BBSimplePart part : factory.getParts())
		{
			if (!isFactoryPart(part))
			{
				String partName = namer.getUniqueName(part);
				for (BBSimpleSlot slot : part.getSlots())
				{
					if (part.getType().isBean())
					{
						c.write("    " + partName + ".set" + upper(slot.getAttribute().getRawName()) + "(");
						c.write(namer.getUniqueName(slot.getEnvironmentAlias()) + ".get()");
					}
					else
					{
						c.write("    " + partName + ".set" + upper(slot.getAttribute().getRawName()) + "(");
						c.write(namer.getUniqueName(slot.getEnvironmentAlias()));
					}
					c.write(");");
					c.newLine();
				}
			}
		}

		// write the connectors
		StringWriter deletedConnectors = new StringWriter();
		BufferedWriter deleted = new BufferedWriter(deletedConnectors);
		writeConnectors(registry, namer, factory, c, deleted, false);

		// inform any lifecycle parts that we have initialized
		for (BBSimplePart part : factory.getParts())
			if (part.getType().hasLifecycleCallbacks())
			{
				String partName = namer.getUniqueName(part);
				c.write("    " + partName + ".afterInit();");
				c.newLine();
			}
		c.write("    return this;");
		c.newLine();
		c.write("  }");
		c.newLine();

		// write the destroy methods
		c.write("  public void childDestroyed(IHardcodedFactory child) { children.remove(child); }");
		c.newLine();
		c.newLine();
		
		c.write("  public void destroy()");
		c.newLine();
		c.write("  {");
		c.newLine();
		if (factoryNumber != 0)
		{
			// tell the parent
			c.write("    destroyChildren(parent, this, children);");
			c.newLine();
	
			// tell any parts we are about to delete them
			for (BBSimplePart part : factory.getParts())
				if (part.getType().hasLifecycleCallbacks())
				{
					String partName = namer.getUniqueName(part);
					c.write("    " + partName + ".beforeDelete();");
					c.newLine();
				}
	
			// remove any connectors
			deleted.flush();
			c.write(deletedConnectors.toString());
		}

		// finish the destroy method
		c.write("  }");
		c.newLine();
		c.newLine();

		// a utility method
		if (factoryNumber == 0)
		{
			c.write("  static void destroyChildren(IHardcodedFactory parent, IHardcodedFactory me, java.util.List<IHardcodedFactory> children)");
			c.newLine();
			c.write("  {");
			c.newLine();
			// tell the parent
			c.write("    parent.childDestroyed(me);");
			c.newLine();
			// tell any children to destroy themselves
			c.write("    if (children != null) {");
			c.newLine();
			c.write("      java.util.List<IHardcodedFactory> copy = new java.util.ArrayList<IHardcodedFactory>(children);"); c.newLine();
			c.write("      java.util.Collections.reverse(copy);"); c.newLine();
			c.write("      for (IHardcodedFactory f : copy)"); c.newLine();
			c.write("        f.destroy();"); c.newLine();
			c.write("    }");
			c.newLine();		
			c.write("  }");
			c.newLine();
		}

		// write any referenced factories
		if (!referencedFactories.isEmpty())
		{
			c.newLine();
			c.write("// flattened factories");
			c.newLine();
			for (Integer f : referencedFactories)
			{
				String nextClassName = factoryClassNames.get(f);
				writeSingleFactory(registry, c, nextClassName, simple, f, namer, expander);
			}
		}
		
		// finish off the class
		c.write("}");
		c.newLine();
	}

	private void writeAttributes(
			BufferedWriter c,
			int factoryNumber,
			UniqueNamer namer,
			BBSimpleFactory factory,
			boolean top) throws IOException
	{
		for (BBSimpleAttribute attr : factory.getAttributes())
		{
			PositionEnum position = attr.getPosition();
			if (!isFactoryNumber(attr) && (position != PositionEnum.TOP || top))
			{
				String attrName = namer.getUniqueName(attr);
				String impl = attr.getType().getImplementationClassName();
				String translatedImpl = PrimitiveHelper.translateLongToShortPrimitive(impl);
				if (top)
					c.write("  private Attribute<" + PrimitiveHelper.stripJavaLang(impl) + "> ");
				else
					c.write("    ");
				c.write(attrName);
				List<BBSimpleParameter> def = attr.getDefaultValue();
				if (factoryNumber == 0 && attr.getDefaultValue() != null)
				{
					def = attr.getDefaultValue();
				}
				if (def == null || position != PositionEnum.TOP && top)
				{
					c.write(";");
					c.newLine();
				}
				else
				{
					c.write(" = ");
					writeInitializer(namer, c, impl, def);
					c.newLine();

					if (top)
					{
						// make a setter or getter function for top attributes
						if (!attr.isReadOnly())
						{
							c.write("  public void set" + upper(attrName) + "(" + translatedImpl + " " + attrName + ") { this."
									+ attrName + ".set(" + attrName + "); }");
							c.newLine();
						}
						if (!attr.isWriteOnly())
						{
							c.write("  public " + translatedImpl + " get" + upper(attrName) + "() { return " + attrName + ".get(); }");
							c.newLine();
						}
					}
				}
			}
		}
	}

	/** do this in a better way */
	private boolean isFactoryNumber(BBSimpleAttribute attr)
	{
		return attr.getRawName().equals("factoryNumber");
	}

	/** do this better */
	private boolean isFactoryPart(BBSimplePart part)
	{
		String implClass = part.getType().getImplementationClassName();
		return implClass.equals(Creator.class.getName());
	}

	private void writeConnectors(
			BBSimpleElementRegistry registry,
			UniqueNamer namer,
			BBSimpleFactory factory,
			BufferedWriter c,
			BufferedWriter d,
			boolean declarations) throws IOException
	{
		// handle the connectors
		// cache the provided for each port
		List<BBSimpleConnectorEnd> ends = factory.getInternalSortedConnectorEnds();
		if (ends.isEmpty())
			return;
		
		if (declarations)
		{
			c.newLine();
			c.write("  // connectors");
			c.newLine();
		}
		for (BBSimpleConnectorEnd end : ends)
		{
			boolean bean = end.getPart().getType().isBean();
			String partName = namer.getUniqueName(end.getPart());
			BBSimplePort port = end.getPort();
			for (BBSimpleInterface p : port.getProvides())
			{
				String originalImpl = p.getImplementationClassName();
				String impl = end.getPart().getRequiredImplementationNameForProvided(registry, port, p);
				String shortOriginalImpl = getAfterLastDot(originalImpl);
				// generate a variable
				String vname = namer.getUniqueName("var_" + partName + "_" + namer.getUniqueName(port) + "_" + shortOriginalImpl + "_"
						+ namer.getUniqueName(end.getConnector()), "c");
				String name = upper(port.getRawName());

				if (bean || isFactoryPart(end.getPart()))
				{
					if (declarations)
					{
						c.write("  private " + impl + " " + vname + ";");
						c.newLine();						
					}
					else
					{
						c.write("    " + vname + " = " + partName + ";");
						c.newLine();
					}
				}
				else
				{
					String methodName = "get" + name + "_" + shortOriginalImpl;
					String cast = originalImpl.equals(impl) ? "" : ("(" + impl + ") ");
					if (declarations)
					{
						c.write("  private " + impl + " " + vname + ";");
						c.newLine();
					}
					else
					{
						c.write("    " + vname + " = " + cast + partName + "." + methodName + "(" + impl + ".class");
						if (end.getIndex() != null)
						{
								c.write(", " + end.getIndex());
						}
						else
							if (end.getPort().isIndexed() && end.isTakeNext())
								c.write(", -1");							

						c.write(");");
						c.newLine();
					}
				}
			}
		}
		
		if (declarations)
			return;

		for (BBSimpleConnectorEnd end : ends)
		{
			boolean bean = end.getPart().getType().isBean();
			String partName = namer.getUniqueName(end.getPart());
			BBSimplePort port = end.getPort();
			// look to the other side for the variable name
			BBSimpleConnectorEnd otherEnd = end.getConnector().makeSimpleConnectorEnd(1 - end.getSide());
			BBSimplePort otherPort = otherEnd.getPort();
			BBSimplePart otherPart = otherEnd.getPart();
			String otherPartName = namer.getUniqueName(otherPart);

			for (BBSimpleInterface p : port.getRequires())
			{
				String impl = p.getImplementationClassName();
				String shortImpl = getAfterLastDot(impl);

				Set<? extends DEInterface> provided =
					otherPort.getOwner().getComplex().asComponent().getProvidedInterfaces(
							registry.getPerspective(),
							otherPort.getComplexPort());
				BBSimpleInterface otherInterface = registry.retrieveInterface(
						DEComponent.getOneMatch(registry.getPerspective(), p.getComplex(), provided));
				String shortOtherSideImpl = getAfterLastDot(otherInterface.getImplementationClassName());

				// get back the reference
				String vname = namer.getUniqueName("var_" + otherPartName + "_" + namer.getUniqueName(otherPort) + "_"
						+ shortOtherSideImpl + "_" + namer.getUniqueName(end.getConnector()), "c");

				String name = upper(port.getRawName());

				if (bean)
				{
					if (port.getComplexPort().isBeanNoName())
					{
						c.write("    " + partName + ".add(" + vname + ");");
						d.write("    " + partName + ".remove(" + vname + ");");
						possiblyRemove(namer, d, otherEnd, vname, p);
					}
					else if (port.isIndexed())
					{
						c.write("    " + partName + ".add" + makeSingular(name) + "(" + vname + ");");
						d.write("    " + partName + ".remove" + makeSingular(name) + "(" + vname + ");");
						possiblyRemove(namer, d, otherEnd, vname, p);
					}
					else
					{
						c.write("    " + partName + ".set" + name + "(" + vname + ");");
						d.write("    " + partName + ".set" + name + "(null);");
						possiblyRemove(namer, d, otherEnd, vname, p);
					}
					c.newLine();
					d.newLine();
				}
				else
				{
					String methodName = "set" + name + "_" + shortImpl;
					c.write("    " + partName + "." + methodName + "(" + vname);
					if (end.getIndex() != null)
					{
						c.write(", " + end.getIndex());
						d.write("    " + partName + ".remove" + name + "_" + shortImpl + "(" + vname + ");");
						possiblyRemove(namer, d, otherEnd, vname, p);
					}
					else
					if (port.isIndexed())
					{
						c.write(", -1");
						d.write("    " + partName + ".remove" + name + "_" + shortImpl + "(" + vname + ");");
						possiblyRemove(namer, d, otherEnd, vname, p);
					}
					else
					{
						d.write("    " + partName + ".set" + name + "_" + shortImpl + "(null);");						
						possiblyRemove(namer, d, otherEnd, vname, p);
					}
					c.write(");");
					c.newLine();
					d.newLine();
				}
			}
		}
	}

	private void possiblyRemove(UniqueNamer namer, BufferedWriter d, BBSimpleConnectorEnd end, String vname, BBSimpleInterface provides)
		throws IOException
	{
		BBSimplePort port = end.getPort();
		BBSimplePart part = end.getPart();
		String partName = namer.getUniqueName(part);
		String impl = provides.getImplementationClassName();
		String shortImpl = getAfterLastDot(impl);

		boolean bean = part.getType().isBean();
		String name = upper(port.getRawName());

		if (bean)
		{
			if (port.getComplexPort().isBeanNoName())
			{
				d.newLine();
				d.write("    " + partName + ".remove(" + vname + ");");
			}
			else if (port.isIndexed())
			{
				d.newLine();
				d.write("    " + partName + ".remove" + makeSingular(name) + "(" + vname + ");");
			}
		}
		else
		{
			if (end.getIndex() != null)
			{
				d.newLine();
				d.write("    " + partName + ".remove" + name + "_" + shortImpl + "(" + vname + ");");
			}
			else
			if (port.isIndexed())
			{
				d.newLine();
				d.write("    " + partName + ".remove" + name + "_" + shortImpl + "(" + vname + ");");
			}
		}
	}

	private String makeSingular(String name)
	{
		// remove a possible 's'
		if (name.endsWith("s") && name.length() > 1)
			return name.substring(0, name.length() - 1);
		return name;
	}

	private void writeInitializer(UniqueNamer namer, BufferedWriter c, String impl, List<BBSimpleParameter> def)
			throws IOException
	{
		String translated = PrimitiveHelper.translateLongToShortPrimitive(impl);
		boolean primitive = !impl.equals(translated);
		String primTrans = PrimitiveHelper.stripJavaLang(impl);
		c.write("new Attribute<" + primTrans + ">(");

		if (isDefault(def))
		{
			c.write("new " + primTrans + "());");
		}
		else
		{
			if (!primitive)
				c.write("new " + impl + "(");
			boolean start = true;
			for (BBSimpleParameter p : def)
			{
				if (!start)
					c.write(", ");
				start = false;
				if (p.getLiteral() != null)
				{
					c.write(p.getLiteral());
				}
				else
				{
					c.write(namer.getUniqueName(p.getAttribute()));
					if (!p.getAttribute().getType().isBean())
						c.write(".get()");
				}
			}
			if (primitive)
				c.write(");");
			else
				c.write("));");
		}
	}

	/**
	 * has a default value been requested?
	 */
	private boolean isDefault(List<BBSimpleParameter> def)
	{
		if (def.size() != 1)
			return false;
		return def.get(0).getLiteral() != null && def.get(0).getLiteral().equals("default");
	}

	private void writeVisiblePorts(UniqueNamer namer, BBSimpleFactory factory, BBSimpleComponent comp, BufferedWriter c,
			boolean suppressInterfaceOnMethod) throws BackboneGenerationException, IOException
	{
		// handle visible ports
		for (BBSimplePort port : comp.getPorts())
		{
			BBSimpleConnector matchingConn = null;
			int matchingEnd = 0;

			// get the (hopefully) single connector for this
			for (BBSimpleConnector conn : factory.getConnectors())
			{
				int end = conn.getEndNumber(null, port);
				if (end != -1)
				{
					// if we already have a match, we have a problem
					if (matchingConn != null)
						throw new BackboneGenerationException("Must have a single connector for external port " + port.getName(),
								comp);

					matchingConn = conn;
					matchingEnd = end;
				}
			}

			// if we don't have a connector, this is bad
			if (matchingConn == null)
				throw new BackboneGenerationException("Cannot find single connector for external port " + port.getName(), comp);

			// the ports must be non-indexed
			BBSimpleConnectorEnd end = matchingConn.makeSimpleConnectorEnd(1 - matchingEnd);
			if (port.isIndexed() || end.getPort().isIndexed())
				throw new BackboneGenerationException("External port cannot be indexed " + port.getName(), comp);

			// write out the port getter or setter
			String name = upper(port.getRawName());
			boolean bean = end.getPart().getType().isBean();
			String partName = namer.getUniqueName(end.getPart());

			for (BBSimpleInterface p : port.getProvides())
			{
				String fullName = partName + "_" + getAfterLastDot(p.getImplementationClassName());
				String desiredName = fullName;
				if (suppressInterfaceOnMethod)
					desiredName = "get" + name;
				String methodName = namer.getUniqueName(fullName, desiredName);
				c.write("  public " + p.getImplementationClassName() + " " + methodName + "()");
				if (bean)
				{
					// beans only provide themselves...
					c.write(" { return " + partName + "; }");
				}
				else
				{
					String originalImpl = p.getImplementationClassName();
					String shortOriginalImpl = getAfterLastDot(originalImpl);
					c.write(" { return " + partName + "." + methodName + "_" + shortOriginalImpl + "(null); }");
				}
				c.newLine();
			}
			for (BBSimpleInterface r : port.getRequires())
			{
				String desiredName = "set" + name;
				String fullName = partName + "_" + getAfterLastDot(r.getImplementationClassName());
				String methodName = namer.getUniqueName(fullName, desiredName);
				c.write("  public void " + methodName + "(" + r.getImplementationClassName() + " val)");
				if (bean)
				{
					// beans only provide themselves...
					c.write(" { " + partName + ".set" + name + "(val); }");
				}
				else
				{
					String originalImpl = r.getImplementationClassName();
					String shortOriginalImpl = getAfterLastDot(originalImpl);
					c.write(" { " + partName + "." + methodName + "_" + shortOriginalImpl + "(val); }");
				}

				c.newLine();
			}
		}
	}
}
