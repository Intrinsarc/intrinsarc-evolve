% This file was created with JabRef 2.4.2.
% Encoding: UTF-8

@INPROCEEDINGS{Avgeriou2006,
  author = {Paris Avgeriou and Uwe Zdun and Isabelle Borne},
  title = {Architecture-Centric Evolution: New Issues and Trends},
  booktitle = {ECOOP Workshops},
  year = {2006},
  pages = {97-105},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  crossref = {DBLP:conf/ecoopw/2006},
  ee = {http://dx.doi.org/10.1007/978-3-540-71774-4_11},
  owner = {andrew},
  review = {looks at some trends in evolving architectures. pretty light.},
  timestamp = {2009.05.05}
}

@INPROCEEDINGS{Batory2005,
  author = {Don S. Batory},
  title = {Feature Models, Grammars, and Propositional Formulas},
  booktitle = {SPLC},
  year = {2005},
  pages = {7-20},
  abstract = {Feature models are used to specify members of a product-line.
	
	Despite years of progress, contemporary tools provide limited support
	for feature
	
	constraints and offer little or no support for debugging feature models.
	We
	
	integrate prior results to connect feature models, grammars, and propositional
	
	formulas. This connection allows arbitrary propositional constraints
	to be
	
	defined among features and enables off-the-shelf satisfiability solvers
	to debug
	
	feature models. We also show how our ideas can generalize recent results
	on the
	
	staged configuration of feature models.},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  crossref = {DBLP:conf/splc/2005},
  ee = {http://dx.doi.org/10.1007/11554844_3},
  owner = {andrew},
  review = {nice look at the start at feature modelling},
  timestamp = {2009.06.24}
}

@INPROCEEDINGS{D'Ippolito2008,
  author = {Nicolás D'Ippolito and Dario Fischbein and Marsha Chechik and Sebastián
	Uchitel},
  title = {MTSA: The Modal Transition System Analyser},
  booktitle = {IEEE/ACM Automated Software Engineering},
  year = {2008},
  pages = {475-476},
  publisher = {IEEE},
  crossref = {conf/kbse/2008},
  date = {2008-10-29},
  ee = {http://dx.doi.org/10.1109/ASE.2008.78},
  interhash = {ce8c99e0b607329c51f6c9ee8c20e52d},
  intrahash = {51e411eb8012e32bd104b7c06a4b649e},
  owner = {andrew},
  timestamp = {2009.07.21},
  url = {http://dblp.uni-trier.de/db/conf/kbse/ase2008.html#DIppolitoFCU08}
}

@ARTICLE{Adamek2005,
  author = {Adamek, J. and Plasil, F.},
  title = {Component Composition Errors and Update Atomicity: Static Analysis},
  journal = {Journal of Software Maintenance and Evolution: Research and Practice},
  year = {2005},
  volume = {17},
  pages = {363--377},
  number = {5},
  abstract = {Dynamic evolution inherently involves dynamic update and the issue
	of its atomicity. We show how this issue can be addressed in a similar
	manner to a communication failure via an extension to behavior protocols.
	First, we discuss the problem of defining a composition operator
	for behavior protocols so as to be able to reflect communication
	failures. Classical architecture description languages (ADLs) supporting
	behavior description, such as Wright and TRACTA, use a CSP-like parallel
	composition, which inherently yields only 'successful traces' ignoring
	non-accepted communication attempts. We show that component composition
	can produce several different types of behavior errors: bad activity,
	no activity, and divergence. The key idea behind bad activity is
	that real programs typically have an asymmetry of roles during event
	exchange: the caller is considered to be the initiator of the call
	while the callee has only a passive role. This contrasts with most
	formal systems, which treat communication symmetrically. We propose
	a new composition operator, 'consent', which reflects these types
	of errors by producing erroneous traces. By using the consent operator
	it can be statically determined whether the atomicity of a dynamic
	update of a component is implicitly guaranteed by the behavior of
	its current environment. Copyright � 2005 John Wiley & Sons, Ltd.},
  comment = {Excellent and very understantable. Looks at protocols for behaviour
	and introduces update tokens. Very nice concept. Introduces an operator
	called "consent" which leads to an analysis of behavioural errors
	when composing: bad activity, no activity and divergence. Easy to
	get these results with FSP instead.
	
	2006-01-12},
  issn = {1532-060X},
  keywords = {component, architecture description language, SYSTEMS},
  owner = {amcveigh},
  publisher = {John Wiley \& Sons, Inc.},
  refid = {72},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=1090748&coll=Portal&dl=GUIDE&CFID=70282723&CFTOKEN=98894328#}
}

@INPROCEEDINGS{Adamek2004,
  author = {Adamek, J. and Plasil, F.},
  title = {Partial Bindings of Components - Any Harm?},
  booktitle = {Proceedings of the 11th Asia-Pacific Software Engineering Conference
	(APSEC'04) - Volume 00},
  year = {2004},
  pages = {632--639},
  publisher = {IEEE Computer Society},
  abstract = {Reuse is one of the key benefits of components. It inherently means
	that the functionality of a component may be employed only partially.
	This triggers the issue whether all of the component's interfaces
	have to be really bound to the other components in its current environment
	(missing binding problem). Assuming each of the components is equipped
	by its behavior protocol, we show that missing bindings can be statically
	identified via verification tools, in particular by employing the
	concept of bad activity error introduced in [Component Composition
	Errors and Update Atomicity: Static Analysis].},
  comment = {Excellent paper looking at how to verify that we can omit elements
	from an architecture using protocols. Need to look into how to do
	this in a hierarchy.
	
	2006-01-06},
  issn = {0-7695-2245-9},
  keywords = {component},
  owner = {amcveigh},
  refid = {68},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=1032783&coll=Portal&dl=GUIDE&CFID=70282723&CFTOKEN=98894328#}
}

@BOOK{Agha1986,
  title = {Actors: A Model of Concurrent Computation in Distributed Systems},
  publisher = {MIT Press},
  year = {1986},
  author = {Agha,, Gul},
  address = {Cambridge, MA, USA},
  isbn = {0-262-01092-5},
  owner = {andrew},
  timestamp = {2009.04.06}
}

@INPROCEEDINGS{Alanen2003,
  author = {Alanen, M. and Porres, I.},
  title = {Difference and Union of Models},
  booktitle = {UML2003},
  year = {2003},
  editor = {Stevens, P. and Whittle.J and Booch, J.},
  publisher = {Springer-Verlag},
  chapter = {Difference and Union of Models},
  owner = {amcveigh},
  timestamp = {2006.05.30}
}

@INPROCEEDINGS{Aldrich2008,
  author = {Aldrich,, Jonathan},
  title = {Using Types to Enforce Architectural Structure},
  booktitle = {WICSA '08: Proceedings of the Seventh Working IEEE/IFIP Conference
	on Software Architecture (WICSA 2008)},
  year = {2008},
  pages = {211--220},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  doi = {http://dx.doi.org/10.1109/WICSA.2008.48},
  isbn = {978-0-7695-3092-5},
  owner = {andrew},
  timestamp = {2009.04.04}
}

@INPROCEEDINGS{Aldrich2002,
  author = {Aldrich,, Jonathan and Chambers,, Craig and Notkin,, David},
  title = {ArchJava: Connecting Software Architecture to Implementation},
  booktitle = {ICSE '02: Proceedings of the 24th International Conference on Software
	Engineering},
  year = {2002},
  pages = {187--197},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/581339.581365},
  isbn = {1-58113-472-X},
  location = {Orlando, Florida},
  owner = {andrew},
  timestamp = {2009.04.04}
}

@ARTICLE{Allen1994,
  author = {Allen,, Robert and Garlan,, David},
  title = {Beyond Definition/Use: Architectural Interconnection},
  journal = {Proceedings of the workshop on Interface Definition Languages},
  year = {1994},
  volume = {29},
  pages = {35--45},
  number = {8},
  abstract = {Large software systems require decompositional mechanisms in order
	to make them tractable. Traditionally, MILs and IDLs have played
	this role by providing notations based on definition/use bindings.
	In this paper we argue that current MIL/IDLs based on definition/use
	have some serious drawbacks. A significant problem is that they fail
	to distinguish between "implementation" and "interaction" relationships
	between modules. We propose an alternative model in which components
	interact along welldefined lines of communication -- or connectors.
	Connectors are defined as protocols that capture the expected patterns
	of communication between modules. We show how this leads to a scheme
	that is much more expressive for architectural relationships, that
	allows the formal definition of module interaction, and that supports
	its own form of automated checks and formal reasoning.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/185087.185101},
  issn = {0362-1340},
  owner = {amcveigh},
  publisher = {ACM},
  review = {The paper that explains the use of connectors as the differentiating
	factor between ADLs and MILs.},
  timestamp = {2009.04.02}
}

@INBOOK{Team2002-2003,
  chapter = {1. Getting Started with AspectJ},
  title = {The AspectJ Programming Guide},
  publisher = {Xerox Corporation},
  year = {2002-2003},
  author = {{AspectJ Team}},
  owner = {amcveigh},
  timestamp = {2009.03.26},
  url = {http://www.eclipse.org/aspectj/doc/released/progguide/starting-aspectj.html}
}

@INPROCEEDINGS{Barais2004,
  author = {Olivier Barais and Eric Cariou and Laurence Duchien and Nicolas Pessemier
	and Lionel Seinturier},
  title = {TranSAT: A Framework for the Specification of Software Architecture
	Evolution},
  booktitle = {ECOOP First International Workshop on Coordination and Adaptation
	Techniques for Software Entities (WCAT04)},
  year = { 2004 },
  address = { Oslo, Norway },
  month = { jun },
  abstract = { Everything changes in our everyday lives: New discoveries, paradigms,
	styles, and technologies. Frequently, software systems success depends
	on how they can quickly adapt to requirement or environment evolution.
	Software architectures are ABSTRACT models at the highest level.
	As such, they should assume conceptual guidance on what parts of
	the system changed. However, many software architectures often evolve
	from an uncoordinated build-and-fix attitude. The result is opaque
	and not analyzable. We present in this paper a practical experience
	of using aspect oriented programming principles for managing software
	architecture specification evolution. Our approach aims at clarifying
	software architecture evolution steps. It extends software architecture
	ABSTRACT models for the specification and the analysis of new concern
	integration. },
  comment = {Workshop,en},
  dateadded = { 2007-03-26 },
  groups = { international,jacquard,mosaiques,workshop },
  lastdatemodified = { 2007-03-26 },
  lastname = { Barais },
  longnotes = { 20040601 },
  owner = {andrew},
  timestamp = {2009.05.05},
  website = { wcat04.unex.es/ }
}

@INPROCEEDINGS{Barais2006,
  author = {Barais,, Olivier and Le Meur,, Anne-Francoise and Duchien,, Laurence
	and Lawall,, Julia},
  title = {Safe Integration of New Concerns in a Software Architecture},
  booktitle = {ECBS '06: Proceedings of the 13th Annual IEEE International Symposium
	and Workshop on Engineering of Computer Based Systems},
  year = {2006},
  pages = {52--64},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  abstract = {Software architectures must frequently evolve to cope with changing
	requirements, and this evolution often implies integrating new concerns.
	Unfortunately, existing architecture description languages provide
	little or no support for this kind of evolution. The software architect
	must modify the architecture manually, which risks introducing inconsistencies.
	In previous work, we have proposed the TranSAT framework, which provides
	a pattern construct for describing new concerns and their integration
	into an existing architecture. As the interaction between the new
	concern and the existing architecture may be complex, it is essential
	that the framework ensure the coherence of the resulting architecture.
	In this paper, we introduce a language for specifying patterns and
	verifications that ensure that the concern represented by a pattern
	can be safely integrated into an existing architecture. The verifications
	comprise static verifications that check coherence properties before
	the architecture is modified and dynamic verifications that focus
	on the parts of the architecture that are affected by the pattern.
	As a result of these verifications, patterns can be provided as a
	commodity, such that a software architect can confidently apply a
	pattern obtained from a third-party developer.},
  doi = {http://dx.doi.org/10.1109/ECBS.2006.64},
  isbn = {0-7695-2546-6},
  owner = {andrew},
  review = {quite neat -- uses aspects (add port, create binding etc) to remake
	an architecture. joinpoints are specified using structural and behavioural
	patterns.},
  timestamp = {2009.05.05}
}

@MISC{Barnabe2007,
  author = {Jason Barnabe},
  title = {{Avoiding Extension Conflicts in Firefox}},
  howpublished = {http://blog.userstyles.org/2007/02/06/avoiding-extension-conflicts/},
  year = {last accessed August 2009},
  abstract = {Problems that occur when two specific extensions are installed are
	difficult to debug. You often won’t see the problem yourself, it’ll
	be some user reporting it. You have to lasso them long enough to
	figure out that that indeed is what’s happening rather than some
	system-specific or a difficult-to-reproduce bug. Once the conflicting
	extension is found, you have to delve into its gooey innards and
	try to make some sense of it.},
  owner = {andrew},
  review = {contains rules about avoiding firefox script extensions, and how users
	tend to find the conflicts first.},
  timestamp = {2009.05.05},
  url = {http://blog.userstyles.org/2007/02/06/avoiding-extension-conflicts/}
}

@INPROCEEDINGS{Batory2006,
  author = {Don Batory},
  title = {A Tutorial on Feature Oriented Programming and the AHEAD Tool Suite},
  booktitle = {Generative and Transformational Techniques in Software Engineering},
  year = {2006},
  volume = {4143},
  series = {Lecture Notes in Computer Science},
  pages = {3--35},
  publisher = {Springer},
  abstract = {Feature oriented programming (FOP) is the study of feature mod ularity
	and its use in program synthesis. AHEAD is a theory of FOP that is
	based on a fundamental concept of generative programming that functions
	map programs. This enables the design of programs to be expressed
	compo sitionallyas algebraic expressions, which are suited for automated
	analysis, manipulation, and program synthesis. This paper is a tutorialon
	FOP and AHEAD. We review AHEAD’s theory and the tool set that implements
	it.},
  interhash = {6d24ea963d5dfd5b07cd45574025c1f8},
  intrahash = {d80e4cbc2e98a823601d1ce51f199f49},
  owner = {andrew},
  review = {nice tutorial that actually makes the AHEAD system concrete!},
  timestamp = {2009.06.24},
  url = {http://dx.doi.org/10.1007/11877028_1}
}

@ARTICLE{Batory2002a,
  author = {Batory, Don and Johnson, Clay and MacDonald, Bob and von Heeder,
	Dale},
  title = {Achieving Extensibility Through Product-Lines and Domain-Specific
	Languages: A Case Study},
  journal = {ACM Transactions on Software Engineering and Methodology (TOSEM)},
  year = {2002},
  volume = {11},
  pages = {191--214},
  number = {2},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/505145.505147},
  issn = {1049-331X},
  owner = {andrew},
  publisher = {ACM},
  timestamp = {2009.06.26}
}

@INPROCEEDINGS{Batory2003,
  author = {Batory, D. and Liu, J. and Sarvela, J.N.},
  title = {Refinements and Multi-Dimensional Separation of Concerns},
  booktitle = {Proceedings of the 9th European Software Engineering Conference},
  year = {2003},
  pages = {48--57},
  address = {Helsinki, Finland},
  publisher = {ACM Press},
  abstract = {Step-wise refinement (SWR) asserts that complex programs can be derived
	from simple programs by progressively adding features. The length
	of a program specification is the number of features that the program
	has. Critical to the scalability of SWR are multi-dimensional models
	that separate orthogonal feature sets. Let n be the dimensionality
	of a model and k be the number of features along a dimension. We
	show program specifications that could be O(kn) features long have
	short and easy-to-understand specifications of length O(kn) when
	multi-dimensional models are used. We present new examples of multidimensional
	models: a micro example of a product-line (whose programs are 30
	lines of code) and isomorphic macro examples (whose programs exceed
	30K lines of code). Our work provides strong evidence that SWR scales
	to synthesis of large systems.},
  comment = {Applies a 2d matrix where each axis represents a set of features.
	To share features, two columns or two rows etc are combined. Seems
	like an equational approach. Not sure about how useful or actually
	how scalable this technique is in practice. Relies on ordering in
	some cases. Matrix type is called Origami due to folding.
	
	2005-12-12},
  issn = {1-58113-743-5},
  keywords = {SPECIFICATION, SYSTEMS},
  owner = {amcveigh},
  refid = {69},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=940079&coll=Portal&dl=GUIDE&CFID=70282723&CFTOKEN=98894328#}
}

@INPROCEEDINGS{Batory2002,
  author = {Don Batory and Roberto E. Lopez-Herrejon and Jean-Philippe Martin},
  title = {Generating Product-Lines of Product-Families},
  booktitle = {ASE '02: Proceedings of the 17th IEEE International Conference on
	Automated Software Engineering},
  year = {2002},
  pages = {81},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  isbn = {0-7695-1736-6},
  review = {interesting but sometimes confusing due to overcomplex terminology
	and lack of discussion about how gluons are implemented.
	
	
	it turns out that gluons are methods etc that are part of adding a
	feature to a product inside a family inside a product line! i.e.
	a product family is a suite -- e.g. java compiler, java ida. a product
	line is a java compiler, a java state machine compiler etc. layers
	are a horizontal grouping of gluons that add a consistent set of
	features across a family. facets are a vertical grouping of gluons
	(in the origami matrix) that add a full set of features to a single
	product in the family.
	
	
	it also turns out that gluons are implemented using hyper/j -- they
	are in effect just aspects. so gluons and facets are effectively
	a way to organise aspects for a product line and product family combination.
	
	
	there are parallels to what I'm doing, and this serves as a credible
	way for me to tie my stuff to aspects and feature sets.
	
	
	class extension = redefinition (interestingly, they have a very similar
	concept as described in the note on page 4)
	
	inheritance = resemblance (they use classes rather than components)
	
	constant/layer/feature set = stratum
	
	design rules = dependencies between stratum / feature sets},
  timestamp = {2007.04.02}
}

@INPROCEEDINGS{Batory2003a,
  author = {Batory,, Don and Sarvela,, Jacob Neal and Rauschmayer,, Axel},
  title = {Scaling Step-Wise Refinement},
  booktitle = {ICSE '03: Proceedings of the 25th International Conference on Software
	Engineering},
  year = {2003},
  pages = {187--197},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  abstract = {Step-wise refinement is a powerful paradigm for developing a complex
	program from a simple program by adding features incrementally. We
	present the AHEAD (Algebraic Hierarchical Equations for Application
	Design) model that shows how step-wise refinement scales to synthesize
	multiple programs and multiple non-code representations. AHEAD shows
	that software can have an elegant, hierarchical mathematical structure
	that is expressible as nested sets of equations. We review a tool
	set that supports AHEAD. As a demonstration of its viability, we
	have bootstrapped AHEAD tools solely from equational specifications,
	generating Java and non-Java artifacts automatically, a task that
	was accomplished only by ad hoc means previously.},
  isbn = {0-7695-1877-X},
  location = {Portland, Oregon},
  review = {Presents AHEAD which offers ability to "refine" existing classes.
	Need to read properly. Important reference, as it is one of the leaders
	of the compositional approach.}
}

@INPROCEEDINGS{Bauerdick2004,
  author = {Hanna Bauerdick and Martin Gogolla and Fabian Gutsche},
  title = {Detecting {OCL} Traps in the {UML} 2.0 Superstructure: An Experience
	Report},
  booktitle = {{UML} 2004 - The Unified Modeling Language. Model Languages and Applications.
	7th International Conference, Lisbon, Portugal, October 11-15, 2004,
	Proceedings},
  year = {2004},
  editor = {Thomas Baar and Alfred Strohmeier and Ana Moreira and Stephen J.
	Mellor},
  volume = {3273},
  series = {LNCS},
  pages = {188--196},
  publisher = {Springer},
  owner = {andrew},
  timestamp = {2009.06.09}
}

@MISC{Beaton2005,
  author = {Wayne Beaton},
  title = {{Eclipse Hints, Tips, and Random Musings}},
  howpublished = {http://dev.eclipse.org/blogs/wayne/2005/10/03/fun-with-combinatorics/},
  year = {last accessed August 2009},
  journal = {Blog entry},
  owner = {amcveigh},
  review = {decent explanation of the main focus of the eclipse platform, including
	plugin architecture.},
  timestamp = {2006.05.15},
  url = {http://wbeaton.blogspot.com/2005/10/fun-with-combinatorics.html}
}

@INPROCEEDINGS{Bederson2000,
  author = {Bederson, Benjamin B.},
  title = {Fisheye Menus},
  booktitle = {UIST '00: Proceedings of the 13th annual ACM Symposium on User Interface
	Software and Technology},
  year = {2000},
  pages = {217--225},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/354401.354782},
  isbn = {1-58113-212-3},
  location = {San Diego, California, United States},
  owner = {andrew},
  timestamp = {2009.06.09}
}

@CONFERENCE{Bennett2004,
  author = {Keith Bennett and David Budgen and Tony Hoare and Paul Layzell},
  title = {Software Evolution},
  booktitle = {Grand Challenges for Computing Research Conference Announcement},
  year = {2004},
  address = {University of Newcastle upon Tyne},
  owner = {andrew},
  review = {Fantastic article which puts evolution on a par with creation. Very
	good for my work.
	
	
	Some great quotes:
	
	
	"It is sometimes advocated that software should be designed to make
	change easy.
	
	However enticing, this is hard. It seems impossible to predict change,
	and very often, a
	
	successful system will change in ways which are inconceivable to the
	original designers."
	
	
	"It does seem clear that two aspects are central to research:
	
	? Architectural design for dependability and evolution: including
	issues relating to
	
	structure, granularity of components and interfaces between them,
	as well as
	
	architectural mismatches. We do not really understand how change and
	its
	
	propagation can be contained."
	
	
	Wow -- this dovetails neatly into my work.},
  timestamp = {2009.03.18},
  url = {http://www.nesc.ac.uk/esi/events/Grand_Challenges/gcconf04/submissions.html}
}

@ARTICLE{Birsan2005,
  author = {Birsan, Dorian},
  title = {On Plug-Ins and Extensible Architectures},
  journal = {ACM Queue},
  year = {2005},
  volume = {3},
  pages = {40--46},
  number = {2},
  owner = {amcveigh},
  publisher = {ACM Press
	
	},
  timestamp = {2006.05.15}
}

@INBOOK{Blandy2009,
  chapter = {11: GNU Emacs: Creeping Featurism Is a Strength},
  pages = {263-278},
  title = {Beautiful Architecture: Leading Thinkers Reveal the Hidden Beauty
	in Software Design},
  publisher = {O'Reilly Media, Inc.},
  year = {2009},
  editor = {Diomidis Spinellis and Georgios Gousios},
  author = {Jim Blandy},
  owner = {andrew},
  timestamp = {2009.03.09}
}

@MISC{Blewitt2007,
  author = {Neil Blewitt},
  title = {{A Comparison of Eclipse Extensions and OSGi Services}},
  howpublished = {http://www.eclipsezone.com/articles/extensions-vs-services/},
  year = {last accessed August 2009},
  journal = {EclipseZone},
  owner = {amcveigh},
  timestamp = {2007.07.09},
  url = {http://www.eclipsezone.com/articles/extensions-vs-services/}
}

@ARTICLE{Bosch1999,
  author = {Jan Bosch},
  title = {Superimposition: A Component Adaptation Technique},
  journal = {Information and Software Technology},
  year = {1999},
  volume = {41},
  pages = {257--273},
  number = {5},
  month = {25~March},
  url = {citeseer.ist.psu.edu/281749.html}
}

@BOOK{Box1997,
  title = {Essential COM},
  publisher = {Addison-Wesley Professional},
  year = {1997},
  author = {Box, D.},
  owner = {amcveigh},
  timestamp = {2006.05.30}
}

@INPROCEEDINGS{Bracha1990,
  author = {Bracha, G. and Cook, W.},
  title = {Mixin-Based Inheritance},
  booktitle = {OOPSLA/ECOOP '90: Proceedings of the European Conference on Object-Oriented
	Programming Systems, Languages, and Applications},
  year = {1990},
  pages = {303--311},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  doi = {http://doi.acm.org/10.1145/97945.97982},
  isbn = {0-201-52430-X},
  location = {Ottawa, Canada}
}

@TECHREPORT{Bruce1998,
  author = {Kim B. Bruce and Leaf Petersen and Joseph Vanderwaart},
  title = {Modules in LOOM: Classes are Not Enough (extended abstract)},
  institution = {Williams College},
  year = {1998},
  owner = {amcveigh},
  timestamp = {2007.07.10},
  url = {http://www.cs.williams.edu/kim}
}

@TECHREPORT{Buchi1999,
  author = {Buchi,, Martin and Weck,, Wolfgang},
  title = {The Greybox Approach: When Blackbox Specifications Hide Too Much},
  institution = {Turku Centre for Computer Science},
  year = {1999},
  abstract = {Development of different parts of large software systems by separate
	teams, replacement of individual software parts during maintenance
	without changing other parts, and marketing of independently developed
	software components require interface descriptions. Interoperation
	is impossible without sufficient description; only abstraction leaves
	room for alternate implementations. Specifications that only relate
	the state prior to service invocation (precondition) to that after
	service termination (postcondition) do not sufficiently capture external
	calls made during operation execution. If other methods called in
	the specification cannot be fully specified, it is not sufficient
	that the implementation only performs the specified state transformation.
	The implementation must also make the prescribed external calls in
	the respective states. We show how to specify both state change and
	external call sequences using simple extensions of programming languages.
	Furthermore, we give a formal definition of the correctness of implementations
	with respect to such specifications and show how to prove correctness
	in practice with data refinement in context.},
  publisher = {Turku Centre for Computer Science},
  source = {http://www.ncstrl.org:8900/ncstrl/servlet/search?formname=detail\&id=oai%3Ancstrlh%3Atucs_fi%3Ancstrl.tucs.fi%2F%2FTUCS-TR-297}
}

@BOOK{Budgen2003,
  title = {Software Design},
  publisher = {Addison Wesley},
  year = {2003},
  author = {David Budgen},
  edition = {2nd},
  month = {July},
  owner = {andrew},
  review = {used for the good pattern description},
  timestamp = {2009.06.15}
}

@INBOOK{Bullen2005,
  chapter = {5: Function, General and Application-Specific Add-Ins},
  pages = {109-142},
  title = {Professional Excel Development: The Definitive Guide to Developing
	Applications Using Microsoft Excel and VBA},
  publisher = {Addison Wesley},
  year = {2005},
  author = {Stephen Bullen and Rob Bovey and John Green},
  owner = {andrew},
  timestamp = {2009.03.09}
}

@BOOK{Buschmann1996,
  title = {Pattern-Oriented Software Architecture, Volume 1: A System of Patterns},
  publisher = {John Wiley \& Sons; 1st edition (August 8, 1996)},
  year = {1996},
  author = {Buschmann, F. and Meunier, R. and Rohnert, H. and Sommerlad, P. and
	Stal, M. and Sommerlad, P.},
  issn = {0471958697},
  keywords = {Buschmann,F.; Meunier,R.; Rohnert,H.; Sommerlad,P.; Stal,M.; Sommerlad,P.;
	Stal,M.},
  owner = {amcveigh},
  refid = {59},
  timestamp = {2006.03.14}
}

@BOOK{Chappell1996,
  title = {Understanding ActiveX and OLE},
  publisher = {Microsoft Press},
  year = {1996},
  author = {Chappell, D.},
  owner = {amcveigh},
  timestamp = {2006.05.30}
}

@INPROCEEDINGS{Chatley2004a,
  author = {R. Chatley and S. Eisenbach and J. Kramer and J. Magee and S. Uchitel},
  title = {Predictable Dynamic Plugin Systems},
  booktitle = {FASE 2004 : Fundamental Approaches to Software Engineering},
  year = {2004},
  pages = {129--143},
  owner = {andrew},
  timestamp = {2009.07.27}
}

@ARTICLE{Chatley2004,
  author = {Chatley, R. and Eisenbach, S. and Magee, J.},
  title = {MagicBeans: A Platform for Deploying Plugin Components},
  journal = {Component Deployment},
  year = {2004},
  volume = {3083},
  pages = {97--112},
  abstract = {Plugins are optional components which can be used to enable the dynamic
	construction of flexible and complex systems, passing as much of
	the configuration management effort as possible to the system rather
	than the user, allowing graceful upgrading of systems over time without
	stopping and restarting. Using plugins as a mechanism for evolving
	applications is appealing, but current implementations have limited
	functionality. In this paper we present a framework that supports
	the construction and evolution of applications with a plugin architecture},
  address = {Univ London Imperial Coll Sci Technol \& Med, Dept Comp, London SW7
	2AZ, England},
  comment = {Times Cited: 0 Article English Chatley, R Univ London Imperial Coll
	Sci Technol & Med, Dept Comp, 180 Queensgate, London SW7 2AZ, England
	Cited References Count: 23
	
	Read part of this to see what type of plugin model Rob was modelling.
	The model is not hierarchical, and is based on auto-matching plugins
	based on (a) the interfaces exposed in Java by the implementation
	and (b) the running model. Develops a formal model in Alloy for the
	plugin approach. Cardinality / multiplicity is used. Probably worth
	revisiting to re-examine the Alloy model and the 1st order logical
	statements about the model.
	
	2005-10-04},
  issn = {0302-9743},
  keywords = {component, configuration, SYSTEMS},
  owner = {amcveigh},
  refid = {1},
  timestamp = {2006.03.14},
  url = {ISI:000221782700007}
}

@INPROCEEDINGS{Chatley2003,
  author = {Chatley, Robert and Eisenbach, Susan and Magee, Jeff},
  title = {Modelling a Framework for Plugins},
  booktitle = {Specification and Verification of Component-Based Systems},
  year = {2003},
  url = {http://pubs.doc.ic.ac.uk/ModellingPluginFramework/}
}

@ARTICLE{Ping2004,
  author = {Chen, P.H. and Critchlow, M. and Garg, A. and Van der Westhuizen,
	C. and van der Hoek, A.},
  title = {Differencing and Merging Within an Evolving Product Line Architecture},
  journal = {Software Product-Family Engineering},
  year = {2004},
  volume = {3014},
  pages = {269--281},
  owner = {amcveigh},
  review = {looks at diffing between 2 architectures and then merging back into
	a different line. needs to work out diffs, but merging is simplistic.},
  timestamp = {2006.05.15}
}

@INPROCEEDINGS{Chern2006,
  author = {Rick Chern},
  title = {Refactoring with Difference-Based Modules: An Experience Report},
  booktitle = {CPSC 511 Mini Conference},
  year = {2006},
  owner = {amcveigh},
  timestamp = {2007.07.09},
  url = {http://www.cs.ubc.ca/~kdvolder/CPSC511/conference-program.html}
}

@INPROCEEDINGS{Clarke2001,
  author = {Clarke, S. and Walker, R.J.},
  title = {Composition Patterns: An Approach to Designing Reusable Aspects},
  booktitle = {Proceedings of the 23rd International Conference on Software Engineering},
  year = {2001},
  pages = {5--14},
  address = {Toronto, Ontario, Canada},
  publisher = {IEEE Computer Society},
  abstract = {Requirements such as distribution or tracing have an impact on multiple
	classes in a system. They are cross-cutting requirements, or aspects.
	Their support is, by necessity, scattered across those multiple classes.
	A look at an individual class may also show support for cross-cutting
	requirements tangled up with the core responsibilities of that class.
	Scattering and tangling make object-oriented software difficult to
	understand, extend and reuse. Though design is an important activity
	within the software lifecycle with well-documented benefits, those
	benefits are reduced when cross-cutting requirements are present.
	This paper presents a means to mitigate these problems by separating
	the design of cross-cutting requirements into composition patterns.
	Composition patterns require extensions to the UML, and are based
	on a combination of the subject-oriented model for composing separate,
	overlapping designs, and UML templates. This paper also demonstrates
	how composition patterns map to one programming model that provides
	a solution for separation of cross-cutting requirements in code-aspect-oriented
	programming. This mapping serves to illustrate that separation of
	aspects may be maintained throughout the software lifecycle.},
  comment = {Looks at the idea of templated design concepts which are expressed
	as independent design models. Main aim is to assemble programs out
	of these. Doesn't address conflicts directly. Has a behavioural approach
	based on sequence diagrams. Deals with merging.
	
	2006-02-01},
  issn = {0-7695-1050-7},
  owner = {amcveigh},
  refid = {66},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=381474&coll=Portal&dl=GUIDE&CFID=70282723&CFTOKEN=98894328#}
}

@BOOK{Clements2001,
  title = {Software Product Lines: Practices and Patterns},
  publisher = {Addison-Wesley},
  year = {2001},
  author = {Paul C. Clements and Linda Northrop},
  series = {SEI Series in Software Engineering},
  month = {August},
  abstract = {(...) In providing a comprehensive set of practices and patterns,
	this book defines and explores the key activities for software product
	line development and explains specific practice areas in engineering,
	technical management, and organizational management. (...)},
  available = {1},
  category = {General},
  interhash = {cd614386b56e1a8c1d8db57c1a505411},
  intrahash = {18cfb5d792f79120506c1d5440baad7a},
  newinversion = {2.19},
  owner = {andrew},
  timestamp = {2009.06.24}
}

@ARTICLE{Codenie1997,
  author = {Codenie, W. and De Hondt, K. and Steyaert, P. and Vercammen, A.},
  title = {From Custom Applications to Domain-Specific Frameworks},
  journal = {Communications of the ACM},
  year = {1997},
  volume = {40},
  pages = {70--77},
  number = {10},
  abstract = {As a provider of broadcast planning software for television stations,
	we have to create highly customized software while maintaining the
	quality standards of an offthe- shelf product. Framework technology
	plays a strategic role in our business, because there are many similarities
	in the complex broadcast planning processes of different stations,
	yet a standard product would satisfy only 70% to 80% of the needs
	of a typical station. Thanks to frameworks, customers can be offered
	a standard product that is easily customizable by a small team of
	software engineers in a cost-effective way. Moreover, the adaptive
	nature of frameworks provides another advantage; like any other business,
	television stations need to respond to new and rapidly changing market
	opportunities. They are faced with rapidly evolving hardware (e.g.,
	digital video broadcasting, distributed video production) and rapid
	evolution of their products (e.g., interactive TV, electronic program
	guides). These changes require more malleable software. For broadcasters,
	the ability to cope with change more efficiently than from similar
	off-the-shelf applications results in a competitive advantage.},
  comment = {Contains an excellent description of some reuse problems of frameworks.
	Also defines reuse operators, and looks at a matrix of changes by
	the extender and the developer of the framework. Extremely relevant
	and very clear.
	
	2005-10-25},
  issn = {0001-0782},
  owner = {amcveigh},
  publisher = {ACM Press},
  refid = {35},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=262807&coll=GUIDE&dl=GUIDE&CFID=58678673&CFTOKEN=85896761#}
}

@ARTICLE{Cortes2003,
  author = {Cortes, M. and Fontoura, M. and Lucena, C.},
  title = {Using Refactoring and Unification Rules to Assist Framework Evolution},
  journal = {ACM SIGSOFT Software Engineering Notes},
  year = {2003},
  volume = {28},
  pages = {1--1},
  number = {6},
  abstract = {Although object-oriented software development has experienced the
	benefits of using frameworks, a thorough understanding of how to
	change them to meet evolving requirement needs is still object of
	research. Therefore framework development is very expensive, not
	only because of the intrinsic difficulty related to capturing the
	domain theory, but also because of the lack of appropriate methods
	and techniques to support the evolution and redesign of the framework
	architecture. This paper proposes the use of refactoring and unification
	rules to assist framework evolution. The approach is illustrated
	through the JUnit testing framework.},
  comment = {Looks directly at the evolution of frameworks, which makes this relevant
	to my work. Proposes use of refactoring, which are behavior preserving
	transformations, and unifications, which are ways to incorporate
	new abstractions into a framework structure. This works by taking
	2 forked versions of a framework (called architectural drift) and
	unifying them through transformations.
	
	2005-10-03},
  issn = {0163-5948},
  owner = {amcveigh},
  publisher = {ACM Press},
  refid = {46},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=966234&coll=Portal&dl=GUIDE&CFID=60884029&CFTOKEN=12662247#}
}

@INPROCEEDINGS{Councill2001,
  author = {Councill,, Bill and Heineman,, George T.},
  title = {Definition of a Software Component and its Elements},
  booktitle = {Component-Based Software Engineering: Putting the Pieces Together},
  year = {2001},
  pages = {5--19},
  address = {Boston, MA, USA},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  book = {Component-based software engineering: putting the pieces together},
  isbn = {0-201-70485-4}
}

@BOOK{Cox1991,
  title = {Object-Oriented Programming: An Evolutionary Approach},
  publisher = {Addison-Wesley},
  year = {1991},
  author = {Cox, B.J. and Novobilski, A.J.},
  owner = {amcveigh},
  timestamp = {2006.05.30}
}

@INPROCEEDINGS{Crane1995,
  author = {Crane,, S. and Dulay,, N. and Foss{\aa},, H. and Kramer,, J. and
	Magee,, J. and Sloman,, M. and Twidle,, K.},
  title = {Configuration Management for Distributed Software Services},
  booktitle = {Proceedings of the Fourth International Symposium on Integrated Network
	Management},
  year = {1995},
  pages = {29--42},
  address = {London, UK, UK},
  publisher = {Chapman \& Hall, Ltd.},
  isbn = {0-412-71570-8},
  owner = {andrew},
  review = {interesting paper on SysMan and the active badge system. has first
	details I've seen on 1st party versus thirdy party versus dynamic
	bindings in an ADL.},
  timestamp = {2009.04.15}
}

@INPROCEEDINGS{Dashofy2007,
  author = {Dashofy,, Eric and Asuncion,, Hazel and Hendrickson,, Scott and Suryanarayana,,
	Girish and Georgas,, John and Taylor,, Richard},
  title = {ArchStudio 4: An Architecture-Based Meta-Modeling Environment},
  booktitle = {ICSE COMPANION '07: Companion to the proceedings of the 29th International
	Conference on Software Engineering},
  year = {2007},
  pages = {67--68},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  doi = {http://dx.doi.org/10.1109/ICSECOMPANION.2007.21},
  isbn = {0-7695-2892-9},
  owner = {andrew},
  timestamp = {2009.04.04}
}

@MISC{Dashofy2002,
  author = {Eric M. Dashofy},
  title = {{Variants Extension for xADL 2.0}},
  howpublished = {http://www.isr.uci.edu/projects/xarchuci/ext-overview.html},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.04.04},
  url = {http://www.isr.uci.edu/projects/xarchuci/ext-overview.html#variants}
}

@ARTICLE{Dashofy2005,
  author = {Dashofy,, Eric M. and Hoek,, Andr\'{e} van der and Taylor,, Richard
	N.},
  title = {A Comprehensive Approach for the Development of Modular Software
	Architecture Description Languages},
  journal = {ACM Transactions on Software Engineering and Methodology (TOSEM)},
  year = {2005},
  volume = {14},
  pages = {199--245},
  number = {2},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1061254.1061258},
  issn = {1049-331X},
  owner = {andrew},
  publisher = {ACM},
  timestamp = {2009.04.04}
}

@MISC{Delap2006,
  author = {Scott Delap},
  title = {{Understanding How Eclipse Plug-Ins Work with OSGi}},
  howpublished = {http://www.ibm.com/developerworks/library/os-ecl-osgi/index.html},
  year = {last accessed August 2009},
  journal = {IBM Developerworks},
  owner = {amcveigh},
  timestamp = {2007.06.25},
  url = {http://www.ibm.com/developerworks/library/os-ecl-osgi/index.html},
  volume = {http://www.ibm.com/developerworks/library/os-ecl-osgi/index.html}
}

@MISC{DeMichiel2006,
  author = {Linda DeMichiel and Michael Keith},
  title = {{JSR-000220 Enterprise JavaBeans 3.0}},
  howpublished = {http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html},
  year = {last accessed August 2009},
  owner = {andrew},
  review = {The EJB 3.0 spec},
  timestamp = {2009.04.01},
  url = {http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html}
}

@MISC{Fireheadaches2005,
  author = {{DesktopLinux.com}},
  title = {{Firefox 1.5 Upgrade Brings Extension Headaches}},
  howpublished = {http://www.desktoplinux.com/news/NS2432314568.html},
  year = {last accessed 2009},
  owner = {amcveigh},
  timestamp = {2007.06.25},
  url = {http://www.desktoplinux.com/news/NS2432314568.html},
  volume = {http://www.desktoplinux.com/news/NS2432314568.html}
}

@INPROCEEDINGS{Doucet2005,
  author = {Doucet, F. and Shukla, S. and Gupta, R.},
  title = {Typing Abstractions and Management in a Component Framework},
  booktitle = {Asia and South Pacific Design Automation Conference},
  year = {2005},
  pages = {--},
  abstract = {We consider the type inference problems in a compositional design
	environment where the components are automatically instantiated from
	pre-existing C++-based intellectual property (IP) libraries. We present
	a component integration language based on scripting for design specification.
	Our focus is architectural aspects in specification that uses aggregation-
	as opposed to the more commonly used inheritance- for composition
	of components. Our approach simplifies architectural specification
	by employing a type inference and typemanagement environment. We
	show that the type inference problem is NP-complete. We present a
	heuristic based on code generation and parameterization to solve
	the type inference for IP selection in our C++-based composition
	environment. We have implemented the composition and type management
	in the BALBOA framework. The results show the utility of our approach.},
  comment = {need to read fully. uses type inferencing + type constraints to propagage
	types and infer them into connectors and parts of nested components.},
  keywords = {component, SPECIFICATION},
  owner = {amcveigh},
  refid = {52},
  timestamp = {2006.03.14},
  url = {http://mesl.ucsd.edu/balboa/}
}

@TECHREPORT{DSE1997,
  author = {{DSE, Imperial College}},
  title = {The Darwin Language, Version 3d.},
  institution = {Imperial College},
  year = {1997},
  file = {darwin-lang.pdf:http\://www-dse.doc.ic.ac.uk/Software/Darwin/darwin-lang.pdf:PDF},
  owner = {amcveigh},
  timestamp = {2007.07.09},
  url = {http://www-dse.doc.ic.ac.uk/Software/Darwin/darwin-lang.pdf}
}

@MISC{Consortium2006,
  author = {{Eclipse Foundation}},
  title = {{Platform Plug-in Developer Guide: OSGi Bundle Manifest Headers}},
  howpublished = {http://help.eclipse.org/stable/index.jsp?topic=/org.eclipse.platform.doc.isv/\\\-reference/misc/bundle\_manifest.html},
  year = {last accessed August 2009},
  journal = {Eclipse 3.2.1 Online Help},
  owner = {amcveigh},
  timestamp = {2007.06.25},
  url = {http://help.eclipse.org/help32/index.jsp?topic=/org.eclipse. platform.doc.isv/reference/misc/bundle\_manifest.html},
  volume = {http://help.eclipse.org/help32/index.jsp?topic=/org.eclipse. platform.doc.isv/reference/misc/bundle\_manifest.html}
}

@MISC{Foundation,
  author = {{Eclipse Foundation}},
  title = {{Rich client platform (RCP) applications}},
  howpublished = {http://www.eclipse.org/community/rcp.php},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.06.19},
  url = {http://www.eclipse.org/community/rcp.php}
}

@MISC{GEF2009,
  author = {{Eclipse Foundation}},
  title = {{Eclipse Graphical Editing Framework (GEF)}},
  howpublished = {http://www.eclipse.org/gef/},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.06.09},
  url = {http://www.eclipse.org/gef/}
}

@INPROCEEDINGS{Engels1997,
  author = {Gregor Engels and Reiko Heckel and Gabi Taentzer and Hartmut Ehrig},
  title = {A View-Oriented Approach to System Modelling Based on Graph Transformation},
  booktitle = {ESEC '97/FSE-5: Proceedings of the 6th European Conference},
  year = {1997},
  pages = {327--343},
  address = {New York, NY, USA},
  publisher = {Springer-Verlag New York, Inc.},
  abstract = {The idea of a combined reference model- and view-based
	
	specification approach has been proposed recently in the software
	engineering
	
	community. In this paper we present a specification technique
	
	based on graph transformations which supports such a development approach.
	
	The use of graphs and graph transformations supports an intuitive
	
	understanding and an integration of static and dynamic aspects
	
	on a well-defined semantical base. On this background, formal notions
	
	of view and view relation are developed and the behaviour of views
	is
	
	described by a loose semantics. We define a construction for automatic
	
	view integration which assumes that the dependencies between different
	
	views are described by a reference model. The views and the reference
	
	model are kept consistent manuahy, which is the task of a model manager.
	
	AII concepts and results are illustrated at the weII-known example
	
	of a banking system.},
  doi = {http://doi.acm.org/10.1145/267895.267919},
  isbn = {3-540-63531-9},
  location = {Zurich, Switzerland},
  review = {discusses viewpoint engineering. this is very much relevant to my
	approach.
	
	
	this is a fairly simple approach, where views are defined on a reference
	model and these are then merged back into a consistent sysstem model.
	
	
	views can rename or add -- no deletion and it is not hierarchical.},
  timestamp = {2006.08.07}
}

@INPROCEEDINGS{Erdogmus1998,
  author = {Erdogmus, H.},
  title = {Representing Architectural Evolution},
  booktitle = {Proceedings of the 1998 Conference of the Centre for Advanced Studies
	on Collaborative Research},
  year = {1998},
  pages = {11--},
  address = {Toronto, Ontario, Canada},
  publisher = {IBM Press},
  abstract = {Software engineers informally use block diagrams with boxes and lines
	to express system architectures. Diagrammatic representations of
	this type are also found in many speci�- cation techniques. However,
	rarely are architectural documents containing such representations
	systematically maintained; as a system evolves, architectural documents
	become obsolete, and the design history of the system is ultimately
	lost. Additionally, box-and-line representations used in these documents
	do not possess a precise semantics invariant across the di�erent
	techniques that rely on them. This paper addresses expression of
	system evolution at the architectural level based on a formal model
	of box-and-line diagrams. The formal model (a) provides semantic
	uniformity and precision; and (b) allows evolutionary steps to be
	represented as structural transformations. Interesting classes of
	such transformations are characterized in terms of the underlying
	operators. With these tools, the architectural evolution of a system
	is captured as a directed acyclic graph of baselines, where each
	baseline consists of a system of box-and-line diagrams, and is mapped
	to a successor baseline by a set of structural transformations. It
	is also shown how familiar design concepts|such as extension, abstraction,
	and structural re�nement| can be formalized in simple terms within
	the framework developed.},
  comment = {Not fully read yet. Looks at a way to represent architectural evolution
	by the transformation of component-connector graphs. Attempts to
	generalise this across component systems with different semantics.
	Introduces different types of structural transformations, where the
	intent is exposed.
	
	!read fully},
  owner = {amcveigh},
  refid = {41},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=783171&coll=Portal&dl=GUIDE&CFID=56765354&CFTOKEN=72300829#}
}

@ARTICLE{Eriksson2006,
  author = {Magnus Eriksson and J\"{u}rgen B\"{o}rstler and Kjell Borg},
  title = {Software Product Line Modeling Made Practical},
  journal = {Communications of the ACM},
  year = {2006},
  volume = {49},
  pages = {49--54},
  number = {12},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1183236.1183265},
  issn = {0001-0782},
  publisher = {ACM Press}
}

@INPROCEEDINGS{Escoffier2007,
  author = {Clement Escoffier and Richard S. Hall},
  title = {Dynamically Adaptable Applications with iPOJO Service Components},
  booktitle = {6th International Symposium on Software Composition (SC 2007)},
  year = {2007},
  abstract = {Traditional component models and frameworks simplified software
	
	system development by enabling developers to break software systems
	into
	
	independent pieces with well-defined interfaces. This approach led
	to looser
	
	coupling among the system pieces and enhanced possibilities for reuse.
	While the
	
	component-based approach led to advancements in the software development
	
	process, it still has its limitations. In particular, after a component-based
	
	application is developed and deployed it typically is a monolithic
	and static
	
	configuration of components. The advent of service-oriented component
	(SOC),
	
	the rise in popularity of consumer devices, and the ubiquity of connectivity
	have
	
	fostered a growing interest in applications that react dynamically
	to changes in
	
	the availability of various services. To simplify the creation of
	such dynamic
	
	software systems, it is possible to borrow concepts from SOC and include
	them
	
	into a component model, resulting in a service-oriented component
	model that
	
	specifically supports dynamically adaptable applications. This paper
	presents
	
	iPOJO, a service-oriented component framework to help developers implement
	
	dynamically adaptable software systems.},
  journal = {6th International Symposium on Software Composition (SC 2007)},
  owner = {amcveigh},
  review = {this is one I reviewed for the Jeffs.
	
	
	It discusses the merging of service oriented (dynamic) and component
	oriented ideas. it has clear language, and it proposes to deal with
	disappearing leaf services by repeatedly moving upwards and disabling
	upward services. could end up with a very fragile architecture.
	
	
	benefit over declarative services is unclear...},
  timestamp = {2007.04.02}
}

@INPROCEEDINGS{Evans1999a,
  author = {Evans, Andy and Kent, Stuart},
  title = {Meta-Modelling Semantics of UML: The pUML Approach},
  booktitle = {2nd International Conference on the Unified Modeling Language},
  year = {1999},
  pages = {140--155},
  month = {January},
  abstract = {The current UML semantics documentation has made a significant step
	towards providing a precise description of the UML. However, at present
	the semantic model it proposes only provides a description of the
	language's syntax and well-formedness rules. The meaning of the language,
	which is mainly described in English, is too informal and unstructured
	to provide a foundation for developing formal analysis and development
	techniques. Another problem is the scope of the model, which is both
	complex and large. This paper describes work currently being undertaken
	by the precise UML group (<SPAN style='background:silver;'>pUML</SPAN>),
	an international group of researchers and practitioners, to address
	these problems. A formalisation strategy is presented which concentrates
	on giving a precise denotational semantics to core elements of UML.
	This is illustrated through the development of precise definitions
	of two important concepts: generalization and packages. Finally,
	a viewpoint architecture is proposed as a means of providing improved
	separation of concerns in the semantics definition.},
  citeulike-article-id = {197546},
  journal = {Lecture Notes in Computer Science},
  keywords = {semantic, uml},
  owner = {andrew},
  posted-at = {2005-05-12 15:53:46},
  priority = {0},
  timestamp = {2009.06.09},
  url = {http://www.metapress.com/link.asp?id=NYU563JRFGC86CYW}
}

@INPROCEEDINGS{Evans1999,
  author = {Evans, H. and Dickman, P.},
  title = {Zones, Contracts and Absorbing Changes: An Approach to Software Evolution},
  booktitle = {Proceedings of the 14th ACM SIGPLAN Conference on Object-Oriented
	Programming, Systems, Languages, and Applications},
  year = {1999},
  pages = {415--434},
  address = {Denver, Colorado, United States},
  publisher = {ACM Press},
  abstract = {This paper describes a novel approach to managing the evolution of
	distributed, persistent systems at run-time. This is achieved by
	partitioning a system into disjoint zones, each of which can be evolved
	without affecting code in any other. Contracts are defined between
	zones, making type-level interdependencies and inter-zone communication
	explicit. Programmer supplied code is added to the running system,
	at the boundary between zones, to constrain the scope of changes.
	A change methodology is presented which the software engineer uses
	to help describe and manage the evolution of the system. Knowledge
	of the application semantics is essential when evolving a system
	and our approach allows the engineer to concentrate on these semantic
	aspects of change. Our Java-based demonstration platform and methodology
	reduce or remove some of the burdensome tasks the software engineer
	is normally expected to perform when changing a system, making evolution
	more tractable.},
  comment = {Defines several constructs to allow a system to evolve at runtime.
	A system is partitioned into several disjoint zones. Each zone has
	its own types. It communicates with other zones by means of service
	level interfaces, which are described by "contracts". These contracts
	are declarative, and describe how to translate information passed
	between zones. To evolve a zone, all processes into the zone are
	exited (by buffering comms maybe?) and then the zone can be fully
	evolved.
	
	2005-11-03},
  issn = {1-58113-238-7},
  keywords = {SYSTEMS},
  owner = {amcveigh},
  refid = {42},
  timestamp = {2006.03.14},
  url = {http://doi.acm.org/10.1145/320384.320430}
}

@INPROCEEDINGS{Fahmy2000,
  author = {Fahmy, H. and Holt, R.C.},
  title = {Using Graph Rewriting to Specify Software Architectural Transformations},
  booktitle = {Proceedings of the The Fifteenth IEEE International Conference on
	Automated Software Engineering (ASE'00)},
  year = {2000},
  pages = {187--},
  publisher = {IEEE Computer Society},
  abstract = {In order to understand, analyze and possibly modify software, we commonly
	examine and manipulate its architecture. For example, we may want
	to examine the architecture at different levels of abstraction or
	repair the architecture if it has deviated from our mental model
	of the software. We can view such manipulations as architectural
	transformations, and more specifically, as graph transformations.
	In this paper, we use graph rewriting to specify these transformations
	so that we can work towards automating them. Specifically, we use
	the PROGRES tool to formulate executable graph-rewriting specifications
	for various architectural transformations in order to demonstrate
	the strengths of using graph rewriting. We have applied our executable
	specifications to small graphs and our results confirm that graph
	rewriting offers a high-level visual notation that can be used to
	neatly specify graph modifications, as well as supporting prototype
	implementations. It also provides a convenient and intuitive framework
	for exploring various architectural transformations},
  comment = {Nice paper that deswcribes how graph rewriting can be used to specify
	simple architectural transformations. A basic example is worked through
	that shows how "unexpected" intermodule dependencies can be detected
	and repaired.
	
	2005-11-07},
  issn = {0-7695-0710-7},
  keywords = {SPECIFICATION},
  owner = {amcveigh},
  refid = {44},
  timestamp = {2006.03.14},
  url = {http://csdl2.computer.org/persagen/DLAbsToc.jsp?resourcePath=/dl/proceedings/&toc=comp/proceedings/ase/2000/0710/00/0710toc.xml&DOI=10.1109/ASE.2000.873663}
}

@ARTICLE{Fayad1997,
  author = {Fayad, M.E. and Schmidt, D.C.},
  title = {Object-Oriented Application Frameworks},
  journal = {Communications of the ACM},
  year = {1997},
  volume = {40},
  pages = {32--38},
  number = {10},
  month = oct,
  abstract = {Computing power and network bandwidth have increased dramatically
	over the past decade, yet the design and implementation of complex
	software remain expensive and error-prone. Much of the cost and effort
	stems from the continuous rediscovery and reinvention of core concepts
	and components across the software industry. In particular, the growing
	heterogeneity of hardware architectures and diversity of operating
	system and communication platforms make it difficult to build correct,
	portable, efficient, and inexpensive applications from scratch.},
  address = {WASHINGTON UNIV,DEPT COMP SCI,ST LOUIS,MO 63130},
  comment = {Times Cited: 48 Article English Fayad, M. E UNIV NEVADA,COLL ENGN,RENO,NV
	89557 Cited References Count: 9
	
	Very clear introductory paper to frameworks. Defines (informally)
	a framework, inversion of control, framework reuse, white vs grey
	vs black box frameworks and benefits of frameworks. Discusses the
	strengths and weaknesses of the approach. Mentions current frameworks
	suffer from an inability to define control flow explicitly.
	
	2005-10-23},
  issn = {0001-0782},
  keywords = {component},
  owner = {amcveigh},
  refid = {33},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=262798&coll=Portal&dl=GUIDE&CFID=58680448&CFTOKEN=64378225}
}

@ARTICLE{Feldman2005,
  author = {Feldman, Stuart},
  title = {A Conversation with Alan Kay},
  journal = {ACM Queue},
  year = {2005},
  volume = {2},
  pages = {20--30},
  number = {9},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1039511.1039523},
  issn = {1542-7730},
  owner = {andrew},
  publisher = {ACM},
  timestamp = {2009.07.31}
}

@INPROCEEDINGS{Figueiredo2008,
  author = {Figueiredo,, Eduardo and Cacho,, Nelio and Sant'Anna,, Claudio and
	Monteiro,, Mario and Kulesza,, Uira and Garcia,, Alessandro and Soares,,
	Sergio and Ferrari,, Fabiano and Khan,, Safoora and Castor Filho,,
	Fernando and Dantas,, Francisco},
  title = {Evolving Software Product Lines with Aspects: An Empirical Study
	on Design Stability},
  booktitle = {ICSE '08: Proceedings of the 30th International Conference on Software
	Engineering},
  year = {2008},
  pages = {261--270},
  address = {New York, NY, USA},
  publisher = {ACM},
  abstract = {Software product lines (SPLs) enable modular, large-scale reuse through
	a software architecture addressing multiple core and varying features.
	To reap the benefits of SPLs, their designs need to be stable. Design
	stability encompasses the sustenance of the product line's modularity
	properties in the presence of changes to both the core and varying
	features. It is usually assumed that aspect-oriented programming
	promotes better modularity and changeability of product lines than
	conventional variability mechanisms, such as conditional compilation.
	However, there is no empirical evidence on its efficacy to prolong
	design stability of SPLs through realistic development scenarios.
	This paper reports a quantitative study that evolves two SPLs to
	assess various design stability facets of their aspect-oriented implementations.
	Our investigation focused upon a multi-perspective analysis of the
	evolving product lines in terms of modularity, change propagation,
	and feature dependency. We have identified a number of scenarios
	which positively or negatively affect the architecture stability
	of aspectual SPLs.},
  doi = {http://doi.acm.org/10.1145/1368088.1368124},
  isbn = {978-1-60558-079-1},
  location = {Leipzig, Germany},
  review = {looks at how they evolved a product line using aspects. interestingly,
	it discusses the need to alter the underlying source to introduce
	aspect cutpoints!
	
	
	good case study, shows limitations of aspects somewhat as an evolutionary
	mechanism.}
}

@TECHREPORT{Filman2000,
  author = {Robert E. Filman and Daniel P. Friedman},
  title = {Aspect-Oriented Programming is Quantification and Obliviousness},
  institution = {RIACS},
  year = {2000},
  publisher = {RIACS},
  source = {http://www.ncstrl.org:8900/ncstrl/servlet/search?formname=detail\&id=oai%3ARIACS%3A00000046}
}

@INPROCEEDINGS{Findler1998,
  author = {Robert Bruce Findler and Matthew Flatt},
  title = {Modular Object-Oriented Programming with Units and Mixins},
  booktitle = {ICFP '98: Proceedings of the third ACM SIGPLAN International Conference
	on Functional Programming},
  year = {1998},
  pages = {94--104},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/289423.289432},
  isbn = {1-58113-024-4},
  location = {Baltimore, Maryland, United States},
  review = {mentioned in my "rejection" for SAVCBS 2007. Is a way of delaying
	binding until composition, but suffers from "taking up the slot"
	problem.}
}

@ARTICLE{Finkelstein1992,
  author = {Finkelstein, A. and Kramer, J. and Nuseibeh, B. and Finkelstein,
	L. and Goedicke, M.},
  title = {Viewpoints: A Framework for Integrating Multiple Perspectives in
	System Development},
  journal = {International Journal of Software Engineering and Knowledge Engineering},
  year = {1992},
  volume = {2(1)},
  pages = {31--58},
  abstract = {This paper outlines a framework which supports the use of multiple
	perspectives in system development, and provides a means for developing
	and applying systems design methods. The framework uses "viewpoints"
	to partition the system specification, the development method and
	the formal representations used to express the system specifications.
	This VOSE (viewpoint-oriented systems engineering) framework can
	be used to support the design of heterogeneous and composite systems.
	We illustrate the...},
  review = {interesting approach to system construction that differs from UML
	style views -- this approach has multiple representations and checks
	and transfers between them. interesting but a bit simplistic.},
  timestamp = {2006.09.07},
  url = {citeseer.ist.psu.edu/141147.html}
}

@INPROCEEDINGS{Foote1999,
  author = {Brian Foote and Joseph Yoder},
  title = {Big Ball of Mud},
  booktitle = {Fourth Conference on Patterns Languages of Programs},
  year = {1999},
  owner = {amcveigh},
  timestamp = {2007.07.10}
}

@MISC{Fowler2004,
  author = {Fowler, M.},
  title = {{Inversion of Control Containers and the Dependency Injection Pattern}},
  howpublished = {http://www.martinfowler.com/articles/injection.html},
  year = {last accessed August 2009},
  journal = {Website},
  owner = {amcveigh},
  review = {Eclipse plugin site, showing thousands of plugins.},
  timestamp = {2006.05.15},
  url = {http://www.martinfowler.com/articles/injection.html},
  volume = {http://www.martinfowler.com/articles/injection.html}
}

@INPROCEEDINGS{Froehlich1997,
  author = {Froehlich, G. and Hoover, J. and Liu, L. and Sorenson, P.},
  title = {Hooking into Object-Oriented Application Frameworks},
  booktitle = {Proceedings of the 19th International Conference on Software Engineering},
  year = {1997},
  pages = {491--501},
  address = {Boston, Massachusetts, United States},
  publisher = {ACM Press},
  abstract = {An object-oriented application framework provides a generic design
	within a given domain and a reusable implementation of that design.
	Frameworks have great potential for reuse, but that potential can
	only be achieved if the framework can be understood and used effectively
	by application developers. The complexity of the design and implementation
	of a framework can make understanding the framework difficult, and
	so good documentation and guidance to the framework user is needed.
	Several methods exist for documenting the design of the framework,
	but less work has been done on documenting the purpose of the framework
	and how it is intended to be used. In this paper, we introduce the
	concept of hooks as a means of documenting and providing guidance
	on the intended use of a framework. Each hook provides a concise
	solution to a focused requirement or problem within the context of
	the framework. Solutions for more complex requirements can be provided
	by combining several hooks. A discussion and means of describing
	hooks is given, with a focus on the method of adaption used to fulfill
	the requirement and the level of support provided for the solution
	within the framework.},
  comment = {must read. Have used as a reference for "hooks".},
  issn = {0-89791-914-9},
  owner = {amcveigh},
  refid = {51},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=253432&coll=Portal&dl=GUIDE&CFID=60884982&CFTOKEN=64386172#}
}

@BOOK{Gamma2003,
  title = {Contributing to Eclipse: Principles, Patterns, and Plugins},
  publisher = {Addison Wesley Longman Publishing Co., Inc.},
  year = {2003},
  author = {Erich Gamma and Kent Beck},
  address = {Redwood City, CA, USA},
  isbn = {0321205758}
}

@BOOK{Gamma1995,
  title = {Design Patterns: Elements of Reusable Object-Oriented Software},
  publisher = {Addison-Wesley},
  year = {1995},
  author = {Gamma, E. and Helm, R. and Johnson, R. and Vlissides J.},
  owner = {amcveigh},
  timestamp = {2006.05.30}
}

@INPROCEEDINGS{Garlan1997,
  author = {David Garlan and Robert Monroe and David Wile},
  title = {Acme: An Architecture Description Interchange Language},
  booktitle = {CASCON '97: Proceedings of the 1997 Conference of the Centre for
	Advanced Studies on Collaborative research},
  year = {1997},
  pages = {7},
  publisher = {IBM Press},
  location = {Toronto, Ontario, Canada}
}

@MISC{Gentleware2009,
  author = {{Gentleware AG}},
  title = {{Poseidon UML}},
  howpublished = {http://www.gentleware.com/products.html},
  year = {last accessed June 2009},
  owner = {andrew},
  timestamp = {2009.06.09},
  url = {http://www.gentleware.com/products.html}
}

@ARTICLE{Gogolla2007,
  author = {Gogolla, Martin and B\"{u}ttner, Fabian and Richters, Mark},
  title = {USE: A UML-Based Specification Environment for Validating UML and
	OCL},
  journal = {Science of Computer Programming},
  year = {2007},
  volume = {69},
  pages = {27--34},
  number = {1-3},
  address = {Amsterdam, The Netherlands, The Netherlands},
  doi = {http://dx.doi.org/10.1016/j.scico.2007.01.013},
  issn = {0167-6423},
  owner = {andrew},
  publisher = {Elsevier North-Holland, Inc.},
  timestamp = {2009.06.09}
}

@INPROCEEDINGS{Gogolla2003,
  author = {Martin Gogolla and J{\"o}rn Bohling and Mark Richters},
  title = {Validation of UML and OCL Models by Automatic Snapshot Generation.},
  booktitle = {UML},
  year = {2003},
  pages = {265-279},
  abstract = {This extended abstract recalls how visual language editors benefit
	from graph grammars and how the editor-generator DiaGen is based
	on this approach. We then outline how generated editors can create
	abstract diagram representations for further processing, e. g. for
	communication with other tools or for diagram visualizations with
	varying, adjustable detail level which is a valuable aid when editing
	large diagrams. These concepts are illustrated with UML class diagrams.},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://springerlink.metapress.com/openurl.asp?genre=article{\&}issn=0302-9743{\&}volume=2863{\&}spage=265},
  review = {simple and fairly accessible.
	
	
	snapshots are constructed using a language or manually. state space
	is limited very much like alloy.
	
	
	interesting, possibly better than alloy for checking well defined
	instances, but you can't really ask it questions as with alloy.}
}

@INPROCEEDINGS{Gomaa1998,
  author = {H. Gomaa and G. A. Farrukh},
  title = {Composition of Software Architectures from Reusable Architecture
	Patterns},
  booktitle = {ISAW '98: Proceedings of the Third International Workshop on Software
	Architecture},
  year = {1998},
  pages = {45--48},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  abstract = {In this paper a software architecture
	
	perspective is taken to designing reusable
	
	software applications. An application
	
	domain is defined as a family of systems that
	
	have some features in common and others
	
	that differentiate them. During domain
	
	engineering, reusable specifications,
	
	architectural design patterns, and component
	
	types are developed, which capture the
	
	similarities and variations of the family of
	
	systems that compose the application domain.
	
	This paper describes the composition of
	
	software architectures from reusable feature
	
	based domain specific architectural design
	
	patterns.},
  doi = {http://doi.acm.org/10.1145/288408.288420},
  isbn = {1-58113-081-3},
  location = {Orlando, Florida, United States},
  review = {very nify idea of tying features into layers that connect. nice pictures
	showing layers of component joining up.
	
	
	what about feature interaction? doesn't really cover...}
}

@MISC{GWT,
  author = {Google},
  title = {{Google Web Toolkit}},
  howpublished = {http://code.google.com/webtoolkit/},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.06.29},
  url = {http://code.google.com/webtoolkit/}
}

@MISC{GWT-Apps,
  author = {Google},
  title = {{Google Web Toolkit Application Gallery -- Google Code}},
  howpublished = {http://gwtgallery.appspot.com/},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.06.29},
  url = {http://gwtgallery.appspot.com/}
}

@INPROCEEDINGS{Goulo2003,
  author = {Goulo, M. and Abreu, F.},
  title = {Bridging the Gap between Acme and UML 2.0 for CBD},
  booktitle = {Specification and Verification of Component-Based Systems (SAVCBS
	2003)},
  year = {2003},
  comment = {Abstract: Architecture Description Languages (ADLs) such as Acme (a
	mainstream second generation ADL which contains the most common ADL
	constructs) provide formality in the description of software architectures,
	but are not easily reconciled with day-today development concerns,
	thus hampering their adoption by a larger community. UML, on the
	other hand, has become the de facto standard notation for design
	modeling, both in industry and in academia. In this paper we map
	Acme modeling abstractions into UML ...
	
	A decent paper that looks at the UML2 features for expressing an architecture,
	and concludes that connectors are underspecified and need to be phrased
	as separate components rather than UML connectors.
	
	2004-01-01},
  comments = {Abstract: Architecture Description Languages (ADLs) such as Acme (a
	mainstream second generation ADL which contains the most common ADL
	constructs) provide formality in the description of software architectures,
	but are not easily reconciled with day-today development concerns,
	thus hampering their adoption by a larger community. UML, on the
	other hand, has become the de facto standard notation for design
	modeling, both in industry and in academia. In this paper we map
	Acme modeling abstractions into UML ...
	
	A decent paper that looks at the UML2 features for expressing an architecture,
	and concludes that connectors are underspecified and need to be phrased
	as separate components rather than UML connectors.
	
	2004-01-01},
  keywords = {architecture description language, software architecture},
  owner = {amcveigh},
  refid = {28},
  timestamp = {2006.03.14},
  url = {http://citeseer.ist.psu.edu/680515.html}
}

@BOOK{Greenfield2004,
  title = {Software Factories: Assembling Applications with Patterns, Models,
	Frameworks, and Tools},
  publisher = {Wiley; 1st edition (August 16, 2004)},
  year = {2004},
  author = {Greenfield, J. and Short, K. and Cook, S. and Kent, S. and Crupi,
	J.},
  pages = {--},
  owner = {amcveigh},
  refid = {60},
  timestamp = {2006.03.14}
}

@ARTICLE{Gurp2001,
  author = {van Gurp,, J. and Bosch,, J.},
  title = {Design, Implementation and Evolution of Object Oriented Frameworks:
	Concepts and Guidelines},
  journal = {Software - Practice And Experience In the Second International Workshop
	on Component-Oriented Programming},
  year = {2001},
  volume = {31},
  pages = {277--300},
  number = {3},
  abstract = {Object-oriented frameworks provide software developers with the means
	to build an infrastructure for
	
	their applications. Unfortunately, frameworks do not always deliver
	on their promises of reusability and
	
	flexibility. To address this, we have developed a conceptual model
	for frameworks and a set of guidelines
	
	to build object oriented frameworks that adhere to this model. Our
	guidelines focus on improving the
	
	flexibility, reusability and usability (i.e. making it easy to use
	a framework) of frameworks.},
  address = {New York, NY, USA},
  doi = {http://dx.doi.org/10.1002/spe.366},
  issn = {0038-0644},
  publisher = {John Wiley \& Sons, Inc.}
}

@MISC{Haggar2002,
  author = {Peter Haggar},
  title = {{Double-Checked Locking and the Singleton Pattern}},
  howpublished = {http://www.ibm.com/developerworks/java/library/j-dcl.html},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.06.15}
}

@ARTICLE{Harel1987,
  author = {Harel, David},
  title = {Statecharts: A Visual Formalism for Complex Systems},
  journal = {Science of Computer Programming},
  year = {1987},
  volume = {8},
  pages = {231--274},
  number = {3},
  address = {Amsterdam, The Netherlands, The Netherlands},
  doi = {http://dx.doi.org/10.1016/0167-6423(87)90035-9},
  issn = {0167-6423},
  owner = {andrew},
  publisher = {Elsevier North-Holland, Inc.},
  timestamp = {2009.06.26}
}

@BOOK{Harrop2005,
  title = {Pro Spring},
  publisher = {Apress},
  year = {2005},
  author = {Harrop, R. and Machacek, J.},
  owner = {amcveigh},
  timestamp = {2006.05.30}
}

@INPROCEEDINGS{Hay2000,
  author = {Hay, J.D. and Atlee, J.M.},
  title = {Composing Features and Resolving Interactions},
  booktitle = {SIGSOFT '00/FSE-8: Proceedings of the 8th ACM SIGSOFT International
	Symposium on Foundations of Software Engineering},
  year = {2000},
  pages = {110--119},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  abstract = {One of the accepted techniques for developing and maintaining feature-rich
	applications is to treat each feature as a separate concern. However,
	most features are not separate concerns because they override and
	extend the same basic service. That is, �independent� features are
	coupled to one another through the system's basic service. As a result,
	seemingly unrelated features subtly interfere with each other when
	trying to override the system behaviour in different directions.
	The problem is how to coordinate features' access to the service's
	shared variables.
	
	
	This paper proposes coordinating features via feature composition.
	We model each feature as a separate labelled-transition system and
	define a 1conflict-free (CF) composition operator that prevents enabled
	transitions from synchronizing if they interact: if several features'
	transitions are simultaneously enabled but have conflicting actions,
	a non-conflicting subset of the enabled transitions are synchronized
	in the composition. We also define a conflict- and violation-free
	(CVF) composition operator that prevents enabled transitions from
	executing if they violate features' invariants. Both composition
	operators use priorities among features to decide whether to synchronize
	transitions.},
  comments = {Looks at feature interaction from a telco perspective. The idea is
	taht features should be developed as separate concerns, because this
	"illusion" simplifies the design and development of features. i.e.
	features can be contracted out, potentially. Each feature is abstracted
	to a set of assertions and transitions, with invariants also possible.
	Each feature specifies these transitions, and you can compose these
	to find interactions. Interestingly, sometimes interactions are desirable
	-- i.e. you want to update the feature in the presence of another.
	
	
	The formalisms are simple, but presented in a complex, and comprehensive
	way. The basic idea is that conflicts are picked up and resolved
	by prioritising features. Finally, weak invariants are added which
	allow the service to say something about the properties that must
	hold for the service. These can be "relaxed" by higher priority features,
	but are still asserted to handle interaction with lower priority
	features.
	
	
	There is a lot of good language and phrases in this paper. Well worth
	a re-read. This is also valuable as a source of info about why features
	interact, in case I need to reverse engineer feature conflicts etc.},
  doi = {http://doi.acm.org/10.1145/355045.355061},
  isbn = {1-58113-205-0},
  location = {San Diego, California, United States},
  timestamp = {2006.03.03},
  url = {http://portal.acm.org/citation.cfm?id=355061&coll=Portal&dl=GUIDE&CFID=73394572&CFTOKEN=93442719#}
}

@MISC{Headway,
  author = {{Headway Software Technologies Ltd}},
  title = {{Structure101 - Software Architecture Analysis for Java, C/C++ and
	Anything}},
  howpublished = {http://www.headwaysoftware.com/index.php},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.07.24},
  url = {http://www.headwaysoftware.com/index.php}
}

@INPROCEEDINGS{Helm1990,
  author = {Helm, R. and Holland, I.M. and Gangopadhyay, D.},
  title = {Contracts: Specifying Behavioral Compositions in Object-Oriented
	Systems},
  booktitle = {Proceedings of the European Conference on Object-Oriented Programming:
	Systems, Languages, and Applications},
  year = {1990},
  pages = {169--180},
  address = {Ottawa, Canada},
  publisher = {ACM Press},
  comment = {97967
	
	http://doi.acm.org/10.1145/97945.97967},
  issn = {0-201-52430-X},
  keywords = {SYSTEMS},
  owner = {amcveigh},
  refid = {61},
  timestamp = {2006.03.14}
}

@INCOLLECTION{Henderson-Sellers2006,
  author = {Henderson-Sellers, B. and Gonzalez-Perez, C.},
  title = {Uses and Abuses of the Stereotype Mechanism in UML 1.x and 2.0},
  booktitle = {Model Driven Engineering Languages and Systems},
  publisher = {Springer},
  year = {2006},
  pages = {16--26},
  abstract = {Stereotypes were introduced into the UML in order to offer extensibility
	to the basic metamodel structure by the user and without actually
	modifying the metamodel. In UML version 1.x, this was accomplished
	by means of permitting virtual subtyping in the metamodel. However,
	this facility led many to misuse stereotypes, particularly in places
	where regular domain-level modelling would be more appropriate. In
	version 2.0 of the UML, the portion of the metamodel pertaining to
	stereotypes was drastically revised. The resulting mechanism is reviewed
	here and compared with that of version 1.x. From a set theory point
	of view, the new (2.0) metamodel is unfortunately untenable and the
	examples used in the OMG documentation unconvincing. This paper outlines
	the issues and suggests some possible steps to improve the UML 2.0
	stereotype theory and practice.},
  citeulike-article-id = {4079645},
  doi = {10.1007/11880240\_2},
  journal = {Model Driven Engineering Languages and Systems},
  keywords = {get-it},
  owner = {andrew},
  posted-at = {2009-02-22 10:56:46},
  priority = {2},
  timestamp = {2009.04.04},
  url = {http://dx.doi.org/10.1007/11880240\_2}
}

@INPROCEEDINGS{Hendrickson2007,
  author = {Hendrickson, Scott A. and van der Hoek, Andre},
  title = {Modeling Product Line Architectures Through Change Sets and Relationships},
  booktitle = {ICSE '07: Proceedings of the 29th International Conference on Software
	Engineering},
  year = {2007},
  pages = {189--198},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  abstract = {The essence of any modeling approach for product line architectures
	lies in its ability to express variability. Existing approaches do
	so by explicitly specifying variation points inside the architectural
	specification of the entire product line, usually with optional and
	alternative elements of some form. This, however, leads to a sizable
	mismatch between conceptual variability (i.e., the features through
	which architects logically view and interpret differences in product
	architectures) and actual variability (i.e., the modeling constructs
	through which the logical differences must be expressed). We contribute
	a new product line architecture modeling approach that unites the
	two. Our approach uses change sets to group related architectural
	differences and relationships to govern which change set combinations
	are valid when composed into a particular product architecture. The
	result lifts modeling of variability out of modeling architectural
	structure, consolidates related variation points, and explicitly
	and separately manages their compatibilities.},
  doi = {http://dx.doi.org/10.1109/ICSE.2007.56},
  isbn = {0-7695-2828-7},
  review = {Applies changes sets to underlying ADL to allow arbitrary changes.
	then allows relationships between change sets.
	
	
	very comparable to Backbone approach, but merging is very much limited.
	No resemblance, so it doesn't apply to local reuse. Concerns about
	usability for larger architectures.
	
	
	Also, doesn't appear to feature any form of replacement. Does use
	UUIDs though.}
}

@INPROCEEDINGS{heuzeroth99b,
  author = {Dirk Heuzeroth and Ralf Reussner},
  title = {Dynamic Coupling of Binary Components and its Technical Support},
  booktitle = {First Workshop on Generative and Component based Software Engineering
	(GCSE) -- Young Researchers Workshop},
  year = {1999},
  abstract = {The aim of todays software development is to build applications by
	the reuse of binary components.
	
	This requires the composition of components and as special cases component
	enhancement
	
	as well as adaption. We demonstrate how to deal with these cases by
	furnishing components with
	
	a type consisting of two protocols � a call and a use protocol. We
	model these protocols by finite
	
	automata and show how those reflect component enhancement and adaption.
	This mechanism allows
	
	for automatic adaption of components in changing environments.
	
	In order to obtain binary components we have to compile corresponding
	sources. In view of the
	
	required features of the binary components and with the problems of
	compiling generic classes in
	
	mind, we describe an approach to generate such pre-compiled components
	by appropriate compiler
	
	extensions.},
  adress = {Erfurt, Germany},
  review = {this is very poor and hard to understand. It is also *very* incorrect
	in places. e.g. binary compilation of frameworks.
	
	
	tries to use automata to verify protocols.},
  timestamp = {2006.09.11},
  url = {citeseer.ist.psu.edu/article/heuzeroth99dynamic.html}
}

@INPROCEEDINGS{Hillman2004,
  author = {Hillman, J. and Warren, I.},
  title = {An Open Framework for Dynamic Reconfiguration},
  booktitle = {Proceedings of the 26th International Conference on Software Engineering},
  year = {2004},
  pages = {594--603},
  publisher = {IEEE Computer Society},
  comment = {Recommended by Jeff K. Describes an "open" implementation of a system
	to allow dynamic reconfiguration of architectures. Separates out
	the algorithm from the reconfiguration manager, and defines their
	responsibilities. Discusses 2 approaches to achieving quiescent state:
	blocking components and blocking connectors.
	
	2005-10-11},
  issn = {0-7695-2163-0},
  owner = {amcveigh},
  refid = {3},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=999462&coll=GUIDE&dl=GUIDE&CFID=57996419&CFTOKEN=31358059#}
}

@INPROCEEDINGS{Hoek1996,
  author = {Andr\'{e} van der Hoek and Dennis Heimbigner and Alexander L. Wolf},
  title = {A Generic, Peer-to-Peer Repository for Distributed Configuration
	Management},
  booktitle = {ICSE '96: Proceedings of the 18th International Conference on Software
	engineering},
  year = {1996},
  pages = {308--317},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  isbn = {0-8186-7246-3},
  location = {Berlin, Germany},
  review = {earliest academic paper i could find that addressed distributed config
	mgmt directly.}
}

@INPROCEEDINGS{Hoek2001,
  author = {van der Hoek, A. and Mikic-Rakic, M. and Roshandel, R. and Medvidovic,
	N.},
  title = {Taming Architectural Evolution},
  booktitle = {Proceedings of the 8th European Software Engineering Conference held
	jointly with 9th ACM SIGSOFT International Symposium on Foundations
	of Software Engineering},
  year = {2001},
  pages = {1--10},
  address = {Vienna, Austria},
  publisher = {ACM Press},
  abstract = {In the world of software development everything evolves. So, then,
	do software architectures. Unlike source code, for which the use
	of a configuration management (CM) system is the predominant approach
	to capturing and managing evolution, approaches to capturing and
	managing architectural evolution span a wide range of disconnected
	alternatives. This paper contributes a novel architecture evolution
	environment, called Mae, which brings together a number of these
	alternatives. The environment facilitates an incremental design process
	in which all changes to all architectural elements are integrally
	captured and related. Key to the environment is a rich system model
	that combines architectural concepts with those from the field of
	CM. Not only does this system model form the basis for Mae, but in
	precisely capturing architectural evolution it also facilitates automated
	support for several innovative capabilities that rely on the integrated
	nature of the system model. This paper introduces three of those:
	the provision of design guidance at the architectural level, the
	use of specialized software connectors to ensure run-time reliability
	during component upgrades, and the creation of component-level patches
	to be applied to deployed system configurations.},
  comment = {!read},
  issn = {1-58113-390-1},
  keywords = {software architecture, configuration, connector, component},
  owner = {amcveigh},
  refid = {39},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=503211&coll=Portal&dl=GUIDE&CFID=56765354&CFTOKEN=72300829#}
}

@INPROCEEDINGS{Holzle1993,
  author = {Holzle, U.},
  title = {Integrating Independently-Developed Components in Object-Oriented
	Languages},
  booktitle = {Proceedings of the 7th European Conference on Object-Oriented Programming},
  year = {1993},
  pages = {36--56},
  publisher = {Springer-Verlag},
  comment = {Good paper, very early and influential, but examples are too simplistic.
	Proposes type adaptation to adjust types in place. Need to look into
	extension hierarchies referenced in the paper -- sound a bit like
	BB extensions. The wrapping ideas here are very relevant.
	
	2005-12-12},
  issn = {3-540-57120-5},
  keywords = {component},
  owner = {amcveigh},
  refid = {76},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=679351#}
}

@INPROCEEDINGS{Hou2001,
  author = {Hou, D. and Hoover, J.},
  title = {Towards Specifying Constraints for Object-Oriented Frameworks},
  booktitle = {Proceedings of the 2001 Conference of the Centre for Advanced Studies
	on Collaborative Research},
  year = {2001},
  pages = {5},
  address = {Toronto, Ontario, Canada},
  publisher = {IBM Press},
  abstract = {Object-oriented frameworks are often hard to learn and use [1, 3].
	As a result, software cost rises and quality suers. Thus the capabil-
	ity to automatically detect errors occurring at the boundary between
	frameworks and applica- tions is considered crucial to mitigate the
	prob- lem. This paper introduces the notion of frame- work constraints
	and a specication language, FCL (Framework Constraints Language),
	to formally specify them. Framework constraints are rules that frameworks
	impose on the code of framework-based applications. The semantics
	of FCL is primarily based on rst order predi- cate logic and set
	theory though the syntax is designed to resemble that of programming
	lan- guages as much as possible. We take examples from the MFC (Microsoft
	Foundation Classes) framework [19] demonstrating both the nature
	of framework constraints and the semantics of FCL. Essentially, framework
	constraints can be regarded as framework-specic typing rules conveyed
	by the specication language FCL, and thus can be enforced by techniques
	analo- gous to those of conventional type checking.},
  comment = {Introduces a framework constraint language (FCL) that documents and
	specifies a framework. Intended to (at least partially) record intentions
	of the original designers. The language is a bit simplistic, but
	it allows sequencing and other simple terms to be specified. Impractical
	for use, as it needs to parse the code (!) to work out if the constraints
	are violated!!!
	
	2005-10-24},
  owner = {amcveigh},
  refid = {34},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=782101&coll=GUIDE&dl=GUIDE&CFID=58678673&CFTOKEN=85896761#}
}

@BOOK{Hoy2002,
  title = {Java Swing},
  publisher = {O'Reilly \& Associates, Inc.},
  year = {2002},
  author = {Hoy,, Marc and Wood,, Dave and Loy,, Marc and Elliot,, James and
	Eckstein,, Robert},
  address = {Sebastopol, CA, USA},
  isbn = {0596004087},
  owner = {andrew},
  timestamp = {2009.03.31}
}

@MISC{IBM,
  author = {IBM},
  title = {{Rational Software Architect for WebSphere Software}},
  howpublished = {http://www-01.ibm.com/software/awdtools/swarchitect/websphere/},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.06.19},
  url = {http://www-01.ibm.com/software/awdtools/swarchitect/websphere/}
}

@MISC{IBMa,
  author = {IBM},
  title = {{Rational Application Developer for WebSphere Software}},
  howpublished = {http://www-01.ibm.com/software/awdtools/developer/application/},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.06.19},
  url = {http://www-01.ibm.com/software/awdtools/developer/application/}
}

@TECHREPORT{Ichisugi2002a,
  author = {Yuuji Ichisugi},
  title = {Layered Class Diagram --The Way to Express Class Structures of MixJuice
	Programs.},
  institution = {National Institute of Advanced Industrial Science and Technology
	(AIST)},
  year = {2002},
  file = {lclass-diag-20021030.pdf:http\://staff.aist.go.jp/y-ichisugi/mj/papers/lclass-diag-20021030.pdf:PDF},
  owner = {amcveigh},
  review = {Nice pictures of MixJuice programs.},
  timestamp = {2007.07.09},
  url = {http://staff.aist.go.jp/y-ichisugi/mj/papers/lclass-diag-20021030.pdf}
}

@INPROCEEDINGS{Ichisugi2002,
  author = {Yuuji Ichisugi and Akira Tanaka},
  title = {Difference-Based Modules: A Class-Independent Module Mechanism},
  booktitle = {ECOOP '02: Proceedings of the 16th European Conference on Object-Oriented
	Programming},
  year = {2002},
  pages = {62--88},
  address = {London, UK},
  publisher = {Springer-Verlag},
  abstract = {We describe a module mechanism, which we call differencebased
	
	modules, and an object-oriented language we call MixJuice. MixJuice
	
	is an enhancement to the Java language that adopts difference-based
	
	modules instead of Java�s original module mechanism. Modules are units
	
	of information hiding, reuse and separate compilation. We have completely
	
	separated the class mechanism and the module mechanism, and
	
	then unified the module mechanism and the differential programming
	
	mechanism. Although this module mechanism is simpler than that of
	
	Java, it enhances ease with which programs can be extended, reused
	and
	
	maintained. Collaborations that crosscut several classes can be separated
	
	into different modules. Modules are composable in the same way as
	mixins.
	
	The composition of modules sometimes causes name collision and
	
	an interesting phenomenon, which we call implementation defects. We
	
	describe solutions to these problems.},
  isbn = {3-540-43759-2},
  review = {Paper is very similar to what I am doing, except rather than use an
	ADL and components, they apply the ideas directly to Java and propose
	that their modules be used instead of packages. My work has major
	parallels with this and must cite this!
	
	
	Basically, they use inheritance instead of resemblance, and they use
	class and interface "extension" instead of redefinition. I strongly
	suspect that it is rewriting everything in terms of inheritance under
	the covers although I don't think it explicitly indicates this.
	
	
	This paper is important because it gives insight on how well the approach
	of development-by-difference works, and it also shows that a module
	can be regarded as a feature set or as an aspect. Nice for reference
	in my work.
	
	
	NOTE: has further papers on modeling approach (UML), extension rules
	for safely composing, and an experience report on how refactoring
	works in this approach.
	
	
	Limitations of approach:
	
	--------------------
	
	1. limited to the semantics of inheritance, which makes full evolution
	impossible
	
	2. trying to replace packages and nested classes, but it doesn't provide
	the full functionality of nested classes (c.f. poor example in 3.3)
	
	3. needs to linearise modules -- conflict resolution is not powerful
	enough, possible because of (1)
	
	
	Similarities:
	
	----------
	
	1. difference modules = stratum, class = component, inheritance =
	resemblance, extension = redefinition, dependencies between modules
	provide a partial order
	
	2. non-hierarchical modules
	
	3. discusses independently developed modules and clashes that can
	result.
	
	4. idea of complementary modules to resolve conficts between independent
	modules
	
	5. NoSource -- doesn't require the source of java to extensively change.
	Maybe better at this than my stuff, which requires ADL source.
	
	6. Use of fully-qualified-names / UUIDs to solve problem with name
	clashes in independently developed modules
	
	7. use of .original() for delegation versus actual delegation/wrapping
	in Backbone
	
	
	MixJuice is better at:
	
	-----------------
	
	1. unit of change granularity is naturally lower, as it works with
	implementation classes/interfaces directly. low design overhead.
	
	2. no need for 2 languages (ADL, Java)
	
	3. complementary modules are included automatically
	
	
	Backbone is better at:
	
	------------------
	
	1. component model is recursive and more architecturally powerful
	
	 a. attribute aliasing -- notion of higher state
	
	 b. ability to change original instance config + factories -- i.e.
	natural object graphs
	
	2. resemblance/redefinition allows arbitrary changes, can model software
	evolution more fully
	
	3. baselining, as a result of (2)
	
	4. behavioural specs + goal specs -- ties into recursive approach
	+ FSP
	
	5. formal semantics -- does MixJuice have these?
	
	6. deals with partial order through merge and resolution rules --
	made more powerful by 2.
	
	7. multiple resemblance, even for components
	
	8. modelling approach (view as at a particular stratum)
	
	9. renaming support via modelling approach for refactoring etc.
	
	
	Some techniques I can use from the paper
	
	-----------------------------------
	
	1. separation of specification of component in one module, and multiple
	implementations in another which "redefine" the spec
	
	2. nested if statements through chaining / delegation},
  timestamp = {2007.03.26}
}

@MISC{Jackson2005,
  author = {Jackson, D.},
  title = {{Alloy Home Page}},
  howpublished = {http://alloy.mit.edu/},
  year = {last accessed August 2009},
  address = {http://alloy.mit.edu/},
  owner = {amcveigh},
  pages = {--},
  refid = {65},
  timestamp = {2006.03.14},
  url = {http://alloy.mit.edu/}
}

@BOOK{Jackson2006,
  title = {Software Abstractions: Logic, Language, and Analysis},
  publisher = {The MIT Press},
  year = {2006},
  author = {Daniel Jackson},
  month = {April},
  abstract = {In Software Abstractions Daniel Jackson introduces a new approach
	to software design that draws on traditional formal methods but exploits
	automated tools to find flaws as early as possible. This approach—which
	Jackson calls "lightweight formal methods" or "agile modeling"—takes
	from formal specification the idea of a precise and expressive notation
	based on a tiny core of simple and robust concepts but replaces conventional
	analysis based on theorem proving with a fully automated analysis
	that gives designers immediate feedback. Jackson has developed Alloy,
	a language that captures the essence of software abstractions simply
	and succinctly, using a minimal toolkit of mathematical notions.
	The designer can use automated analysis not only to correct errors
	but also to make models that are more precise and elegant. This approach,
	Jackson says, can rescue designers from "the tarpit of implementation
	technologies" and return them to thinking deeply about underlying
	concepts.
	
	
	Software Abstractions introduces the key elements of the approach:
	a logic, which provides the building blocks of the language; a language,
	which adds a small amount of syntax to the logic for structuring
	descriptions; and an analysis, a form of constraint solving that
	offers both simulation (generating sample states and executions)
	and checking (finding counterexamples to claimed properties). The
	book uses Alloy as a vehicle because of its simplicity and tool support,
	but the book's lessons are mostly language-independent, and could
	also be applied in the context of other modeling languages.},
  owner = {andrew},
  review = {the definitive book!!},
  timestamp = {2009.05.13}
}

@ARTICLE{Jackson2002,
  author = {Daniel Jackson},
  title = {Alloy: A Lightweight Object Modelling Notation},
  journal = {ACM Transactions on Software Engineering and Methodology (TOSEM)},
  year = {2002},
  volume = {11},
  pages = {256--290},
  number = {2},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/505145.505149},
  issn = {1049-331X},
  publisher = {ACM Press}
}

@ARTICLE{Johnson1997,
  author = {Johnson, R.E.},
  title = {Frameworks = (Components + Patterns)},
  journal = {Communications of the ACM},
  year = {1997},
  volume = {40},
  pages = {39--42},
  number = {10},
  comment = {Defines a framework, and looks at how it differs from components and
	patterns. Mentions their similarity to components.
	
	2005-10-24},
  issn = {0001-0782},
  keywords = {component},
  owner = {amcveigh},
  publisher = {ACM Press},
  refid = {36},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=262799&coll=GUIDE&dl=GUIDE&CFID=58678673&CFTOKEN=85896761#}
}

@INPROCEEDINGS{Johnson1997a,
  author = {Johnson, R.E.},
  title = {Components, Frameworks, Patterns},
  booktitle = {Proceedings of the 1997 Symposium on Software Reusability},
  year = {1997},
  pages = {10--17},
  address = {Boston, Massachusetts, United States},
  publisher = {ACM Press},
  abstract = {Frameworks are an object-oriented reuse technique. They share a lot
	of characteristics with reuse techniques in general, and object-oriented
	reuse techniques in particular. Although they have been used successfully
	for some time, and are an important part of the culture of long-time
	object-oriented developers, most framework development projects are
	failures, and most object-oriented met homologies do not describe
	how to use frameworks. Moreover, there is a lot of confusion about
	whether frameworks are just large+ scale patterns, or whether they
	are just another kind of component.},
  comment = {Very similar to the Frameworks = (Components + Patterns) paper. Has
	extra references.
	
	2005-10-27},
  issn = {0-89791-945-9},
  keywords = {component},
  owner = {amcveigh},
  refid = {37},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=258378&coll=GUIDE&dl=GUIDE&CFID=58678673&CFTOKEN=85896761#}
}

@BOOK{Johnson2005,
  title = {Professional Java Development with the Spring Framework},
  publisher = {Hungry Minds Inc, U.S.},
  year = {2005},
  author = {Rod Johnson and Juergen Hoeller and Alef Arendsen and Thomas Risberg
	and Colin Sampaleanu},
  owner = {amcveigh},
  timestamp = {2007.07.09}
}

@INPROCEEDINGS{Jorgensen2004,
  author = {Jorgensen, B.N.},
  title = {Language Support for Incremental Integration of Independently Developed
	Components in Java},
  booktitle = {SAC '04: Proceedings of the 2004 ACM Symposium on Applied Computing},
  year = {2004},
  pages = {1316--1322},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  doi = {http://doi.acm.org/10.1145/967900.968166},
  isbn = {1-58113-812-1},
  location = {Nicosia, Cyprus}
}

@TECHREPORT{Kang1990,
  author = {K. C. Kang and S. G. Cohen and J. A. Hess and W. E. Novak and A.
	S. Peterson},
  title = {Feature-Oriented Domain Analysis (FODA) Feasibility Study},
  institution = {Carnegie-Mellon University Software Engineering Institute},
  year = {1990},
  month = {November},
  interhash = {7d9a7ab3a80077c31cfd2a83150d5b3f},
  intrahash = {1910de1c3156c3a5821385760069cc52},
  owner = {andrew},
  timestamp = {2009.06.24}
}

@INPROCEEDINGS{Kastner2008,
  author = {Kastner, Christian and Apel, Sven and Kuhlemann, Martin},
  title = {Granularity in Software Product Lines},
  booktitle = {ICSE '08: Proceedings of the 30th International Conference on Software
	Engineering},
  year = {2008},
  pages = {311--320},
  address = {New York, NY, USA},
  publisher = {ACM},
  abstract = {Building software product lines (SPLs) with features is a challenging
	task. Many SPL implementations support features with coarse granularity
	- e.g., the ability to add and wrap entire methods. However, fine-grained
	extensions, like adding a statement in the middle of a method, either
	require intricate workarounds or obfuscate the base code with annotations.
	Though many SPLs can and have been implemented with the coarse granularity
	of existing approaches, fine-grained extensions are essential when
	extracting features from legacy applications. Furthermore, also some
	existing SPLs could benefit from fine-grained extensions to reduce
	code replication or improve readability. In this paper, we analyze
	the effects of feature granularity in SPLs and present a tool, called
	Colored IDE (CIDE), that allows features to implement coarse-grained
	and fine-grained extensions in a concise way. In two case studies,
	we show how CIDE simplifies SPL development compared to traditional
	approaches.},
  doi = {http://doi.acm.org/10.1145/1368088.1368131},
  isbn = {978-1-60558-079-1},
  location = {Leipzig, Germany},
  review = {provides the CIDE (coloured IDE) which allows for bits of code to
	be annotated and changes to be made to arbitrary methods etc. they
	compare their approach to the compositional approach, which uses
	Jak. interstingly Jak features the refine concept -- definitely need
	to reference.
	
	
	Excellent references, but a fragile approach which breaks when changes
	are made bottom up to existing artifacts.}
}

@ARTICLE{Kemerer1999,
  author = {Chris F. Kemerer and Sandra Slaughter},
  title = {An Empirical Approach to Studying Software Evolution},
  journal = {IEEE Transactions on Software Engineering},
  year = {1999},
  volume = {25},
  pages = {493--509},
  number = {4},
  abstract = {With the approach of the new millennium, a primary focus in software
	engineering involves issues relating to upgrading, migrating, and
	evolving existing software systems. In this environment, the role
	of careful empirical studies as the basis for improving software
	maintenance processes, methods, and tools is highlighted. One of
	the most important processes that merits empirical evaluation is
	software evolution. Software evolution refers to the dynamic behavior
	of software systems as they are maintained and enhanced over their
	lifetimes. Software evolution is particularly important as systems
	in organizations become longer-lived. However, evolution is challenging
	to study due to the longitudinal nature of the phenomenon in addition
	to the usual difficulties in collecting empirical data. In this paper,
	we describe a set of methods and techniques that we have developed
	and adapted to empirically study software evolution. Our longitudinal
	empirical study involves collecting, coding, and analyzing more than
	25,000 change events to 23 commercial software systems over a 20-year
	period. Using data from two of the systems, we illustrate the efficacy
	of flexible phase mapping and gamma sequence analytic methods originally
	developed in social psychology to examine group problem solving processes.
	We have adapted these techniques in the context of our study to identify
	and understand the phases through which a software system travels
	as it evolves over time. We contrast this approach with time series
	analysis, the more traditional way of studying longitudinal data.
	Our work demonstrates the advantages of applying methods and techniques
	from other domains to software engineering and illustrates how, despite
	difficulties, software evolution can be empirically studied.},
  address = {Piscataway, NJ, USA},
  doi = {http://dx.doi.org/10.1109/32.799945},
  issn = {0098-5589},
  publisher = {IEEE Press},
  review = {contains the 50% figure for software maintenance and evolution.}
}

@INPROCEEDINGS{Khare2001,
  author = {Khare,, R. and Guntersdorfer,, M. and Oreizy,, P. and Medvidovic,,
	N. and Taylor,, R.},
  title = {xADL: Enabling Architecture-Centric Tool Integration with XML},
  booktitle = {HICSS '01: Proceedings of the 34th Annual Hawaii International Conference
	on System Sciences ( HICSS-34)-Volume 9},
  year = {2001},
  pages = {9053},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  isbn = {0-7695-0981-9},
  owner = {andrew},
  timestamp = {2009.04.04}
}

@INBOOK{Kiczales1993,
  chapter = {4: Metaobject Protocols: Why We Want Them and What Else Can They
	Do},
  pages = {101-131},
  title = {Object-Oriented Programming: The CLOS Perspective},
  publisher = {MIT Press},
  year = {1993},
  editor = {Andreas Paepcke},
  author = {Gregor Kiczales and J. Michael Ashley and Luis H. Rodriguez Jr. and
	Amin Vahdat and Daniel G. Bobrow},
  abstract = {Originally conceived as a neat idea that could help solve problems
	in the design and implementation
	
	of CLOS, the metaobject protocol framework now appears to have applicability
	to a wide range
	
	of problems that come up in high-level languages. This chapter sketches
	this wider potential, by
	
	drawing an analogy to ordinary language design, by presenting some
	early design principles, and
	
	by presenting an overview of three new metaobject protcols we have
	designed that, respectively,
	
	control the semantics of Scheme, the compilation of Scheme, and the
	static parallelization of Scheme
	
	programs.},
  owner = {andrew},
  timestamp = {2009.03.31}
}

@INPROCEEDINGS{Kiczales1992,
  author = {Kiczales, G. and Lamping, J.},
  title = {Issues in the Design and Specification of Class Libraries},
  booktitle = {ACM SIGPLAN Notices},
  year = {1992},
  pages = {435--451},
  address = {Vancouver, British Columbia, Canada},
  publisher = {ACM Press},
  abstract = {The design and specification of an extensible class library presents
	a difficult challenge: because extensibility comes from allowing
	the user to override parts of the implementation, more of the internal
	structure must be exposed to the user than in a typical procedure
	library. This raises issues in both how the library is designed and
	how its specification is written. Specification of the CLOS Metaobject
	Protocol required a combination of new and existing techniques to
	address these issues. We present those techniques, and discuss their
	relation to the underlying issues.},
  comment = {An older paper which predates the framework term. Looks at the issues
	with making an extensible class library. Has very clear, precise
	terminology and explains the notion of framework extension very well.
	Mentions layered protocols as a possible way of solving the issues,
	in order to resolve the tension between ease of use and extensibility.
	
	2005-11-16},
  issn = {0-201-53372-3},
  keywords = {SPECIFICATION, SYSTEMS},
  owner = {amcveigh},
  refid = {49},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=141971&coll=Portal&dl=GUIDE&CFID=60884982&CFTOKEN=64386172#}
}

@INCOLLECTION{kiczales97aspectoriented,
  author = {Kiczales, G. and Lamping, J. and Menhdhekar, A. and Maeda, C. and
	Lopes, C. and Loingtier, J.M. and Irwin, J.},
  title = {Aspect-Oriented Programming},
  booktitle = {Proceedings European Conference on Object-Oriented Programming},
  publisher = {Springer-Verlag},
  year = {1997},
  editor = {Mehmet Ak\c{s}it and Satoshi Matsuoka},
  volume = {1241},
  pages = {220--242},
  address = {Berlin, Heidelberg, and New York},
  url = {citeseer.ist.psu.edu/kiczales97aspectoriented.html}
}

@BOOK{Kiczales1991,
  title = {The Art of the Metaobject Protocol},
  publisher = {The MIT Press},
  year = {1991},
  author = {Kiczales, Gregor and des Rivieres, Jim and Bobrow, Daniel G.},
  owner = {andrew},
  timestamp = {2009.03.31}
}

@ARTICLE{Kramer1990,
  author = {Kramer, J. and Magee, J.},
  title = {The Evolving Philosophers Problem - Dynamic Change Management},
  journal = {IEEE Transactions on Software Engineering},
  year = {1990},
  volume = {16},
  pages = {1293--1306},
  number = {11},
  month = nov,
  comment = {Times Cited: 44 Article English KRAMER, J UNIV LONDON,IMPERIAL COLL
	SCI TECHNOL,DEPT COMP,180 QUEENS GATE,LONDON SW7 2BZ,ENGLAND Cited
	References Count: 21
	
	A very clear and amazingly innovative paper. Probably one of the seminal
	papers for the field. Moves on from configuration of component systems
	to look at dynamic reconfiguration of these, using "configuration
	changes" which express the difference between the past architecture
	and the future one. Describes approaches where part of the system
	may be dynamically reconfigured during runtime, and strategies involved.
	Develops the notion of lifecycle state and the use of this in a reconfiguration
	approach.
	
	2005-10-17},
  comments = {Times Cited: 44 Article English KRAMER, J UNIV LONDON,IMPERIAL COLL
	SCI TECHNOL,DEPT COMP,180 QUEENS GATE,LONDON SW7 2BZ,ENGLAND Cited
	References Count: 21
	
	
	A very clear and amazingly innovative paper. Probably one of the seminal
	papers for the field. Moves on from configuration of component systems
	to look at dynamic reconfiguration of these, using "configuration
	changes" which express the difference between the past architecture
	and the future one. Describes approaches where part of the system
	may be dynamically reconfigured during runtime, and strategies involved.
	Develops the notion of lifecycle state and the use of this in a reconfiguration
	approach.
	
	2005-10-17},
  issn = {0098-5589},
  owner = {amcveigh},
  refid = {26},
  timestamp = {2006.03.14},
  url = {ISI:A1990ED91000007}
}

@INCOLLECTION{Kramer1995,
  author = {Kramer, Jeff and Magee, Jeff and Eisenbach, Susan},
  title = {Modelling Darwin in pi-Calculus},
  booktitle = {Theory and Practice in Distributed Systems},
  publisher = {Springer-Verlag},
  year = {1995},
  series = {Lecture Notes in Computer Science},
  pages = {133--152},
  month = {July},
  abstract = {DARWIN is a configuration language for distributed
	
	and parallel programs, providing a hierarchical structure
	
	of components with dynamic binding. In order to
	
	specify precisely the behaviour of DARWIN programs,
	
	we sketch a translation of the features of the language
	
	into the pi-calculus, a formalism for modelling concurrent
	
	processes. The match between underlying models
	
	for DARWIN and pi-calculus is good. Examples done
	
	in the calculus are clean abstractions of the same solutions
	
	in other concurrent languages.},
  url = {http://pubs.doc.ic.ac.uk/darwin-in-pi-calculus/}
}

@INPROCEEDINGS{Kramer1989,
  author = {Kramer, J. and Magee, J. and Sloman, M.},
  title = {Configuration Support for System Description, Construction and Evolution},
  booktitle = {Proceedings of the 5th International Workshop on Software Specification
	and Design},
  year = {1989},
  pages = {28--33},
  address = {Pittsburgh, Pennsylvania, United States},
  publisher = {ACM Press},
  comment = {Defines configuration programming. Specifically mentions the need
	to be able to evolve the system at runtime, using change specifications.
	Uses CONIC (ADL + superset of Pascal) for examples. Interesting that
	it specifically creates an implementation language for implementing
	the components. Work is way ahead of its time, in a historical sense.
	Preceeds much of the OO era, yet is in many ways more advanced...
	
	2005-10-23},
  issn = {0-89791-305-1},
  keywords = {configuration, SPECIFICATION},
  owner = {amcveigh},
  refid = {30},
  timestamp = {2006.03.14},
  url = {http://doi.acm.org/10.1145/75199.75204}
}

@INBOOK{Kramer2000,
  chapter = {2. Software Architecture Description},
  pages = {31-65},
  title = {Software Architecture for Product Families: Principles and Practice},
  publisher = {Addison Wesley},
  year = {2000},
  editor = {Jazayeri, M. and Ran, A. and van der Linde, F.},
  author = {Kramer, K. and Magee, J. and Keng N. and Dulay, N.},
  owner = {amcveigh},
  timestamp = {2006.05.30}
}

@INPROCEEDINGS{Krishnamurthi1998,
  author = {Shriram Krishnamurthi and Matthias Felleisen},
  title = {Toward a Formal Theory of Extensible Software},
  booktitle = {In SIGSOFT '98/FSE-6: Proceedings of the 6th ACM SIGSOFT International
	Symposium on Foundations of Software Engineering},
  year = {1998},
  pages = {88--98},
  publisher = {ACM Press},
  abstract = {As software projects continue to grow in scale and scope, it becomes
	important to reuse software. An important kind of reuse is extensibility,
	i.e., the extension of software without accessing existing code to
	edit or copy it. In this paper, we propose a rigorous, semantics-based
	definition of software extensibility. Then we illustrate the utility
	of our definitions by applying them to several programs. The examination
	shows how programming style affects extensibility and also drives
	the creation of a variant of an existing design pattern. We consider
	programs in both object-oriented and functional languages to prove
	the robustness of our definitions},
  owner = {andrew},
  review = {Excellent definition of "extensible" in this paper:
	
	
	"extensibility: the extension of software without accessing existing
	code to edit or copy it".},
  timestamp = {2009.03.18}
}

@ARTICLE{Krueger2006,
  author = {Krueger, Charles W.},
  title = {New methods in Software Product Line Practice},
  journal = {Communications of the ACM},
  year = {2006},
  volume = {49},
  pages = {37--40},
  number = {12},
  abstract = {Examining the benefits of next-generation SPL methods.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1183236.1183262},
  issn = {0001-0782},
  owner = {andrew},
  publisher = {ACM},
  review = {nice definition of sorftware product lines.},
  timestamp = {2009.06.24}
}

@INCOLLECTION{Kulesza2006,
  author = {Kulesza, Uir\'{a} and Alves, Vander and Garcia, Alessandro and de
	Lucena, Carlos and Borba, Paulo},
  title = {Improving Extensibility of Object-Oriented Frameworks with Aspect-Oriented
	Programming},
  booktitle = {Lecture Notes in Computer Science},
  publisher = {Springer},
  year = {2006},
  pages = {231--245},
  abstract = {Object-oriented frameworks are nowadays a common and useful technology
	used in the implementation of software system families. Despite their
	benefits, over the last years many researchers have described the
	inadequacy of object-oriented mechanisms to address the modularization
	and composition of many framework features, thus reducing the extent
	to which a framework can be extended. The crosscutting nature of
	many framework features is identified as one of the main causes of
	these problems. In this paper, we analyze how aspect-oriented programming
	can help to improve the design, implementation, and extension of
	object-oriented frameworks. We propose the concept of Extension Join
	Points (EJPs) as a way of designing and documenting existing crosscutting
	extension points. EJPs improve framework extensibility, including
	superior composability of the framework core functionality with other
	modules or frameworks. Four case studies of frameworks from diverse
	domains are presented to illustrate our proposal. This paper also
	discusses lessons learned on the application of our approach to the
	development and extension of these frameworks.},
  citeulike-article-id = {3743794},
  doi = {10.1007/11763864\_17},
  journal = {Reuse of Off-the-Shelf Components},
  keywords = {aspectoriented, softwareengineering},
  owner = {andrew},
  posted-at = {2008-12-03 19:08:57},
  priority = {2},
  timestamp = {2009.03.31},
  url = {http://dx.doi.org/10.1007/11763864\_17}
}

@INPROCEEDINGS{Lai2000,
  author = {Lai, A. and Murphy, G. and Walker, R.},
  title = {Separating Concerns with Hyper/J: An Experience Report},
  booktitle = {Multi-Dimensional Separation of Concerns in Software
	
	Engineering},
  year = {2000},
  pages = {79--91},
  owner = {andrew},
  timestamp = {2009.03.31},
  url = {http://pages.cpsc.ucalgary.ca/~rwalker/publications/lai2000a.pdf}
}

@INPROCEEDINGS{Lau2006,
  author = {Kung-Kiu Lau and Ling Ling and Zheng Wang},
  title = {Composing Components in Design Phase using Exogenous Connectors},
  booktitle = {EUROMICRO '06: Proceedings of the 32nd EUROMICRO Conference on Software
	Engineering and Advanced Applications},
  year = {2006},
  pages = {12--19},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  abstract = {Composition can take place during different stages of component life
	cycle. We identify two main stages : design phase - components are
	composed into composite components for reuse; deployment phase -
	components are compiled and the resulting binaries are assembled
	into executable systems. Ideally, the design phase composition should
	maximise component reuse. However, this ideal is not realised in
	current component-based development because they can not reuse composite
	components in design phase. In this paper, we propose a novel approach
	for composing components in design phase using exogenous connectors.
	In contrast to existing composition approaches, our approach allows
	composite components built in design phase to be further reusable
	in both design and deployment phases so as to achieve both component
	reuse and design flexibility. We demonstrate the feasibility of our
	approach in an industrial-strength case study - Automatic Train Protection
	system, and compare them with the closely-related existing composition
	approaches.},
  doi = {http://dx.doi.org/10.1109/EUROMICRO.2006.30},
  isbn = {0-7695-2594-6},
  review = {this is a very odd paper, but these guys are quite well published.
	an exogeneous connector is one that is not owned explicitly by a
	component -- it is "out of the family". In essence they propose putting
	all login in connectors and removing it from components. components
	can then only provide itnerfaces! connectors end up taking on most
	of the qualities of components, with no real benefit as far as I
	can see.
	
	
	also -- seems to confuse the concept of component types and component
	instances. very poor...},
  timestamp = {2007.01.23}
}

@INPROCEEDINGS{Lehman1976,
  author = {Lehman, M.M. and Parr, .F.N.},
  title = {Program Evolution and its Impact on Software Engineering},
  booktitle = {Proceedings of the 2nd International Conference on Software Engineering},
  year = {1976},
  pages = {350--357},
  address = {San Francisco, California, United States},
  publisher = {IEEE Computer Society Press},
  comment = {Looks at the forces of evolution on programs, and produces some metrics.
	Just skimmed.
	
	2005-10-11},
  owner = {amcveigh},
  refid = {2},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=807698&coll=GUIDE&dl=GUIDE&CFID=57996419&CFTOKEN=31358059#}
}

@BOOK{Lehrmann1993,
  title = {Object-Oriented Programming in the Beta Programming Language},
  publisher = {Association for Computing Machinery},
  year = {1993},
  author = {Lehrmann Madsen, Ole and Moller-Pedersen, Birger and Nygaard, Kristen},
  owner = {amcveigh},
  timestamp = {2007.07.10}
}

@TECHREPORT{Leicher2004,
  author = {Andreas Leicher},
  title = {A Framework for Identifying Compositional Conflicts in Component-Based
	Systems},
  institution = {Computation and Information Structures, Technical University of Berline},
  year = {2004},
  owner = {amcveigh},
  timestamp = {2007.07.10}
}

@INPROCEEDINGS{Li2008,
  author = {Li, Peng and Wohlstadter, Eric},
  title = {View-Based Maintenance of Graphical User Interfaces},
  booktitle = {AOSD '08: Proceedings of the 7th International Conference on Aspect-Oriented
	Software Development},
  year = {2008},
  pages = {156--167},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/1353482.1353501},
  isbn = {978-1-60558-044-9},
  location = {Brussels, Belgium},
  owner = {andrew},
  timestamp = {2009.06.29}
}

@INPROCEEDINGS{Magee1995,
  author = {J. Magee and N. Dulay and S. Eisenbach and J. Kramer},
  title = {Specifying Distributed Software Architectures},
  booktitle = {Proceedings of the 5th European Software Engineering Conference},
  year = {1995},
  editor = {W. Schafer and P. Botella},
  volume = {989},
  pages = {137--153},
  address = {Sitges, Spain},
  publisher = {Springer-Verlag, Berlin},
  abstract = {There is a real need for clear and sound design specica-
	
	tions of distributed systems at the architectural level. This is the
	level
	
	of the design which deals with the high-level organisation of computa-
	
	tional elements and the interactions between those elements. The paper
	
	presents the Darwin notation for specifying this high-level organisation.
	
	Darwin is in essence a declarative binding language which can be used
	to
	
	dene hierarchic compositions of interconnected components. Distribu-
	
	tion is dealt with orthogonally to system structuring. The language
	sup-
	
	ports the specication of both static structures and dynamic structures
	
	which may evolve during execution. The central abstractions managed
	
	by Darwin are components and services. Services are the means by which
	
	components interact.
	
	In addition to its use in specifying the architecture of a distributed
	sys-
	
	tem, Darwin has an operational semantics for the elaboration of speci-
	
	cations such that they may be used at runtime to direct the construction
	
	of the desired system. The paper describes the operational semantics
	of
	
	Darwin in terms of the -calculus, Milner's calculus of mobile processes.
	
	The correspondence between the treatment of names in the -calculus
	
	and the management of services in Darwin leads to an elegant and con-
	
	cise -calculus model of Darwin's operational semantics. The model
	is
	
	used to argue the correctness of the Darwin elaboration process. The
	
	overall objective is to provide a soundly based notation for specifying
	
	and constructing distributed software architectures.},
  review = {The best paper (original?) on Darwin with full details of the semantics
	via a translation to pi-calculus also.},
  url = {citeseer.ist.psu.edu/article/magee95specifying.html}
}

@ARTICLE{Magee1994,
  author = {Jeff Magee and Naranker Dulay and Jeff Kramer},
  title = {Regis: A Constructive Development Environment for Distributed Programs},
  journal = {Distributed Systems Engineering Journal},
  year = {1994},
  volume = {1},
  pages = {304--312},
  owner = {andrew},
  review = {Better paper than the SysMan one, but doesn't explain bindings in
	huge detail. The SysMan one does.},
  timestamp = {2009.04.15}
}

@BOOK{Magee1999,
  title = {Concurrency (State Models and Java Programs)},
  publisher = {John Wiley and Sons Ltd},
  year = {2006},
  author = {Magee, J. and Kramer, J.},
  pages = {-},
  edition = {2nd},
  comment = {The seminal text on FSP and applying hierarchical techniques to practical
	architectures.},
  issn = {0 471 98710 7},
  keywords = {concurrency, FSP, state},
  owner = {amcveigh},
  refid = {78},
  timestamp = {2006.03.14}
}

@INPROCEEDINGS{Magee1996,
  author = {Magee, J. and Kramer, J.},
  title = {Dynamic Structure in Software Architectures},
  booktitle = {Proceedings of the 4th ACM SIGSOFT Symposium on Foundations of Software
	Engineering},
  year = {1996},
  pages = {3--14},
  address = {San Francisco, California, United States},
  publisher = {ACM Press},
  comment = {239104
	
	http://doi.acm.org/10.1145/239098.239104},
  issn = {0-89791-797-9},
  keywords = {software architecture},
  owner = {amcveigh},
  refid = {58},
  timestamp = {2006.03.14}
}

@INBOOK{Martin2000,
  chapter = {The Open-Closed principle},
  pages = {97--112},
  title = {More C++ Gems},
  publisher = {Cambridge University Press},
  year = {2000},
  author = {Martin,, Robert C.},
  address = {New York, NY, USA},
  book = {More C++ gems},
  isbn = {0-521-78618-5},
  owner = {andrew},
  timestamp = {2009.03.31}
}

@INPROCEEDINGS{Mattsson1997,
  author = {Mattsson, M. and Bosch, J.},
  title = {Framework Composition: Problems, Causes and Solutions},
  booktitle = {Proceedings of the Tools-23: Technology of Object-Oriented Languages
	and Systems},
  year = {1997},
  pages = {203--},
  publisher = {IEEE Computer Society},
  comment = {832661},
  issn = {0-8186-8383-X},
  keywords = {SYSTEMS},
  owner = {amcveigh},
  refid = {62},
  timestamp = {2006.03.14}
}

@INPROCEEDINGS{Mayer2003,
  author = {Johannes Mayer and Ingo Melzer and Franz Schweiggert},
  title = {Lightweight Plug-In-Based Application Development},
  booktitle = {NODe '02: Revised Papers from the International Conference NetObjectDays
	on Objects, Components, Architectures, Services, and Applications
	for a Networked World},
  year = {2003},
  pages = {87--102},
  address = {London, UK},
  publisher = {Springer-Verlag},
  isbn = {3-540-00737-7},
  review = {nice paper on a plug-in pattern. very simple class diagram, nice mapping
	onto eclipse.}
}

@INBOOK{McIlroy1968,
  title = {Mass Produced Software Components: NATO Science Committee Report},
  publisher = {NATO},
  year = {1968},
  editor = {P. Naur and B. Randell},
  author = {McIlroy, M.D.},
  booktitle = {NATO Science Committee Report},
  journal = {NATO Science Committee Report},
  owner = {amcveigh},
  timestamp = {2006.05.30}
}

@MISC{McVeigh2008,
  author = {Andrew McVeigh},
  title = {{The Rich Engineering Heritage Behind Dependency Injection}},
  howpublished = {http://www.javalobby.org/articles/di-heritage},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.04.01},
  url = {http://www.javalobby.org/articles/di-heritage}
}

@INPROCEEDINGS{McVeigh2006,
  author = {McVeigh, A. and Magee, J. and Kramer, J.},
  title = {Using Resemblance to Support Component Reuse and Evolution},
  booktitle = {Specification and Verification of Component Based Systems Workshop},
  year = {2006},
  owner = {andrew},
  timestamp = {2006.10.04}
}

@PHDTHESIS{Medvidovic1999a,
  author = {Medvidovic,, Nenad},
  title = {Architecture-Based Specification-Time Software Evolution},
  school = {University of California, Irvine},
  year = {1999},
  note = {Taylor, Richard N.},
  isbn = {0-599-10342-6},
  order_no = {AAI9912025},
  publisher = {University of California, Irvine}
}

@INPROCEEDINGS{Medvidovic1996,
  author = {Medvidovic, N.},
  title = {ADLs and Dynamic Architecture Changes},
  booktitle = {Joint Proceedings of the Second international Software Architecture
	Workshop (ISAW-2) and International Workshop on Multiple Perspectives
	in Software Development (Viewpoints '96)},
  year = {1996},
  pages = {24--27},
  address = {San Francisco, California, United States},
  publisher = {ACM Press},
  comment = {A paper discussion dynamic evolution of ADLs at runtime. Seems to
	focus on evolution rather than runtime instantiation of components.
	Motivation is upgrades, addition of new components etc.
	
	2005-10-23},
  issn = {0-89791-867-3},
  keywords = {software architecture},
  owner = {amcveigh},
  refid = {31},
  timestamp = {2006.03.14},
  url = {http://doi.acm.org/10.1145/243327.243340}
}

@INPROCEEDINGS{Medvidovic1996a,
  author = {Medvidovic, N. and Oreizy, P. and Robbins, J.E. and Taylor, R.N.},
  title = {Using Object-Oriented Typing to Support Architectural Design in the
	C2 Style},
  booktitle = {Proceedings of the 4th ACM SIGSOFT Symposium on Foundations of Software
	Engineering},
  year = {1996},
  pages = {24--32},
  address = {San Francisco, California, United States},
  publisher = {ACM Press},
  abstract = {Software architectures enable large-scale software development. Component
	reuse and substitutability, two key aspects of large-scale development,
	must be planned for during software design. Object-oriented (OO)
	type theory supports reuse by structuring inter-component relationships
	and verifying those relationships through type checking in an architecture
	definition language (ADL). In this paper, we identify the issues
	and discuss the ramifications of applying OO type theory to the C2
	architectural style. This work stems from a series of experiments
	that were conducted to investigate component reuse and substitutability
	in C2. We also discuss the limits of applicability of OO typing to
	C2 and how we addressed them in the C2 ADL.},
  comment = {This is a really good paper, which introduces the idea of placeholder
	components in an architecture. These are components which are only
	there to show the space and properties that a concrete extension
	component must provide.
	
	2005-11-15},
  issn = {0-89791-797-9},
  keywords = {software architecture, component, definition},
  owner = {amcveigh},
  refid = {48},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=239106&coll=Portal&dl=GUIDE&CFID=60884982&CFTOKEN=64386172#}
}

@INPROCEEDINGS{Medvidovic1999,
  author = {Medvidovic, N. and Rosenblum, D.S. and Taylor, R.N.},
  title = {A Language and Environment for Architecture-Based Software Development
	and Evolution},
  booktitle = {ICSE '99: Proceedings of the 21st International Conference on Software
	Engineering},
  year = {1999},
  pages = {44--53},
  address = {Los Alamitos, CA, USA},
  publisher = {IEEE Computer Society Press},
  isbn = {1-58113-074-0},
  location = {Los Angeles, California, United States}
}

@ARTICLE{Medvidovic2000,
  author = {Medvidovic, N. and Taylor, R.N.},
  title = {A Classification and Comparison Framework for Software Architecture
	Description Languages},
  journal = {IEEE Transactions on Software Engineering},
  year = {2000},
  volume = {26},
  pages = {70--93},
  number = {1},
  month = jan,
  abstract = {Software architectures shift the focus of developers from lines-of-code
	to coarser-grained architectural elements and their overall interconnection
	structure. Architecture description languages (ADLs) have been proposed
	as modeling notations to support architecture-based development.
	There is, however, little consensus in the research community on
	what is an ADL, what aspects of an architecture should be modeled
	in an ADL, and which of several possible ADLs is best suited for
	a particular problem. Furthermore, the distinction is rarely made
	between ADLs on one hand and formal specification, module interconnection,
	simulation, and programming languages on the other. This paper attempts
	to provide an answer to these questions. It motivates and presents
	a definition and a classification framework for ADLs. The utility
	of the definition is demonstrated by using it to differentiate ADLs
	from other modeling notations. The framework is used to classify
	and compare several existing ADLs, enabling us, in the process, to
	identify key properties of ADLs. The comparison highlights areas
	where existing ADLs provide extensive support and those in which
	they are deficient, suggesting a research agenda for the future},
  address = {Univ So Calif, Dept Comp Sci, Los Angeles, CA 90007 USA Univ Calif
	Irvine, Dept Informat \& Comp Sci, Irvine, CA 92697 USA},
  comment = {Times Cited: 72 Article English Medvidovic, N Univ So Calif, Dept
	Comp Sci, Los Angeles, CA 90007 USA Cited References Count: 74
	
	Read this before starting phd. It looks at the underlying concepts
	of ADLs and distills a feature graph that ADLs map onto. Interesting
	features are "implementation generation" and "evolution". Not entirely
	sure if evolution represents run-time or design-time (pretty sure
	it is design-time). Then maps a number of existing ADLs onto the
	feature set (including Darwin). Of interest in table 2 is the fact
	that evolution is particularly poorly supported. This area is ripe
	for doing work on... Strangely, they haven't seemed to have picked
	up on the Jeffs work on structural evolution for ADLs. Maybe this
	didn't form part of Darwin?
	
	2004-01-01},
  issn = {0098-5589},
  keywords = {architecture description language, CALCULUS, classification, comparison,
	component, configuration, connector, definition, MOBILE PROCESSES,
	software architecture, SPECIFICATION, SYSTEMS},
  owner = {amcveigh},
  refid = {25},
  timestamp = {2006.03.14},
  url = {ISI:000085891100005}
}

@INPROCEEDINGS{mehta02evolving,
  author = {A. Mehta and G. Heineman},
  title = {Evolving Legacy System Features into Fine-Grained Components},
  booktitle = {24th International Conference on Software Engineering},
  year = {2002},
  abstract = {There is a constant need for practical, efficient, and cost-effective
	software evolution techniques. We propose a novel evolution methodology
	that integrates the concepts of features, regression tests, and component-based
	software engineering (CBSE). Regression test cases are untapped resources,
	full of information about system features. By exercising each feature
	with its associated test cases using code profilers and similar tools,
	code can be located and refactored to create components. These components
	are then inserted back into the legacy system, ensuring a working
	system structure. This methodology is divided into three parts. Part
	one identifies the source code associated with features that need
	evolution. Part two deals with creating components and part three
	measures results. By applying this methodology, AFS has successfully
	restructured its enterprise legacy system and reduced the costs of
	future maintenance. Additionally, the components that were refactored
	from the legacy system are currently being used within a web-enabled
	application.},
  review = {this is simplistive -- concerned mainly with evolving legacy systems.
	read 5 pages -- no real mean, no real intersection with my work.},
  text = {A. Mehta and G. T. Heineman. Evolving legacy system features into
	fine-grained components. In Proceedings of the 24th International
	Conference on Software Engineering, pages 417--427. ACM Press, 2002.},
  timestamp = {2006.03.20},
  url = {citeseer.ist.psu.edu/mehta02evolving.html}
}

@ARTICLE{Meijer2002,
  author = {Meijer, E. and Szyperski, C.},
  title = {Overcoming Independent Extensibility Challenges},
  journal = {Communications of the ACM},
  year = {2002},
  volume = {45},
  pages = {41--44},
  number = {10},
  abstract = {As Huxley observed, it isn't always clear what a name is supposed
	to stand for. In this article we go beyond prosaic observations and
	analyze aspects of the challenge posed by requirements of independent
	extensibility. Independent extensibility amounts to the use of software
	components beyond source sharing. Examples of independent extensibility
	include operating systems supporting independently developed applications,
	as well as applications supporting independently developed plug-ins.
	As a consequence of independent extensibility, we must to deal with
	multiple versions of components, which is a difficult problem. Relating
	back to the development and deployment process, we show how name
	resolution issues are often at the heart of this problem.},
  comment = {Not particularly insightful or useful. Looks at need for versioning
	and proposes side-by-side running of different versions except in
	cases where this represents a unique external resource.
	
	2005-12-05},
  issn = {0001-0782},
  keywords = {component, SYSTEMS},
  owner = {amcveigh},
  publisher = {ACM Press},
  refid = {74},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=570929#}
}

@ARTICLE{Mencl2004,
  author = {Vladimir Mencl},
  title = {Specifying Component Behavior with Port State Machines},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2004},
  volume = {101C},
  pages = {129-153},
  note = {Special issue: Proceedings of the Workshop on the Compositional Verification
	of UML Models CVUML Edited by F. de Boer and M. Bonsangue},
  abstract = {Protocol State Machines (PSM) in UML 2.0 [13] describe valid sequences
	of operation
	
	calls. To support modeling components, UML 2.0 introduces a Port associated
	
	with a set of provided and required interfaces. Unfortunately, a PSM
	is applicable
	
	only to a single interface, either a provided or required one; moreover,
	nested
	
	calls cannot be modeled with a PSM. Furthermore, the definition of
	protocol conformance
	
	is rather fuzzy and reasoning on this relation is not possible in
	general;
	
	thus reasoning on consistency in component composition is not possible
	with PSMs.
	
	Behavior Protocols [17] capture the behavior of a component via a
	set of traces.
	
	A textual notation similar to regular expressions is provided to approximate
	the
	
	behavior with a regular language. In [1,17], the compliance relation
	and consent
	
	operator are defined to reason on consistency of component composition;
	a verifier
	
	tool [18] is available for the compliance relation.
	
	In this paper, we propose the Port State Machine (PoSM) to model the
	communication
	
	on a Port. Building on our experience with behavior protocols, we
	model
	
	an operation call as two atomic events request and response, permitting
	PoSM to
	
	capture the interleaving and nesting of operation calls on provided
	and required
	
	interfaces of the Port. The trace semantics of PoSM yields a regular
	language. We
	
	apply the compliance relation of behavior protocols to PoSMs, allowing
	us to reason
	
	on behavior compliance of components in software architectures; the
	existing
	
	verifier tool can be applied to PoSMs.},
  review = {very strong on UML2.
	
	
	uses a simplified form of UML23 state machines (no actions of guards).
	defines a mapping to behaviour protocols.
	
	
	Q? how does composition work, concurrency etc. why can't guards be
	used?
	
	
	what decided the choice points.
	
	
	this led to my idea of decomposing the behaviour as a set of nested
	componnets resembling a state diagram.},
  url = {citeseer.ist.psu.edu/article/mencl04specifying.html}
}

@ARTICLE{Mens2005,
  author = {Tom Mens and Gabriele Taentzer and Olga Runge},
  title = {Detecting Structural Refactoring Conflicts Using Critical Pair Analysis},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2005},
  volume = {127},
  pages = {113-128},
  number = {3},
  month = {April},
  abstract = {Refactorings are program transformations that improve the software
	structure while preserving the external behaviour. In spite of this
	very useful property, refactorings can still give rise to structural
	conflicts when parallel evolutions to the same software are made
	by different developers. This paper explores this problem of structural
	evolution conflicts in a formal way by using graph transformation
	and critical pair analysis. Based on experiments carried out in the
	graph transformation tool AGG, we show how this formalism can be
	exploited to detect and resolve refactoring conflicts.},
  booktitle = {Proceedings of the Workshop on software evolution through transformations:
	model-based versus implementation-level solutions},
  editor = {Reiko Heckel and Tom Mens},
  publisher = {Elsevier Science},
  review = {uses graph rewriting on attributed graphs to analyse a set of refactorings.
	has an oo metamodel. then uses "critical pair" analysis to see how
	independent refactorings conflict over time for parallel development.
	
	
	a bit simplistic -- only considers one parallel change, combined with
	one other parallel change. not particularly practical.},
  timestamp = {2006.08.07}
}

@ARTICLE{Mernik2005,
  author = {Mernik, Marjan and Heering, Jan and Sloane, Anthony M.},
  title = {When and How to Develop Domain-Specific Languages},
  journal = {ACM Computing Survey},
  year = {2005},
  volume = {37},
  pages = {316--344},
  number = {4},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1118890.1118892},
  issn = {0360-0300},
  owner = {andrew},
  publisher = {ACM},
  timestamp = {2009.06.14}
}

@BOOK{Meyer1997,
  title = {Object-Oriented Software Construction},
  publisher = {Prentice-Hall, Inc.},
  year = {1997},
  editor = {Second edition},
  author = {Meyer,, Bertrand},
  address = {Upper Saddle River, NJ, USA},
  isbn = {0-13-629155-4},
  owner = {andrew},
  timestamp = {2009.03.31}
}

@ARTICLE{mezini97dynamic,
  author = {Mira Mezini},
  title = {Dynamic Object Evolution without Name Collisions},
  journal = {Lecture Notes in Computer Science},
  year = {1997},
  volume = {1241},
  pages = {190--219},
  review = {places a layer b/w an object (and its identity) and the bits that
	implement the behaviour. the combiner keeps track of the scope and
	methods (figure 4) to select a sub-object based on context.
	
	
	this seemed to me to be badly written, with complex descriptions.
	it describes a system with no real examples.},
  timestamp = {2005.12.05},
  url = {citeseer.ist.psu.edu/mezini97dynamic.html}
}

@MISC{Microsoft2006,
  author = {Microsoft},
  title = {{COM: Component Object Model Technologies}},
  howpublished = {http://www.microsoft.com/com/default.mspx},
  year = {last accessed August 2009},
  journal = {Website},
  owner = {amcveigh},
  review = {COM model from the horse's mouth...},
  timestamp = {2006.05.15},
  url = {http://www.microsoft.com/com/default.mspx},
  volume = {http://www.microsoft.com/com/default.mspx}
}

@MISC{Microsoft2006a,
  author = {Microsoft},
  title = {{Microsoft Office Online: Excel 2003 Home Page}},
  howpublished = {http://office.microsoft.com/en-gb/FX010858001033.aspx},
  year = {last accessed August 2009},
  journal = {Website},
  owner = {amcveigh},
  review = {Eclipse plugin site, showing thousands of plugins.},
  timestamp = {2006.05.15},
  url = {http://office.microsoft.com/en-gb/FX010858001033.aspx},
  volume = {http://office.microsoft.com/en-gb/FX010858001033.aspx}
}

@MISC{Microsoft,
  author = {{Microsoft .Net Framework Development Center}},
  title = {{.Net Assemblies}},
  howpublished = {http://msdn.microsoft.com/en-us/library/hk5f40ct%28VS.71%29.aspx},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.07.28},
  url = {http://msdn.microsoft.com/en-us/library/hk5f40ct%28VS.71%29.aspx}
}

@INPROCEEDINGS{Milewski1997,
  author = {Bartosz Milewski},
  title = {Distributed Source Control System},
  booktitle = {ICSE '97: Proceedings of the SCM-7 Workshop on System Configuration
	Management},
  year = {1997},
  pages = {98--107},
  address = {London, UK},
  publisher = {Springer-Verlag},
  isbn = {3-540-63014-7},
  review = {decent paper with nice diagrams on distributed source code control.
	i think this is the first example I've found of something that is
	open (i.e. not peer to peer)}
}

@BOOK{Milner1999,
  title = {Communicating and Mobile Systems: the pi-Calculus},
  publisher = {Cambridge University Press},
  year = {1999},
  author = {Robin Milner},
  owner = {andrew},
  timestamp = {2009.04.06}
}

@ARTICLE{Minsky2000,
  author = {Minsky, N.H. and Ungureanu, V.},
  title = {Law-Governed Interaction: A Coordination and Control Mechanism for
	Heterogeneous Distributed Systems},
  journal = {ACM Trans.Softw.Eng.Methodol.},
  year = {2000},
  volume = {9},
  pages = {273--305},
  number = {3},
  abstract = {Software technology is undergoing a transition from monolithic systems,
	constructed according to a single overall design, into conglomerates
	of semiautonomous, heterogeneous, and independently designed subsystems,
	constructed and managed by different organizations, with little,
	if any, knowledge of each other. Among the problems inherent in such
	conglomerates, none is more serious than the difficulty to control
	the activities of the disparate agents operating in it, and the
	difficulty for such agents to coordinate their activities with
	each other. We argue that the nature of coordination and control
	required for such systems calls for the following principles to be
	satisfied: (1) coordination policies need to be enforced; (2) the
	enforcement needs to be decentralized; and (3) coordination policies
	need to be formulated explicitly-rather than being implicit in the
	code of the agents involved-and they should be enforced by means
	of a generic, broad spectrum mechanism; and (4) it should be possible
	to deploy and enforce a policy incrementally, without exacting any
	cost from agents and activities not subject to it. We describe a
	mechanism called law-governed interaction (LGI), currently implemented
	by the Moses toolkit, which has been designed to satisfy these principles.
	We show that LGI is at least as general as a conventional centralized
	coordination mechanism (CCM), and that it is more scalable, and generally
	more efficient, than CCM.},
  comment = {Defines a system called LGI which allows for centralised coordination
	and control activities to be decentralised. This allows for more
	efficient and scalable implementation. The system protects itself
	as it doesn't always require the voluntary participation of agents
	in order to establish and enforce its policies.
	
	2005-10-26},
  issn = {1049-331X},
  keywords = {SYSTEMS},
  owner = {amcveigh},
  publisher = {ACM Press},
  refid = {38},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=352592&coll=GUIDE&dl=GUIDE&CFID=58678673&CFTOKEN=85896761#}
}

@MISC{Corporation2006,
  author = {{Mozilla Corporation}},
  title = {{Firefox Internet Browser}},
  howpublished = {http://www.mozilla.com},
  year = {last accessed August 2009},
  journal = {Website},
  owner = {andrew},
  review = {decent explanation of the main focus of the eclipse platform, including
	plugin architecture.},
  timestamp = {2008.04.01},
  url = {http://www.mozilla.com},
  volume = {http://www.mozilla.com}
}

@MISC{Fireextensions2007,
  author = {{Mozilla Developer Center}},
  title = {{Firefox Extensions}},
  howpublished = {http://developer.mozilla.org/en/docs/Extensions},
  year = {last accessed August 2009},
  owner = {amcveigh},
  timestamp = {2007.06.25},
  url = {http://developer.mozilla.org/en/docs/Extensions},
  volume = {http://developer.mozilla.org/en/docs/Extensions}
}

@MISC{Firefoxplugins2008,
  author = {{Mozilla Developer Center}},
  title = {{Firefox Plugins}},
  howpublished = {http://developer.mozilla.org/en/docs/\\\-Plugins},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2008.04.01},
  url = {http://developer.mozilla.org/en/docs/Plugins},
  volume = {http://developer.mozilla.org/en/docs/Plugins}
}

@PHDTHESIS{Nelson2003,
  author = {Nelson,, Torsten Paul},
  title = {Formal Verification of Projection-Based Software Systems},
  school = {University of Waterloo, Ontario, Canada},
  year = {2003},
  abstract = {Recent implementation languages such as AspectJ and HyperJ allow systems
	to be decomposed into declaratively complete units. These units are
	projections of the system, which are partial implementations of the
	entire system where each program element such as a data structure
	or procedure may be partially defined in more than one projection.
	In contrast, traditional languages rely on units that are partitions,
	which are complete implementations of part of the system: every program
	element is defined in only one part. Projection-based approaches
	offer low coupling between units leading to programs that may be
	easier to maintain and extend.
	
	
	These implementation languages for projection-based systems offer
	facilities for composing projections to form a complete software
	package. This composition usually yields a number of complex interactions
	between the projections. Some of these interactions may manifest
	themselves as inconsistencies such as undesired interference among
	projections. Formal verification is an effective mechanism for detecting
	inconsistencies. However, existing formal specification languages
	do not provide the means to express the interactions between projections
	in a clear and concise fashion.
	
	
	Existing projection-based implementation languages perform composition
	using a similar set of basic constructs. The goal of this work is
	to find representation of projection composition and an approach
	to formal verification of projection-based systems. In order to accomplish
	this goal, a formal model of the composition mechanisms used in projection-based
	languages was developed. This model serves as the semantic basis
	for C3, a language for formally specifying the composition of projections.
	An analyst who decomposes a formal specification into projections
	can compose these projections using C3. A C3 description is easily
	translated to an implementation in a projection-based language. The
	original projections and the composed specifications can be verified
	for desired properties. The C3 language and verification approach
	are demonstrated through two case studies, one using the Alloy language,
	and another using the Finite State Process (FSP) language. The contributions
	of this thesis include: a formal model of the mechanisms for composing
	projections to produce a complete program; C3, a language for specifying
	the composition of projections; and approaches to verifying properties
	of compositions specified using C3, and properties of projections
	written in different formal specification languages. These contributions
	increase the body of knowledge regarding the underlying principles
	of projection-based languages.},
  isbn = {0-612-83013-6},
  order_no = {AAINQ83013},
  owner = {andrew},
  publisher = {University of Waterloo},
  review = {Explains how projection based systems such as hyper/j and aspect/j
	can cause unwanted interference between aspects / slices.},
  timestamp = {2009.03.31}
}

@ARTICLE{Ng1996,
  author = {Ng K., Kramer J, Magee J.},
  title = {A CASE Tool for Software Architecture Design},
  journal = {Automated Software Engineering},
  year = {1996},
  volume = {3},
  pages = {261--284},
  owner = {amcveigh},
  timestamp = {2007.07.09},
  url = {http://www.ingentaconnect.com/content/klu/ause/1996/00000003/F0020003/00111703}
}

@INPROCEEDINGS{Ng1995,
  author = {Keng Ng and J. Kramer and J. Magee and N. Dulay},
  title = {The Software Architect's Assistant-A Visual Environment for Distributed
	Programming},
  booktitle = {HICSS '95: Proceedings of the 28th Hawaii International Conference
	on System Sciences (HICSS'95)},
  year = {1995},
  pages = {254},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  isbn = {0-8186-6935-7}
}

@INPROCEEDINGS{Nierstrasz1993,
  author = {Nierstrasz, O.},
  title = {Regular Types for Acctive Objects},
  booktitle = {Proceedings of the Eighth Annual Conference on Object-Oriented Programming
	Systems, Languages, and Applications},
  year = {1993},
  pages = {1--15},
  address = {Washington, D.C., United States},
  publisher = {ACM Press},
  abstract = {Previous work on type-theoretic foundations for object-oriented programming
	languages has mostly focussed on applying or extending functional
	type theory to functional "objects."This approach, while benefitting
	from a vast body of existing literature, has the disadvantage of
	dealing with state change either in a roundabout way or not at all,
	and completely side-stepping issues of concurrency. In particular,
	dynamic issues of non-uniform service availability and conformance
	to protocols are not addressed by functional types. We propose a
	new type framework that characterizes objects as regular (finite
	state) processes that provide guarantees of service along public
	channels. We also propose an original notion of subtyping for regular
	types that extends Wegner and Zdonik's "principle of substitutability"
	to non-uniform service availability, and we relate it to known process
	equivalences. Finally, we formalize what it means to "satisfy a client's
	expectations," and we show how regular types can be used to tell
	when sequential or concurrent clients are satisfied.},
  comment = {Excellent paper, looking at assigning protocols to objects, and treating
	the protocol as a regular type. Seminal. Regular types are contrasted
	with service types.
	
	2006-03-01},
  issn = {0-89791-587-9},
  keywords = {SYSTEMS},
  owner = {amcveigh},
  refid = {77},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=167976#}
}

@INPROCEEDINGS{Nistor2005,
  author = {Nistor,, Eugen C. and Erenkrantz,, Justin R. and Hendrickson,, Scott
	A. and van der Hoek,, Andr\'{e}},
  title = {ArchEvol: Versioning Architectural-Implementation Relationships},
  booktitle = {SCM '05: Proceedings of the 12th International Workshop on Software
	Configuration Management},
  year = {2005},
  pages = {99--111},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/1109128.1109136},
  isbn = {1-59593-310-7},
  location = {Lisbon, Portugal}
}

@MISC{NoMagic2009,
  author = {{No Magic Inc.}},
  title = {{MagicDraw UML}},
  howpublished = {http://magicdraw.com/},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.06.09},
  url = {http://magicdraw.com/}
}

@ARTICLE{Nystrom2004,
  author = {Nathaniel Nystrom and Stephen Chong and Andrew C. Myers},
  title = {Scalable Extensibility via Nested Inheritance},
  journal = {ACM SIGPLAN Notices},
  year = {2004},
  volume = {39},
  pages = {99--115},
  number = {10},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1035292.1028986},
  issn = {0362-1340},
  publisher = {ACM Press}
}

@BOOK{O'Neill1998,
  title = {JavaBeans from the Ground Up},
  publisher = {Osborne/McGraw-Hill},
  year = {1998},
  author = {Joseph O'Neill},
  owner = {andrew},
  review = {the book kieron gave me on javabeans -- quite good.},
  timestamp = {2009.06.09}
}

@MISC{O'Sullivan2009,
  author = {Byran O'Sullivan},
  title = {{Mercurial: The Definitive Guide}},
  howpublished = {http://hgbook.red-bean.com/read/},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.04.04},
  url = {http://hgbook.red-bean.com/read/}
}

@ARTICLE{O.Gruber2005,
  author = {O.Gruber and B.J.Hargrave and J.McAffer and P.Rapicault and T.Watson},
  title = {The Eclipse 3.0 platform: adopting OSGi technology},
  journal = {IBM Systems Journal},
  year = {2005},
  volume = {44},
  pages = {289--299},
  number = {2},
  comment = {1086616},
  issn = {0018-8670},
  owner = {amcveigh},
  publisher = {IBM Corp.},
  refid = {55},
  timestamp = {2006.03.14}
}

@MISC{OMG2004,
  author = {{Object Management Group}},
  title = {{Catalog of OMG CORBA and IIOP Specifications}},
  howpublished = {http://www.omg.org/technology/documents/corba\_spec\_catalog.htm},
  year = {last accessed August 2009},
  journal = {Website},
  owner = {amcveigh},
  timestamp = {2006.05.15},
  url = {http://www.omg.org/technology/documents/corba_spec_catalog.htm}
}

@MISC{OMG2006,
  author = {{Object Management Group}},
  title = {{Model Driven Architecture}},
  howpublished = {http://www.omg.org/mda/},
  year = {last accessed August 2009},
  journal = {Website},
  owner = {amcveigh},
  review = {Eclipse plugin site, showing thousands of plugins.},
  timestamp = {2006.05.15},
  url = {http://www.omg.org/mda/}
}

@MISC{OMG2006a,
  author = {{Object Management Group}},
  title = {{CORBA Component Model Specification, v4.0}},
  howpublished = {http://www.omg.org/technology/documents/formal/components.htm},
  year = {last accessed August 2009},
  journal = {Website},
  owner = {amcveigh},
  timestamp = {2007.07.09},
  url = {http://www.omg.org/technology/documents/formal/components.htm}
}

@MISC{OMG2007,
  author = {{Object Management Group}},
  title = {{MOF 2.0 / XMI Mapping Specification, v2.1.1}},
  howpublished = {http://www.omg.org/docs/formal/07-12-01.pdf},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.06.09},
  url = {http://www.omg.org/docs/formal/07-12-01.pdf}
}

@MISC{OMGUML,
  author = {{Object Management Group}},
  title = {{UML 2.0 Specification}},
  howpublished = {http://www.omg.org/spec/UML/2.0/},
  year = {last accessed August 2009},
  journal = {Website},
  owner = {amcveigh},
  review = {Eclipse plugin site, showing thousands of plugins.},
  timestamp = {2006.05.15},
  url = {http://www.omg.org/technology/documents/formal/uml.htm}
}

@MISC{Object2001a,
  author = {{Object Technology International Inc.}},
  title = {{Eclipse Platform}},
  howpublished = {http://www.eclipse.org},
  year = {last accessed August 2009},
  journal = {URL},
  owner = {amcveigh},
  review = {decent explanation of the main focus of the eclipse platform, including
	plugin architecture.},
  timestamp = {2006.05.15},
  url = {http://www.eclipse.org},
  volume = {http://www.eclipse.org}
}

@MISC{Object2005,
  author = {{Object Technology International Inc.}},
  title = {{Eclipse Plugin Central}},
  howpublished = {http://www.eclipseplugincentral.com/},
  year = {last accessed August 2009},
  journal = {Website},
  owner = {amcveigh},
  review = {Eclipse plugin site, showing thousands of plugins.},
  timestamp = {2006.05.15},
  url = {http://www.eclipseplugincentral.com/},
  volume = {http://www.eclipseplugincentral.com/}
}

@MISC{Object2001,
  author = {{Object Technology International Inc.}},
  title = {{Eclipse Platform Technical Overview}},
  howpublished = {http://www.eclipse.org/whitepapers/eclipse-overview.pdf},
  year = {last access August 2009},
  journal = {Technical Report},
  owner = {amcveigh},
  review = {decent explanation of the main focus of the eclipse platform, including
	plugin architecture.},
  timestamp = {2006.05.15},
  url = {http://www.eclipse.org/whitepapers/eclipse-overview.pdf},
  volume = {http://www.eclipse.org/whitepapers/eclipse-overview.pdf}
}

@MISC{Stan4J,
  author = {{Odysseus Software GmbH}},
  title = {{STAN: Structural Analysis for Java}},
  howpublished = {http://stan4j.com/},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.07.24},
  url = {http://stan4j.com/}
}

@ARTICLE{Koeth2001,
  author = {Oliver Köth , Mark Minas},
  title = {Abstraction in Graph-Transformation Based Diagram Editors},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2001},
  volume = {50},
  pages = {1-7},
  number = {3},
  abstract = {This extended abstract recalls how visual language editors benefit
	from graph grammars and how the editor-generator DiaGen is based
	on this approach. We then outline how generated editors can create
	abstract diagram representations for further processing, e. g. for
	communication with other tools or for diagram visualizations with
	varying, adjustable detail level which is a valuable aid when editing
	large diagrams. These concepts are illustrated with UML class diagrams.},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  ee = {http://www.elsevier.com/gej-ng/31/29/23/85/29/show/Products/notes/index.htt\#011},
  timestamp = {2006.08.07}
}

@INPROCEEDINGS{Oliver2006,
  author = {Ian Oliver and Vesa Luukala},
  title = {On UML's Composite Structure Diagram},
  booktitle = {Fifth Workshop on System Analysis and Modelling},
  year = {2006},
  address = {Kaiserslautern, Germany},
  abstract = {The composite structure diagram and related notions have
	
	been introduced into UML2.0 to supplement already existing artifacts
	
	such as classes. However the usage of these constructs by engineers
	
	and/or modellers is not always in the spirit of inventors of these
	constructs.
	
	A number of additional interpretations develop which are not
	
	always consistent with the intended usage of the structure nor with
	the
	
	language itself. Understanding these additional usages assists in
	understanding
	
	areas of ambiguity, extension, inconsistency and the future development
	
	of the language.},
  owner = {andrew},
  review = {A really helpful paper explaining in detail about how composite structure
	diagrams translate into class diagrams. Also the 1st paper I have
	seen that describes how UML allows behaviour at the composite level,
	whereas SDL and ROOM do not. In the former case, hidden/private ports
	make complete sense.},
  timestamp = {2008.05.13}
}

@ARTICLE{Ommering2003,
  author = {van Ommering, R.},
  title = {Horizontal Communication: A Style to Compose Control Software},
  journal = {Software - Practice And Experience},
  year = {2003},
  volume = {33},
  pages = {1117--1150},
  number = {12},
  abstract = {Consumer products become more complex and diverse, integrating functions
	that were previously available only in separate products. We believe
	that to build such products efficiently, a compositional approach
	is required. While this is quite feasible in hardware, we would like
	to achieve the same in software, especially in the low-level software
	that drives the hardware. We found this to be possible, but only
	if we let software components communicate horizontally, exchanging
	information along software channels that mirror the hardware signal
	topology. In this paper a concrete protocol implementing this style
	of control is described and many examples are given of its use.},
  comment = {Interesting idea of forming a component signal bus, with protocols,
	to allow components to remain topology-agnostic. i.e. can form a
	bus that properties are published on, and it doesn't matter where
	in the bus a consumer is.
	
	2005-11-03},
  issn = {0038-0644},
  keywords = {component},
  owner = {amcveigh},
  publisher = {John Wiley \& Sons, Inc.},
  refid = {43},
  timestamp = {2006.03.14},
  url = {http://www3.interscience.wiley.com/cgi-bin/abstract/104556449/ABSTRACT}
}

@INPROCEEDINGS{Ommering2002,
  author = {van Ommering, R.},
  title = {Building Product Populations with Software Components},
  booktitle = {ICSE '02: Proceedings of the 24th International Conference on Software
	Engineering},
  year = {2002},
  pages = {255--265},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  abstract = {Two trends have made reuse of embedded software for consumer electronics
	an urgent issue: the software of individual products becomes more
	and more complex, and the market demands a larger variety of products
	at an increasing rate. For that reason, various business groups within
	Philips organize their products as product families. A third trend
	is the integration of functions that until now were only found in
	separate products (e.g. a TV with Dolby Digital sound and a built-in
	DVD player). This requires software reuse between product families,
	which - when organized systematically - leads to a product population
	approach.We have set up such a product population approach, and applied
	it in various business groups within our organization. We use a component
	technology that stimulates context independence, and allows the composition
	of new products out of existing parts. We use an architectural description
	language to explicitly describe the architecture, and also to generate
	efficient bindings. We have aligned our development process and organization
	with the new 'compositional' way of working. This paper outlines
	our approach and reports on our experiences with it.},
  doi = {http://doi.acm.org/10.1145/581339.581373},
  isbn = {1-58113-472-X},
  location = {Orlando, Florida},
  review = {A very nice paper, which outlines how Koala deals with composability
	and variability. In the case of the former, it handles it via Koala
	specs which have documentation and unit tests. In the case of the
	latter, it handles it with parameterisation, and variability interfaces.
	Also, if a component differs from the requirements, then the subcomponents
	are used to build a new component which does support the requirements.
	
	
	Leaves a lot of nice space for BB, in that BB can be used to achieve
	this level of variability. Further, mcveiBB can be used to support
	testing of composite components by removing some of the internals
	and replacing them with mocks.}
}

@INPROCEEDINGS{Ommering2000,
  author = {van Ommering, R.},
  title = {Mechanisms for Handling Diversity in a Product Population},
  booktitle = {ISAW-4: The Fourth International Software Architecture Workshop},
  year = {2000},
  owner = {amcveigh},
  timestamp = {2006.07.19}
}

@INPROCEEDINGS{Oplustil2003,
  author = {Oplustil, T.},
  title = {Inheritance in Architecture Description Languages},
  booktitle = {Proceedings of the Week of Doctoral Students 2003 Conference (WDS
	2003)},
  year = {2003},
  abstract = {This paper explores ways by which inheritance can be defined for and
	used in
	
	specification languages, especially ADLs and CDLs that are now widely
	used in software
	
	engineering for specifying software architectures and components.
	The fact that most
	
	specification languages share many properties with object oriented
	languages � which use
	
	inheritance for variety of purposes � is the main motivation for this
	research. We will analyze
	
	the roles of the inheritance concept in specification languages and
	try to find criteria for
	
	evaluating it. The main focus, however, will be on proposing inheritance
	for the main
	
	abstractions of SOFA CDL � a practically used component definition
	language. An introduction
	
	of inheritance mechanisms for the SOFA CDL interfaces, frames and
	architectures is also the
	
	main results presented in this paper.},
  owner = {amcveigh},
  review = {master's student work.
	
	
	relevant as it includes a description of frame and architecture (insides)
	inheritance. look at concatenation inheritance.
	
	
	includes many relevant statements, particularly about substitutability.},
  timestamp = {2006.06.17}
}

@INPROCEEDINGS{Oreizy1998,
  author = {Oreizy,, Peyman and Medvidovic,, Nenad and Taylor,, Richard N.},
  title = {Architecture-Based Runtime Software Evolution},
  booktitle = {ICSE '98: Proceedings of the 20th International Conference on Software
	Engineering},
  year = {1998},
  pages = {177--186},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  abstract = {Continuous availability is a critical requirement for an
	
	important class of software systems. For these systems,
	
	runtime system evolution can mitigate the costs and risks
	
	associated with shutting down and restarting the system for
	
	an update. We present an architecture-based approach to
	
	runtime software evolution and highlight the role of software
	
	connectors in supporting runtime change. An initial
	
	implementation of a tool suite for supporting the runtime
	
	modification of software architectures, called ArchStudio, is
	
	presented.},
  isbn = {0-8186-8368-6},
  location = {Kyoto, Japan},
  review = {seems to add little to the jeffs work on dynamic architectural change.
	no mention of hierarchy.}
}

@MISC{Alliance2005,
  author = {{OSGi Alliance}},
  title = {{About the OSGi Service Platform}},
  howpublished = {http://www.osgi.org/documents/collateral/OSGiTechnicalWhitePaper.pdf},
  year = {last accessed August 2009},
  journal = {Website},
  owner = {amcveigh},
  review = {Eclipse plugin site, showing thousands of plugins.},
  timestamp = {2006.05.15},
  url = {http://www.osgi.org/documents/collateral/OSGiTechnicalWhitePaper.pdf}
}

@BOOK{OSGi2003,
  title = {OSGi Service Platform},
  publisher = {IOS Press},
  year = {2003},
  author = {{OSGi Alliance}},
  pages = {--},
  issn = {1586033115},
  owner = {amcveigh},
  refid = {56},
  timestamp = {2006.03.14}
}

@ARTICLE{Ossher2001,
  author = {Harold Ossher and Peri Tarr},
  title = {Using Multidimensional Separation of Concerns to (Re)Shape Evolving
	Software},
  journal = {Communications of the ACM},
  year = {2001},
  volume = {44},
  pages = {43--50},
  number = {10},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/383845.383856},
  issn = {0001-0782},
  publisher = {ACM Press}
}

@ARTICLE{Ousterhout1998,
  author = {Ousterhout, J.K.},
  title = {Scripting: Higher-Level Programming for the 21st Century},
  journal = {Computer},
  year = {1998},
  volume = {31},
  pages = {23--30},
  number = {3},
  url = {citeseer.ist.psu.edu/article/ousterhout97scripting.html}
}

@INPROCEEDINGS{Parnas1978,
  author = {Parnas,, David L.},
  title = {Designing Software for Ease of Extension and Contraction},
  booktitle = {ICSE '78: Proceedings of the 3rd International Conference on Software
	Engineering},
  year = {1978},
  pages = {264--277},
  address = {Piscataway, NJ, USA},
  publisher = {IEEE Press},
  isbn = {none},
  location = {Atlanta, Georgia, United States},
  owner = {andrew},
  review = {contains good quotes about simplifying and speeding up system. key
	is the word "contraction".},
  timestamp = {2009.03.31}
}

@ARTICLE{Plasil2002,
  author = {Plasil, F. and Visnovsky, S.},
  title = {Behavior Protocols for Software Components},
  journal = {IEEE Transactions on Software Engineering},
  year = {2002},
  volume = {28},
  pages = {1056--1076},
  number = {11},
  abstract = {Abstract�In this paper, we propose a means to enhance an architecture
	description language with a description of component behavior. A
	notation used for this purpose should be able to express the interplay"
	on the component's interfaces and reflect step-by-step refinement
	of the component's specification during its design. In addition,
	the notation should be easy to comprehend and allow for formal reasoning
	about the correctness of the specification refinement and also about
	the correctness of an implementation in terms of whether it adheres
	to the specification. Targeting all these requirements together,
	the paper proposes employing behavior protocols which are based on
	a notation similar to regular expressions. As proof of the concept,
	the behavior protocols are used in the SOFA architecture description
	language at three levels: interface, frame, and architecture. Key
	achievements of this paper include the definitions of bounded component
	behavior and protocol conformance relation. Using these concepts,
	the designer can verify the adherence of a component's implementation
	to its specification at runtime, while the correctness of refining
	the specification can be verified at design time.},
  comment = {Very nice paper, looking at behaviour protocols. Has top-down / bottom
	up issue covered. Easily translatable into FSP for activity errors.
	Handles removal of components from an architecture, and compatibility
	with subtypes (although this is a bit axiomatic for my liking).
	
	2006-02-01},
  issn = {0098-5589},
  keywords = {component, architecture description language, SPECIFICATION, definition},
  owner = {amcveigh},
  publisher = {IEEE Press},
  refid = {67},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=631297&coll=Portal&dl=GUIDE&CFID=70282723&CFTOKEN=98894328#}
}

@MISC{Poilpret,
  author = {Jean-Francois Poilpret and J. Osgood},
  title = {{designgridlayout: An Easy and Powerful Swing Layout Manager}},
  howpublished = {https://designgridlayout.dev.java.net/},
  year = {last accessed 2009},
  owner = {andrew},
  timestamp = {2009.06.29},
  url = {https://designgridlayout.dev.java.net/}
}

@INPROCEEDINGS{Prasanta1998,
  author = {Prasanta, Bose},
  title = {Change Analysis in an Architectural Model: A Design Rationale Based
	Approach},
  booktitle = {Proceedings of the Third International Workshop on Software Architecture},
  year = {1998},
  pages = {5--8},
  address = {Orlando, Florida, United States},
  publisher = {ACM Press},
  abstract = {The architectural model of a system provides a high level description
	that enables compositional design and analysis of component-based
	systems. This paper focuses on the problem of evaluation and management
	of change in an architectural model of the system and presents a
	design rationale (DR) based approach to such a problem. We consider
	the types of design rationale knowledge relevant to architectural
	decisions and describe an initial prototype environment for capture
	and usage of such knowledge in analysis of change.},
  comment = {Not a great paper. Looks at capturing the design rationale as a way
	of managing evolution, but the example is very difficult to follow.
	Good description of design-time evolution.
	
	2005-11-18},
  issn = {1-58113-081-3},
  keywords = {software architecture, SYSTEMS},
  owner = {amcveigh},
  refid = {53},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=288410&coll=Portal&dl=GUIDE&CFID=60888327&CFTOKEN=91962879#}
}

@MISC{RationalRealtime,
  author = {{Rational Corporation, IBM}},
  title = {{Rational Rose Technical Developer Website}},
  howpublished = {http://www.ibm.com/developerworks/rational/products/rosetechnicaldeveloper/},
  year = {last accessed August 2009},
  owner = {amcveigh},
  timestamp = {2009.04.02},
  url = {http://www.ibm.com/developerworks/rational/products/rosetechnicaldeveloper/}
}

@MISC{Reenskaug2007,
  author = {Trygve Reenskaug},
  title = {{The Original MVC Reports (1979)}},
  howpublished = {http://heim.ifi.uio.no/trygver/2007/MVC\_Originals.pdf},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.04.03},
  url = {http://heim.ifi.uio.no/~trygver/2007/MVC_Originals.pdf}
}

@INPROCEEDINGS{Robert2005,
  author = {Sylvain Robert and Ansgar Radermacher and Vincent Seignole and S\'{e}bastien
	G\'{e}rard and Virginie Watine and Fran\c{c}ois Terrier},
  title = {The CORBA Connector Model},
  booktitle = {SEM '05: Proceedings of the Fifth International Workshop on Software
	Engineering and Middleware},
  year = {2005},
  pages = {76--82},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  abstract = {Embedded systems designers are more than ever confronted with issues
	related to complexity management. New design methods have emerged
	that could help to face this rising concern, but they do not yet
	satisfy all specific requirements from this application domain. In
	this scope, we aim to adapt the CORBA Component Model approach to
	embedded software design. This adaptation notably requires reworking
	the CCM interaction support, in order to provide more flexibility
	and extensibility. We think that this objective can be reached by
	integrating connectors in the CCM. This paper describes the benefits
	of this approach, and outlines the modifications we have made to
	the CCM in order to integrate connectors.},
  doi = {http://doi.acm.org/10.1145/1108473.1108490},
  isbn = {1-59593-204-4},
  location = {Lisbon, Portugal},
  review = {explains the CCM simply, and shows that it doesn't have connectors.}
}

@BOOK{Robinson2007,
  title = {Aspect-Oriented Programming with the e Verification Language: A Pragmatic
	Guide for Testbench Developers},
  publisher = {Morgan Kaufmann},
  year = {2007},
  author = {David Robinson},
  abstract = {excellent book looking at the use of replacement and resemblance-like
	facilities in the e verification language to simulate aspects.},
  owner = {amcveigh},
  timestamp = {2009.03.26}
}

@ARTICLE{Roshandel2004,
  author = {Roshandel, R. and Van Der Hoek, A. and Mikic-Rakic, M. and Medvidovic,
	N.},
  title = {Mae---A System Model and Environment for Managing Architectural Evolution},
  journal = {ACM Transactions on Software Engineering},
  year = {2004},
  volume = {13},
  pages = {240--276},
  number = {2},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1018210.1018213},
  issn = {1049-331X},
  publisher = {ACM Press}
}

@INPROCEEDINGS{Roundy2005,
  author = {Roundy,, David},
  title = {Darcs: Distributed Version Management in Haskell},
  booktitle = {Haskell '05: Proceedings of the 2005 ACM SIGPLAN Workshop on Haskell},
  year = {2005},
  pages = {1--4},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/1088348.1088349},
  isbn = {1-59593-071-X},
  location = {Tallinn, Estonia},
  owner = {andrew},
  timestamp = {2009.04.04}
}

@BOOK{Rumbaugh1996,
  title = {OMT Insights: Perspectives on Modeling from the Journal of Object-Oriented
	Programming},
  publisher = {Cambridge University Press},
  year = {1996},
  author = {Rumbaugh,, James},
  pages = {123},
  address = {New York, NY, USA},
  isbn = {1884842585},
  review = {Excellent collection of articles from JOOP. Particularly useful is
	the section discussing singletons as being just at 1 point in a compositional
	hierarchy, on page 123.}
}

@BOOK{Rumbaugh2004,
  title = {Unified Modeling Language Reference Manual, The (2nd Edition)},
  publisher = {Pearson Higher Education},
  year = {2004},
  author = {James Rumbaugh and Ivar Jacobson and Grady Booch},
  isbn = {0321245628}
}

@INPROCEEDINGS{Eisenbach2004,
  author = {S. Eisenbach, D. Kayhan, C. Sadler},
  title = {Keeping Control of Reusable Components},
  booktitle = {2nd International Working Conference on Component Deployment},
  year = {2004},
  pages = {144 - 158},
  organization = {e-science Institute},
  publisher = {Springer-Verlag},
  note = {Edinburgh, Scotland, 2004},
  owner = {andrew},
  timestamp = {2007.06.25}
}

@INPROCEEDINGS{Schurr1998,
  author = {Andy Sch\"{u}rr and Andreas J. Winter},
  title = {Formal Definition and Refinement of UML's Module/Package Concept},
  booktitle = {ECOOP '97: Proceedings of the Workshops on Object-Oriented Technology},
  year = {1998},
  pages = {211--215},
  address = {London, UK},
  publisher = {Springer-Verlag},
  isbn = {3-540-64039-8},
  review = {Nice treatment of UML packages, how the export/import rules work and
	the problems with them as a form of modularity.}
}

@INPROCEEDINGS{Schneider1999,
  author = {Jean-Guy Schneider and Oscar Nierstrasz},
  title = {Components, Scripts and Glue},
  booktitle = {Software Architectures: Advances and Applications},
  year = {1999},
  pages = {13--25},
  publisher = {Springer},
  abstract = {Experience has shown us that object-oriented technology alone is not
	enough to guarantee that the systems we develop will be flexible
	and adaptable. Even �welldesigned� object-oriented software may be
	difficult to understand and adapt to new requirements. We propose
	a conceptual framework that will help yield more flexible object-oriented
	systems by encouraging explicit separation of computational and compositional
	elements. We distinguish between components that adhere to an architectural
	style, scripts that specify compositions, and glue that may be needed
	to adapt components � interfaces and contracts. We also discuss a
	prototype of an experimental composition language called P ICCOLA
	that attempts to combine proven ideas from scripting languages, coordination
	models and languages, glue techniques, and architectural specification.
	1},
  review = {Fantastic start to this article, looking at how object architectures
	are limited in extensibility. Some great quotes here.
	
	
	Discusses compositional component approaches -- very relevant to my
	work. Rapidly degenerates though, on start of JPiccola material.}
}

@INPROCEEDINGS{Seiwald1996,
  author = {Christopher Seiwald},
  title = {Inter-File Branching - A Practical Method for Representing Variants},
  booktitle = {ICSE '96: Proceedings of the SCM-6 Workshop on System Configuration
	Management},
  year = {1996},
  pages = {67--75},
  address = {London, UK},
  publisher = {Springer-Verlag},
  isbn = {3-540-61964-X},
  review = {seems like a hacky way to implement distributed artifacts. used by
	MAE. need to look into it more, but it seemingly contradicts itself
	in several places --> does it require the same names for branched
	files or not?}
}

@MISC{Selic2003,
  author = {Selic, B.},
  title = {{Tutorial D: An Overview of UML 2.0}},
  howpublished = {UML 2003},
  year = {2003},
  booktitle = {Sixth International Conference on the Unified Modeling Language,
	October 20-24, 2003, San Francisco},
  comment = {Bran's excellent UML tutorial which shows some of the rationale behind
	his work in ROOM on composite structures, connectors and structural
	refinement. Should revisit this and get back in touch with him.
	
	2003-10-22},
  owner = {amcveigh},
  pages = {--},
  refid = {54},
  timestamp = {2006.03.14}
}

@INCOLLECTION{Selic1994,
  author = {Selic, B. and Gullekson, G. and Ward, P.T.},
  title = {Inheritance},
  booktitle = {Real-Time Object-Oriented Modeling},
  publisher = {Wiley},
  year = {1994},
  number = {9},
  pages = {255--285},
  edition = {1st},
  issn = {0471599174},
  owner = {amcveigh},
  refid = {64},
  timestamp = {2006.03.14}
}

@BOOK{Selic1994a,
  title = {Real-Time Object-Oriented Modeling},
  publisher = {John Wiley \& Sons},
  year = {1994},
  author = {Selic, B. and Gullekson, G. and Ward, P.T.},
  owner = {amcveigh},
  timestamp = {2006.05.30}
}

@INPROCEEDINGS{Shukla2002,
  author = {Sandeep K. Shukla and Frederic Doucet and Rajesh K. Gupta},
  title = {Structured Component Composition Frameworks for Embedded System Design},
  booktitle = {HiPC '02: Proceedings of the 9th International Conference on High
	Performance Computing},
  year = {2002},
  pages = {663--678},
  address = {London, UK},
  publisher = {Springer-Verlag},
  abstract = {The increasing integration of system-chips is leading to a widening
	
	gap in the size and complexity of the chip-level design and the design
	capabilities.
	
	A number of advances in high-level modeling and validation have been
	proposed
	
	over the past decade in an attempt to bridge the gap in design productivity.
	
	Prominent among these are advances in Abstraction and Reuse and structured
	design
	
	methods such as Component-Based Design and Platform-Based Design.
	In
	
	this paper, we present an overview of the recent advances in reuse,
	abstraction,
	
	and component frameworks.We describe a compositional approach to high-level
	
	modeling as implemented in the BALBOA project.},
  isbn = {3-540-00303-7},
  review = {contains a re-explanation of type inference in a component-based system.
	also contains details on partial/loose typing...},
  timestamp = {2005.11.25}
}

@ARTICLE{Spinellis2001,
  author = {Diomidis Spinellis},
  title = {Notable Design Patterns for Domain Specific Languages},
  journal = {Journal of Systems and Software},
  year = {2001},
  volume = {56},
  pages = {91--99},
  number = {1},
  month = feb,
  doi = {doi:10.1016/S0164-1212(00)00089-3},
  issn = {0164-1212},
  owner = {andrew},
  timestamp = {2009.06.14},
  url = {http://www.dmst.aueb.gr/dds/pubs/jrnl/2000-JSS-DSLPatterns/html/dslpat.html}
}

@BOOK{Spivey1992,
  title = {The Z Notation: A Reference Manual},
  publisher = {Prentice-Hall, Inc.},
  year = {1992},
  author = {J. Michael Spivey},
  owner = {andrew},
  timestamp = {2009.05.13}
}

@INPROCEEDINGS{Sreedhar2002,
  author = {Vugranam C. Sreedhar},
  title = {Mixin'Up Components},
  booktitle = {ICSE '02: Proceedings of the 24th International Conference on Software
	Engineering},
  year = {2002},
  pages = {198--207},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  note = {2005.11.28},
  abstract = {Recently we proposed a language called ACOEL (A Component-Oriented
	Extension Language) for abstracting and composing software components.
	Components in ACOEL are black-box components, and each component
	consists of (1) an internal implementation containing classes, methods,
	and fields that is hidden to the external world, and (2) an external
	contract consisting of a set of typed input and output ports. Components
	in ACOEL interact with each other only via these ports. In this paper
	we extend ACOEL in two directions: (1) use mixins to customize the
	services provided by a component without exposing its internal implementation,
	(2) add support for virtual types and sub-type relation among components.
	We will show how mixins and virtual types together allows us to build
	adaptable applications based on black-box component principles.},
  doi = {http://doi.acm.org/10.1145/581339.581366},
  isbn = {1-58113-472-X},
  location = {Orlando, Florida},
  review = {uses mixins + type parameters to allow adding functionality + ports
	and overriding, using inheritance. maybe reread.}
}

@INPROCEEDINGS{Steffen2004,
  author = {Steffen, G.},
  title = {Encapsulation of Structural Adaptation by Composite Components},
  booktitle = {Proceedings of the 1st ACM SIGSOFT workshop on Self-managed systems},
  year = {2004},
  pages = {64--68},
  address = {Newport Beach, California},
  publisher = {ACM Press},
  comment = {Looks at how various reconfigurations of components can be mapped
	onto component parameters. For example, an audio player may have
	one "mode" for low-cpu power and another for high-cpu power. The
	parameter "cpuPower" would map onto 2 reconfigurations of the component,
	which substituted the codec for an appropriate one. The component
	model is called CC, and it has been extended to a unit of structural
	adaptation that allows for: changed parameter, removed connections,
	added connections, removed subcomponents, added subcomponents, replaced
	subcomponents. Very similar to the Jeffs idea of reconfiguration
	primitives.
	
	2005-10-23},
  issn = {1-58113-989-6},
  keywords = {component, SYSTEMS},
  owner = {amcveigh},
  refid = {29},
  timestamp = {2006.03.14},
  url = {http://doi.acm.org/10.1145/1075405.1075418}
}

@INPROCEEDINGS{Steyaert1996,
  author = {Steyaert, P. and Lucas, C. and Mens, K. and D'Hondt, T.},
  title = {Reuse Contracts: Managing the Evolution of Reusable Assets},
  booktitle = {Proceedings of the 11th ACM SIGPLAN Conference on Object-Oriented
	Programming, Systems, Languages, and Applications},
  year = {1996},
  pages = {268--285},
  address = {San Jose, California, United States},
  publisher = {ACM Press},
  abstract = {A critical concern in the reuse of software is the propagation of
	changes made to reusable artifacts, Without techniques to manage
	these changes, multiple versions of these artifacts will propagate
	through different systems and reusers will not be able to benefit
	from improvements to the original artifact. We propose to codify
	the management of change in a software system by means of reuse contracts
	that record the protocol between managers and users of a reusable
	asset. Just as real world contracts can be extended, amended and
	customised, reuse contracts are subject to parallel changes encoded
	by formal reuse operators: extension, refinement and concretisation.
	Reuse contracts and their operators serve as structured documentation
	and facilitate the propagation of changes to reusable assets by indicating
	how much work is needed to update previously built applications,
	where and how to test and how to adjust these applications.},
  comment = {Not fully read. Looks at the challenges of maintaining and evolving
	reusable assets such as framework. Proposes reuse contracts offer
	guidelines for reusing assets in some problem domain, via recording
	of protocols on interfaces.},
  issn = {0-89791-788-X},
  keywords = {SYSTEMS},
  owner = {amcveigh},
  refid = {50},
  timestamp = {2006.03.14}
}

@ARTICLE{Stuckenholz2005,
  author = {Stuckenholz, A.},
  title = {Component Evolution and Versioning State of the Art},
  journal = {SIGSOFT Software Engineering Notes},
  year = {2005},
  volume = {30},
  pages = {7--},
  number = {1},
  abstract = {Emerging component-based software development architectures promise
	better re-use of software components, greater flexibility, scalability
	and higher quality of services. But like any other piece of software
	too, software components are hardly perfect, when being created.
	Problems and bugs have to be fixed and new features need to be added.
	This paper analyzes the problem of component evolution and the incompatibilities
	which result during component upgrades. We present the state of the
	art in component versioning and compare the different methods in
	component models, frameworks and programming languages. Special attention
	is put on the automation of processes and tool support in this area.
	The concluding section sketches a possible solution of these problems
	we are currently working on.},
  comment = {Focussed mainly on versioning artifacts involved in component architecture.
	Looks at mechanisms to sort out versioning (CM issues), detection
	of changes, substitutability checks, and minimization of incompatibilities.
	Not particularly interesting
	
	2005-11-07},
  issn = {0163-5948},
  keywords = {component},
  owner = {amcveigh},
  publisher = {ACM Press},
  refid = {40},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=1039197&coll=Portal&dl=GUIDE&CFID=56765354&CFTOKEN=72300829#}
}

@MISC{Network2006,
  author = {{SUN Developer Network}},
  title = {{Java SE Desktop Technologies - JavaBeans}},
  howpublished = {http://java.sun.com/products/javabeans/},
  year = {last accessed August 2009},
  journal = {Website},
  owner = {amcveigh},
  review = {Eclipse plugin site, showing thousands of plugins.},
  timestamp = {2006.05.15},
  url = {http://java.sun.com/products/javabeans/}
}

@MISC{Network2006a,
  author = {{SUN Developer Network}},
  title = {{Enterprise JavaBeans Technology}},
  howpublished = {http://java.sun.com/products/ejb/},
  year = {last accessed August 2009},
  journal = {Website},
  owner = {amcveigh},
  review = {Eclipse plugin site, showing thousands of plugins.},
  timestamp = {2006.05.15},
  url = {http://java.sun.com/products/ejb/}
}

@MISC{EJBRestrictions2009,
  author = {{SUN Microsystems}},
  title = {{EJB Restrictions}},
  howpublished = {http://java.sun.com/blueprints/qanda/ejb\_tier/\\\-restrictions.html},
  year = {Last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.06.16},
  url = {http://java.sun.com/blueprints/qanda/ejb_tier/restrictions.html}
}

@MISC{JavaCC,
  author = {{SUN Microsystems}},
  title = {{JavaCC}},
  howpublished = {https://javacc.dev.java.net/},
  year = {last accessed August 2009},
  journal = {Website},
  owner = {andrew},
  timestamp = {2006.10.04},
  url = {https://javacc.dev.java.net/}
}

@INPROCEEDINGS{Svahnberg1999,
  author = {Svahnberg, M. and Bosch, J.},
  title = {Characterizing Evolution in Product Line Architectures},
  booktitle = {Proceedings of the IASTED 3rd International Conference on Software
	Engineering and Applications},
  year = {1999},
  owner = {amcveigh},
  timestamp = {2006.05.30}
}

@INPROCEEDINGS{Szyperski2006,
  author = {Szyperski, C.},
  title = {Independently Extensible Systems -- Software Engineering Potential
	and Challenges},
  booktitle = {In Proceedings of the 19th Australasian Computer Science Conference},
  year = {2006},
  address = {Melbourne, Australia},
  abstract = {Component-based software, open systems, and document-based user interfaces
	are about to revolutionise most areas traditionally addressed by
	the software engineer. We claim that many traditional software engineering
	methods, from life-cycle models to programming languages to system
	architectures are at least insufficient when facing the new trends.
	In this paper we present the main points of criticism and state a
	few unavoidable facts of life: extensible systems are in principle
	modular, have no ...},
  comment = {Interesting exposition of the problems involved with integrating modular
	extensions. Discusses issues with global integrity checking. Good
	example of operating systems.
	
	2005-12-05},
  keywords = {SYSTEMS},
  owner = {amcveigh},
  refid = {73},
  timestamp = {2006.03.14},
  url = {http://citeseer.ist.psu.edu/szyperski96independently.html}
}

@BOOK{Szyperski2002,
  title = {Component Software: Beyond Object-Oriented Programming},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  year = {2002},
  author = {Szyperski,, Clemens},
  address = {Boston, MA, USA},
  isbn = {0201745720},
  review = {the infamous (and confused) book about software components.}
}

@ARTICLE{Taivalsaari1996,
  author = {Antero Taivalsaari},
  title = {On the Notion of Inheritance},
  journal = {ACM Computing Surveys},
  year = {1996},
  volume = {28},
  pages = {438--479},
  number = {3},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/243439.243441},
  issn = {0360-0300},
  publisher = {ACM Press},
  review = {useful for referring to inheritance.}
}

@INPROCEEDINGS{Tarr2002,
  author = {Tarr,, Peri and Ossher,, Harold and Sutton,Jr., Stanley M.},
  title = {Hyper/J: Multi-Dimensional Separation of Concerns for Java},
  booktitle = {ICSE '02: Proceedings of the 24th International Conference on Software
	Engineering},
  year = {2002},
  pages = {689--690},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/581339.581447},
  isbn = {1-58113-472-X},
  location = {Orlando, Florida},
  owner = {andrew},
  timestamp = {2009.03.31}
}

@INPROCEEDINGS{Taylor1995,
  author = {Taylor, R.N. and Medvidovic, N. and Anderson, M. and Whithead Jr.,
	E.J. and Robbins, J.E.},
  title = {A Component- and Message-based Architectural Style for GUI Software},
  booktitle = {Proceedings of the 17th International Conference on Software Engineering},
  year = {1995},
  pages = {295--304},
  address = {Seattle, Washington, United States},
  publisher = {ACM Press},
  abstract = {While a large fraction of application system code is devoted to user
	interface functions, support for reuse in this domain has largely
	been conjined to creation of UI toolkits ("widgets"). We present
	a novel architectural style directed at supporting larger grain reuse
	andjexible system composition. Moreover the style supports design
	of distributed, concurrent, applications. A key aspect of the style
	is that components are not built with any dependencies on what typically
	would be considered lower-level components, such as user interface
	toolkits. Indeed, all components are oblivious to the existence of
	any components to which notijcation messages are sent. Asynchronous
	notification messages and asynchronous request messages are the sole
	basis for inter-component communication. While our focus has been
	on applications involving graphical user interfaces, the style has
	the potential for broader applicability. Several trial applications
	using the style are described.},
  comment = {Introduces the Chiron-2 style of architecture (often called just C2)
	which consists of active components each potentially with their own
	thread of control. Components offer a set of services, and generate
	a set of notifications which are called the top domain. Components
	require a set of services, and respond to a set of notifications,
	which is known as the bottom domain. No nested components appear
	possible. Multiple components can connect to notification buses.
	All services are invoked asynchronously, leading I presume to a state-based
	approach for handling notifications. It is proposed that this represents
	a viable and advanced architectural style for forming GUI applications.
	Several examples of GUI applications are presented including a KLAX
	game which is interesting.
	
	2005-10-23},
  issn = {0-89791-708-1},
  keywords = {component},
  owner = {amcveigh},
  refid = {45},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=225042&coll=Portal&dl=GUIDE&CFID=60882501&CFTOKEN=91583883#}
}

@BOOK{Taylor2010,
  title = {Software Architecture: Foundations, Theory and Practice},
  publisher = {John Wiley \& Sons},
  year = {2010},
  author = {Richard N. Taylor and Nend Medvidovic and Eric M. Dashofy},
  owner = {andrew},
  timestamp = {2009.04.03}
}

@MISC{Templin2005,
  author = {Dave Templin},
  title = {{Escape DLL Hell: Simplify App Deployment with ClickOnce and Registration-Free
	COM}},
  howpublished = {http://msdn2.microsoft.com/en-us/magazine/cc188708.aspx},
  year = {last accessed August 2009},
  journal = {MSDN Magazine},
  owner = {amcveigh},
  review = {decent explanation of the main focus of the eclipse platform, including
	plugin architecture.},
  timestamp = {2006.05.15},
  url = {http://msdn2.microsoft.com/en-us/magazine/cc188708.aspx}
}

@INPROCEEDINGS{Thomas1988,
  author = {Thomas,, Dave and Johnson,, Kent},
  title = {Orwell---A Configuration Management System for Team Programming},
  booktitle = {OOPSLA '88: Conference proceedings on Object-Oriented Programming
	Systems, Languages and Applications},
  year = {1988},
  pages = {135--141},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/62083.62096},
  isbn = {0-89791-284-5},
  location = {San Diego, California, United States},
  owner = {andrew},
  timestamp = {2009.04.04}
}

@INPROCEEDINGS{Truyen2001,
  author = {Truyen, E. and Vanhaute, B. and Jorgensen, B.N. and Joosen, W. and
	Verbaeton, P.},
  title = {Dynamic and Selective Combination of Extensions in Component-Based
	Applications},
  booktitle = {ICSE '01: Proceedings of the 23rd International Conference on Software
	Engineering},
  year = {2001},
  pages = {233--242},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  isbn = {0-7695-1050-7},
  location = {Toronto, Ontario, Canada}
}

@INPROCEEDINGS{Uchitel2004,
  author = {Uchitel, S. and Chatley, R. and Kramer, J. and Magee, J.},
  title = {System Architecture: the Context for Scenario-Based Model Synthesis},
  booktitle = {Proceedings of the 12th ACM SIGSOFT International Symposium on Foundations
	of Software Engineering},
  year = {2004},
  pages = {33--42},
  address = {Newport Beach, CA, USA},
  publisher = {ACM Press},
  abstract = {Constructing rigorous models for analysing the behaviour of concurrent
	and distributed systems is a complex task. Our aim is to facilitate
	model construction. Scenarios provide simple, intuitive, example
	based descriptions of the behaviour of component instances in the
	context of a simplified architecture instance. The specific architecture
	instance is generally chosen to provide sufficient context to indicate
	the expected behaviour of particular instances of component types
	to be used in the real system. Existing synthesis techniques provide
	mechanisms for building behaviour models for these simplified and
	specific architectural settings. However, the behaviour models required
	are those for the full generality of the system architecture, and
	not the simplified architecture used for scenarios. In this paper
	we exploit architectural information in the context of behaviour
	model synthesis from scenarios. Software architecture descriptions
	give the necessary contextual information so that component instance
	behaviour can be generalised to component type behaviour. Furthermore,
	architecture description languages can be used to describe the complex
	architectures in which the generalised behaviours need to be instantiated.
	Thus, architectural information used in conjunction with scenario-based
	model synthesis can support both model construction and elaboration,
	where the behaviour derived from simple architecture fragments can
	be instantiated in more complex ones.},
  comment = {Excellent paper, very accessible. Looks at using scenarios at multiple
	levels of abstraction to develop an architecture and apply these
	scenarios to architectures with different abstractions in them. Uses
	ports in sequence diagram.
	
	2006-01-09},
  issn = {1-58113-855-5},
  keywords = {SYSTEMS, component, software architecture, architecture description
	language},
  owner = {amcveigh},
  refid = {70},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=1029903&coll=Portal&dl=GUIDE&CFID=70282723&CFTOKEN=98894328#}
}

@ARTICLE{Uchitel2004a,
  author = {Uchitel, S. and Kramer, J. and Magee, J.},
  title = {Incremental Elaboration of Scenario-Based Specifications and Behavior
	Models using Implied Scenarios},
  journal = {ACM Transactions on Software Engineering and Methodology (TOSEM)},
  year = {2004},
  volume = {13},
  pages = {37--85},
  number = {1},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1005561.1005563},
  issn = {1049-331X},
  publisher = {ACM Press}
}

@ARTICLE{Vanderperren2001,
  author = {Wim Vanderperren and Bart Wydaeghe},
  title = {Towards a New Component Composition Process},
  journal = {Eighth Annual IEEE International Conference and Workshop on the Engineering
	of Computer Based Systems (ECBS)},
  year = {2001},
  volume = {0},
  pages = {0322},
  abstract = {Component Based Development is considered to be a promising technology
	to cure the software crisis. However, until now designing and developing
	component-based applications turns out to be very hard. Current component
	based development not only involves a component configuration phase,
	but also writing a lot of glue-code. Much of the existing glue-code
	in current systems is written to "hack " components together instead
	of following a careful design. In this paper we introduce a component
	composition methodology based on the concept of composition patterns.
	A composition pattern describes an interaction between a set of roles
	using an extended sequence chart. It serves as a bridge between the
	design and the implementation. We further propose a component documentation
	and a set of algorithms based on finite automata theory to perform
	an automatic compatibility check and glue-code generation to support
	this methodology.},
  address = {Los Alamitos, CA, USA},
  doi = {http://doi.ieeecomputersociety.org/10.1109/ECBS.2001.922439},
  isbn = {0-7695-1086-8},
  publisher = {IEEE Computer Society},
  review = {related to the other paper by Wydaeghe and Vandperren: general idea
	is that a sequence of fixed primitives can be used to check the compatibility
	of a component playing a role in a pattern.
	
	
	glue lives with the reuse context. again, this paper is limited by
	the lack of explanation of the choices of the fixed message type
	primitives for testing compatbility. poor explanations on why these
	are useful or complete.},
  timestamp = {2006.07.24}
}

@INPROCEEDINGS{Vax2007,
  author = {Matan Vax},
  title = {Conservative Aspect-Orientated Programming with the e Language},
  booktitle = {AOSD '07: Proceedings of the 6th International Conference on Aspect-Oriented
	Software Development},
  year = {2007},
  pages = {149--160},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/1218563.1218581},
  isbn = {1-59593-615-7},
  location = {Vancouver, British Columbia, Canada},
  review = {excellent paper describing how the extend feature of e makes it aspect
	oriented. also, i have the book of this.
	
	
	another useful contribution is to show that aspect quantifications
	are essentially only useful when used in a non domain specific way.
	i.e. they are metamodeling. so, aspects are metamodeling (limited)
	and oblivious extension (with limited combination power).
	
	
	other paper referenced shows that aspects are quantification and obliviousness.
	very interesting. shows that inheritance (resemblance) offers a level
	of simple quantification.}
}

@BOOK{Vlissides1998,
  title = {Pattern Hatching: Design Patterns Applied},
  publisher = {Addison Wesley Professional},
  year = {1998},
  author = {Vlissides, John.},
  owner = {andrew},
  timestamp = {2006.10.04}
}

@PHDTHESIS{Vlissides1990,
  author = {Vlissides,, John M.},
  title = {Generalized Graphical Object Editing},
  school = {Stanford University},
  year = {1990},
  address = {Stanford, CA, USA},
  note = {Adviser-Linton,, Mark A.},
  order_no = {AAI9102367},
  owner = {andrew},
  publisher = {Stanford University},
  timestamp = {2009.03.19}
}

@INPROCEEDINGS{Vlissides1989,
  author = {Vlissides,, J. M. and Linton,, M. A.},
  title = {Unidraw: a Framework for Building Domain-Specific Graphical Editors},
  booktitle = {UIST '89: Proceedings of the 2nd annual ACM SIGGRAPH Symposium on
	User Interface Software and Technology},
  year = {1989},
  pages = {158--167},
  address = {New York, NY, USA},
  publisher = {ACM},
  abstract = {Unidraw is a framework for creating object-oriented graphical editors
	in domains such as technical and artistic drawing, music composition,
	and CAD. The Unidraw architecture simplifies the construction of
	these editors by providing programming abstractions that are common
	across domains. Unidraw defines four basic abstractions: components
	encapsulate the appearance and behavior of objects, tools support
	direct manipulation of components, commands define operations on
	components, and external representations define the mapping between
	components and a file or database. Unidraw also supports multiple
	views, graphical connectivity, and dataflow between components. This
	paper presents Unidraw and three prototype domain-specific editors
	we have developed with it: a schematic capture system, a user interface
	builder, and a drawing editor. Experience indicates a substantial
	reduction in implementation time and effort compared with existing
	tools.},
  doi = {http://doi.acm.org/10.1145/73660.73680},
  isbn = {0-89791-335-3},
  location = {Williamsburg, Virginia, United States},
  owner = {andrew},
  review = {great early graphical editor: tools, subjects and views.},
  timestamp = {2009.03.19}
}

@INPROCEEDINGS{Volter1999,
  author = {Makus Volter},
  title = {Pluggable Component - A Pattern for Interactive System Configuration},
  booktitle = {The Fourth European Conference of Pattern Languages of Programming
	and Computing, EuroPLoP '99},
  year = {1999},
  address = {Bad Irsee, Germany},
  owner = {andrew},
  review = {referenced in the lightweight plug-in paper of Mayer. Seems to deal
	more with runtime change.},
  timestamp = {2008.03.13}
}

@INPROCEEDINGS{Wermelinger1998,
  author = {Wermelinger, M.},
  title = {A Simple Description Language for Dynamic Architectures},
  booktitle = {Proceedings of the Third International Workshop on Software Architecture},
  year = {1998},
  pages = {159--162},
  address = {Orlando, Florida, United States},
  publisher = {ACM Press},
  abstract = {The Chemical Abstract Machine (CHAM) is a very elegant and simple
	computational model that has been used for the specification of both
	static and dynamic architectures. However, so far those descriptions
	are ad-hoc and monolithic, thus making it difficult to perceive the
	elements and form of an architecture. In this paper we present some
	syntactic constructs and a methodology to specify an architecture
	in a principled, explicit, and modular way, thus proposing a very
	simple and compact Architecture Description Language (ADL) which
	is especially suited for dynamic architectures.},
  comment = {Describes the CHAM, and its relevance as a potential ADL. Mentions
	that it isn't an ADL.
	
	2005-10-23},
  issn = {1-58113-081-3},
  keywords = {software architecture, SPECIFICATION, architecture description language},
  owner = {amcveigh},
  refid = {32},
  timestamp = {2006.03.14},
  url = {http://doi.acm.org/10.1145/288408.288449}
}

@MISC{Wheeler,
  author = {David A. Wheeler},
  title = {{SLOCCount: A set of tools for counting physical source lines of
	code}},
  howpublished = {http://www.dwheeler.com/sloccount/},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.07.24},
  url = {http://www.dwheeler.com/sloccount/}
}

@INPROCEEDINGS{Wijnstra2000,
  author = {Jan Gerben Wijnstra},
  title = {Supporting Diversity with Component Frameworks as Architectural Elements},
  booktitle = {ICSE '00: Proceedings of the 22nd International Conference on Software
	Engineering},
  year = {2000},
  pages = {51--60},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  abstract = {In this paper, we describe our experience with component frameworks
	within a family architecture for a medical imaging product family.
	The component frameworks are handled as an integral part of the architectural
	approach and are an important means to support diversity in the functionality
	provided by the individual family members.This paper focuses on a
	particular kind of component framework that has been applied throughout
	the medical imaging product family. This kind of framework is useful
	when the various family members are based on the same concepts and
	the diversity is formed by the differences in the specific instances
	of these concepts that are present in the family members. These component
	frameworks have a number of similarities, allowing a standardised
	approach to their development. They support the division of the system
	into a generic architectural skeleton, which can be extended with
	plug-ins to realise specific family members, each with their own
	set of features.},
  doi = {http://doi.acm.org/10.1145/337180.337188},
  isbn = {1-58113-206-9},
  location = {Limerick, Ireland},
  review = {ok for some ideas, but fairly basic. need to look more at white box
	versus black box reuse.},
  timestamp = {2005.11.23}
}

@MISC{Wordpress,
  author = {Wordpress},
  title = {{Wordpress Plugins}},
  howpublished = {http://wordpress.org/extend/plugins/},
  year = {last accessed August 2009},
  owner = {andrew},
  timestamp = {2009.08.03},
  url = {http://wordpress.org/extend/plugins/}
}

@INPROCEEDINGS{Wydaeghe2001,
  author = {Bart Wydaeghe and Wim Vanderperren},
  title = {Visual Component Composition Using Composition Patterns},
  booktitle = {TOOLS '01: Proceedings of the 39th International Conference and Exhibition
	on Technology of Object-Oriented Languages and Systems (TOOLS39)},
  year = {2001},
  pages = {120},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  abstract = {We improve current visual component composition environments by introducing
	composition patterns as first class objects that can be defined,
	stored and reused independently of the components. We document both
	components and composition patterns using an extended sequence diagram
	notation. For a component, typical usage protocols are specified
	while a composition pattern specifies how a set of roles interact.
	From this documentation, we check whether a component can work as
	described by a composition pattern using finite state automata theory
	and we generate glue-code for the composition. In this paper we present
	our approach, explain the checking algorithms and glue code generation
	and discuss the tool support we developed.},
  review = {started reading but lost interest quickly.
	
	
	general idea is that a sequence of fixed primitives can be used to
	check the compatibility of a component playing a role in a pattern.
	
	
	how can they possibly verify that the primitives are sufficient for
	describing all compability problems? most likely this works for a
	small subset of issues.},
  timestamp = {2006.06.24}
}

@INPROCEEDINGS{Xiong2000,
  author = {Xiong, Y. and Lee, E.A.},
  title = {An Extensible Type System for Component-Based Design},
  booktitle = {Proceedings of the 6th International Conference on Tools and Algorithms
	for Construction and Analysis of Systems},
  year = {2000},
  pages = {20--37},
  publisher = {Springer-Verlag},
  abstract = {Component-based design has been established as an important approach
	to designing complex embedded systems, which often have many concurrent
	computational activities and mix widely differing operations. A good
	type system is particularly important for component-based design.
	A type system can improve the safety and flexibility of the design
	environment, promote component reuse, and help simplify component
	development and optimization. Although type systems have been studied
	extensively in the programming language community, its research in
	component-based design is not enough.},
  comment = {Not read fully yet. Deals with component types by allowing for port
	typing constraints. Further follows connectors to parts to transmit
	the typing information to the embedded components. Could solve typing
	issues with deeply nested components and the issues that come from
	exposing new extension points.},
  issn = {3-540-67282-6},
  keywords = {SYSTEMS, component, definition},
  owner = {amcveigh},
  refid = {47},
  timestamp = {2006.03.14},
  url = {http://portal.acm.org/citation.cfm?id=759191#}
}

@MISC{Yegge2004,
  author = {Yegge, S.},
  title = {When Poymorphism Fails},
  howpublished = {http://steve.yegge.googlepages.com/when-polymorphism-fails},
  year = {last accessed August 2009},
  journal = {Steve Yegge's internal Amazon blog, 2004-2005},
  owner = {amcveigh},
  review = {some greate quotes regarding extensibility.},
  timestamp = {2006.05.15},
  url = {http://steve.yegge.googlepages.com/when-polymorphism-fails}
}

@TECHREPORT{Zenger2004,
  author = {Zenger, M. and Odersky, M.},
  title = {Independently Extensible Solutions to the Expression Problem},
  institution = {Ecole Polytehnique Federale de Lausanne},
  year = {2004},
  owner = {amcveigh},
  timestamp = {2006.05.30}
}

@ARTICLE{Zito2006,
  author = {Zito A, Diskin Z, Dingel J},
  title = {Package Merge in UML 2: Practice vs. Theory?},
  journal = {Model Driven Engineering Languages and Systems},
  year = {2006},
  volume = {9},
  pages = {185--199},
  owner = {amcveigh},
  timestamp = {2007.07.09}
}

@BOOK{Jacko2003,
  title = {The Human-Computer Interaction Handbook: Fundamentals, Evolving Technologies
	and Emerging Applications},
  publisher = {L. Erlbaum Associates Inc.},
  year = {2003},
  editor = {Jacko, Julie A. and Sears, Andrew},
  address = {Hillsdale, NJ, USA},
  isbn = {0-8058-3838-4},
  owner = {andrew},
  timestamp = {2009.06.29}
}

