% This file was created with JabRef 2.10.
% Encoding: UTF-8


@InProceedings{Avgeriou2006,
  Title                    = {Architecture-Centric Evolution: New Issues and Trends},
  Author                   = {Paris Avgeriou and Uwe Zdun and Isabelle Borne},
  Booktitle                = {ECOOP Workshops},
  Year                     = {2006},
  Pages                    = {97-105},

  Bibsource                = {DBLP, http://dblp.uni-trier.de},
  Crossref                 = {DBLP:conf/ecoopw/2006},
  Ee                       = {http://dx.doi.org/10.1007/978-3-540-71774-4_11},
  Owner                    = {andrew},
  Review                   = {looks at some trends in evolving architectures. pretty light.},
  Timestamp                = {2009.05.05}
}

@InProceedings{Batory2005,
  Title                    = {Feature Models, Grammars, and Propositional Formulas},
  Author                   = {Don S. Batory},
  Booktitle                = {SPLC},
  Year                     = {2005},
  Pages                    = {7-20},

  Abstract                 = {Feature models are used to specify members of a product-line.
Despite years of progress, contemporary tools provide limited support for feature
constraints and offer little or no support for debugging feature models. We
integrate prior results to connect feature models, grammars, and propositional
formulas. This connection allows arbitrary propositional constraints to be
defined among features and enables off-the-shelf satisfiability solvers to debug
feature models. We also show how our ideas can generalize recent results on the
staged configuration of feature models.},
  Bibsource                = {DBLP, http://dblp.uni-trier.de},
  Crossref                 = {DBLP:conf/splc/2005},
  Ee                       = {http://dx.doi.org/10.1007/11554844_3},
  Owner                    = {andrew},
  Review                   = {nice look at the start at feature modelling},
  Timestamp                = {2009.06.24}
}

@InProceedings{D'Ippolito2008,
  Title                    = {MTSA: The Modal Transition System Analyser},
  Author                   = {Nicolás D'Ippolito and Dario Fischbein and Marsha Chechik and Sebastián Uchitel},
  Booktitle                = {IEEE/ACM Automated Software Engineering},
  Year                     = {2008},
  Pages                    = {475-476},
  Publisher                = {IEEE},

  Crossref                 = {conf/kbse/2008},
  Date                     = {2008-10-29},
  Ee                       = {http://dx.doi.org/10.1109/ASE.2008.78},
  Interhash                = {ce8c99e0b607329c51f6c9ee8c20e52d},
  Intrahash                = {51e411eb8012e32bd104b7c06a4b649e},
  Owner                    = {andrew},
  Timestamp                = {2009.07.21},
  Url                      = {http://dblp.uni-trier.de/db/conf/kbse/ase2008.html#DIppolitoFCU08}
}

@Article{Adamek2005,
  Title                    = {Component Composition Errors and Update Atomicity: Static Analysis},
  Author                   = {Adamek, J. and Plasil, F.},
  Journal                  = {Journal of Software Maintenance and Evolution: Research and Practice},
  Year                     = {2005},
  Number                   = {5},
  Pages                    = {363--377},
  Volume                   = {17},

  Abstract                 = {Dynamic evolution inherently involves dynamic update and the issue of its atomicity. We show how this issue can be addressed in a similar manner to a communication failure via an extension to behavior protocols. First, we discuss the problem of defining a composition operator for behavior protocols so as to be able to reflect communication failures. Classical architecture description languages (ADLs) supporting behavior description, such as Wright and TRACTA, use a CSP-like parallel composition, which inherently yields only 'successful traces' ignoring non-accepted communication attempts. We show that component composition can produce several different types of behavior errors: bad activity, no activity, and divergence. The key idea behind bad activity is that real programs typically have an asymmetry of roles during event exchange: the caller is considered to be the initiator of the call while the callee has only a passive role. This contrasts with most formal systems, which treat communication symmetrically. We propose a new composition operator, 'consent', which reflects these types of errors by producing erroneous traces. By using the consent operator it can be statically determined whether the atomicity of a dynamic update of a component is implicitly guaranteed by the behavior of its current environment. Copyright � 2005 John Wiley & Sons, Ltd.},
  Comment                  = {Excellent and very understantable. Looks at protocols for behaviour and introduces update tokens. Very nice concept. Introduces an operator called "consent" which leads to an analysis of behavioural errors when composing: bad activity, no activity and divergence. Easy to get these results with FSP instead.
2006-01-12},
  ISSN                     = {1532-060X},
  Keywords                 = {component, architecture description language, SYSTEMS},
  Owner                    = {amcveigh},
  Publisher                = {John Wiley \& Sons, Inc.},
  Refid                    = {72},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=1090748&coll=Portal&dl=GUIDE&CFID=70282723&CFTOKEN=98894328#}
}

@InProceedings{Adamek2004,
  Title                    = {Partial Bindings of Components - Any Harm?},
  Author                   = {Adamek, J. and Plasil, F.},
  Booktitle                = {Proceedings of the 11th Asia-Pacific Software Engineering Conference (APSEC'04) - Volume 00},
  Year                     = {2004},
  Pages                    = {632--639},
  Publisher                = {IEEE Computer Society},

  Abstract                 = {Reuse is one of the key benefits of components. It inherently means that the functionality of a component may be employed only partially. This triggers the issue whether all of the component's interfaces have to be really bound to the other components in its current environment (missing binding problem). Assuming each of the components is equipped by its behavior protocol, we show that missing bindings can be statically identified via verification tools, in particular by employing the concept of bad activity error introduced in [Component Composition Errors and Update Atomicity: Static Analysis].},
  Comment                  = {Excellent paper looking at how to verify that we can omit elements from an architecture using protocols. Need to look into how to do this in a hierarchy.
2006-01-06},
  ISSN                     = {0-7695-2245-9},
  Keywords                 = {component},
  Owner                    = {amcveigh},
  Refid                    = {68},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=1032783&coll=Portal&dl=GUIDE&CFID=70282723&CFTOKEN=98894328#}
}

@Book{Agha1986,
  Title                    = {Actors: A Model of Concurrent Computation in Distributed Systems},
  Author                   = {Agha,, Gul},
  Publisher                = {MIT Press},
  Year                     = {1986},

  Address                  = {Cambridge, MA, USA},

  ISBN                     = {0-262-01092-5},
  Owner                    = {andrew},
  Timestamp                = {2009.04.06}
}

@InProceedings{Alanen2003,
  Title                    = {Difference and Union of Models},
  Author                   = {Alanen, M. and Porres, I.},
  Booktitle                = {UML2003},
  Year                     = {2003},
  Editor                   = {Stevens, P. and Whittle.J and Booch, J.},
  Publisher                = {Springer-Verlag},

  Chapter                  = {Difference and Union of Models},
  Owner                    = {amcveigh},
  Timestamp                = {2006.05.30}
}

@InProceedings{Aldrich2008,
  Title                    = {Using Types to Enforce Architectural Structure},
  Author                   = {Aldrich,, Jonathan},
  Booktitle                = {WICSA '08: Proceedings of the Seventh Working IEEE/IFIP Conference on Software Architecture (WICSA 2008)},
  Year                     = {2008},

  Address                  = {Washington, DC, USA},
  Pages                    = {211--220},
  Publisher                = {IEEE Computer Society},

  Doi                      = {http://dx.doi.org/10.1109/WICSA.2008.48},
  ISBN                     = {978-0-7695-3092-5},
  Owner                    = {andrew},
  Timestamp                = {2009.04.04}
}

@InProceedings{Aldrich2002,
  Title                    = {ArchJava: Connecting Software Architecture to Implementation},
  Author                   = {Aldrich,, Jonathan and Chambers,, Craig and Notkin,, David},
  Booktitle                = {ICSE '02: Proceedings of the 24th International Conference on Software Engineering},
  Year                     = {2002},

  Address                  = {New York, NY, USA},
  Pages                    = {187--197},
  Publisher                = {ACM},

  Doi                      = {http://doi.acm.org/10.1145/581339.581365},
  ISBN                     = {1-58113-472-X},
  Location                 = {Orlando, Florida},
  Owner                    = {andrew},
  Timestamp                = {2009.04.04}
}

@Article{Allen1994,
  Title                    = {Beyond Definition/Use: Architectural Interconnection},
  Author                   = {Allen,, Robert and Garlan,, David},
  Journal                  = {Proceedings of the workshop on Interface Definition Languages},
  Year                     = {1994},
  Number                   = {8},
  Pages                    = {35--45},
  Volume                   = {29},

  Abstract                 = {Large software systems require decompositional mechanisms in order to make them tractable. Traditionally, MILs and IDLs have played this role by providing notations based on definition/use bindings. In this paper we argue that current MIL/IDLs based on definition/use have some serious drawbacks. A significant problem is that they fail to distinguish between "implementation" and "interaction" relationships between modules. We propose an alternative model in which components interact along welldefined lines of communication -- or connectors. Connectors are defined as protocols that capture the expected patterns of communication between modules. We show how this leads to a scheme that is much more expressive for architectural relationships, that allows the formal definition of module interaction, and that supports its own form of automated checks and formal reasoning.},
  Address                  = {New York, NY, USA},
  Doi                      = {http://doi.acm.org/10.1145/185087.185101},
  ISSN                     = {0362-1340},
  Owner                    = {amcveigh},
  Publisher                = {ACM},
  Review                   = {The paper that explains the use of connectors as the differentiating factor between ADLs and MILs.},
  Timestamp                = {2009.04.02}
}

@InBook{Team2002-2003,
  Title                    = {The AspectJ Programming Guide},
  Author                   = {{AspectJ Team}},
  Chapter                  = {1. Getting Started with AspectJ},
  Publisher                = {Xerox Corporation},
  Year                     = {2002-2003},

  Owner                    = {amcveigh},
  Timestamp                = {2009.03.26},
  Url                      = {http://www.eclipse.org/aspectj/doc/released/progguide/starting-aspectj.html}
}

@InProceedings{Barais2004,
  Title                    = {TranSAT: A Framework for the Specification of Software Architecture Evolution},
  Author                   = {Olivier Barais and Eric Cariou and Laurence Duchien and Nicolas Pessemier and Lionel Seinturier},
  Booktitle                = {ECOOP First International Workshop on Coordination and Adaptation Techniques for Software Entities (WCAT04)},
  Year                     = { 2004 },

  Address                  = { Oslo, Norway },
  Month                    = { jun },

  Abstract                 = { Everything changes in our everyday lives: New discoveries, paradigms, styles, and technologies. Frequently, software systems success depends on how they can quickly adapt to requirement or environment evolution. Software architectures are ABSTRACT models at the highest level. As such, they should assume conceptual guidance on what parts of the system changed. However, many software architectures often evolve from an uncoordinated build-and-fix attitude. The result is opaque and not analyzable. We present in this paper a practical experience of using aspect oriented programming principles for managing software architecture specification evolution. Our approach aims at clarifying software architecture evolution steps. It extends software architecture ABSTRACT models for the specification and the analysis of new concern integration. },
  Comment                  = {Workshop,en},
  Dateadded                = { 2007-03-26 },
  Groups                   = { international,jacquard,mosaiques,workshop },
  Lastdatemodified         = { 2007-03-26 },
  Lastname                 = { Barais },
  Longnotes                = { 20040601 },
  Owner                    = {andrew},
  Timestamp                = {2009.05.05},
  Website                  = { wcat04.unex.es/ }
}

@InProceedings{Barais2006,
  Title                    = {Safe Integration of New Concerns in a Software Architecture},
  Author                   = {Barais,, Olivier and Le Meur,, Anne-Francoise and Duchien,, Laurence and Lawall,, Julia},
  Booktitle                = {ECBS '06: Proceedings of the 13th Annual IEEE International Symposium and Workshop on Engineering of Computer Based Systems},
  Year                     = {2006},

  Address                  = {Washington, DC, USA},
  Pages                    = {52--64},
  Publisher                = {IEEE Computer Society},

  Abstract                 = {Software architectures must frequently evolve to cope with changing requirements, and this evolution often implies integrating new concerns. Unfortunately, existing architecture description languages provide little or no support for this kind of evolution. The software architect must modify the architecture manually, which risks introducing inconsistencies. In previous work, we have proposed the TranSAT framework, which provides a pattern construct for describing new concerns and their integration into an existing architecture. As the interaction between the new concern and the existing architecture may be complex, it is essential that the framework ensure the coherence of the resulting architecture. In this paper, we introduce a language for specifying patterns and verifications that ensure that the concern represented by a pattern can be safely integrated into an existing architecture. The verifications comprise static verifications that check coherence properties before the architecture is modified and dynamic verifications that focus on the parts of the architecture that are affected by the pattern. As a result of these verifications, patterns can be provided as a commodity, such that a software architect can confidently apply a pattern obtained from a third-party developer.},
  Doi                      = {http://dx.doi.org/10.1109/ECBS.2006.64},
  ISBN                     = {0-7695-2546-6},
  Owner                    = {andrew},
  Review                   = {quite neat -- uses aspects (add port, create binding etc) to remake an architecture. joinpoints are specified using structural and behavioural patterns.},
  Timestamp                = {2009.05.05}
}

@Misc{Barnabe2007,
  Title                    = {{Avoiding Extension Conflicts in Firefox}},

  Author                   = {Jason Barnabe},
  HowPublished             = {http://blog.userstyles.org/2007/02/06/avoiding-extension-conflicts/},
  Year                     = {last accessed August 2009},

  Abstract                 = {Problems that occur when two specific extensions are installed are difficult to debug. You often won’t see the problem yourself, it’ll be some user reporting it. You have to lasso them long enough to figure out that that indeed is what’s happening rather than some system-specific or a difficult-to-reproduce bug. Once the conflicting extension is found, you have to delve into its gooey innards and try to make some sense of it.},
  Owner                    = {andrew},
  Review                   = {contains rules about avoiding firefox script extensions, and how users tend to find the conflicts first.},
  Timestamp                = {2009.05.05},
  Url                      = {http://blog.userstyles.org/2007/02/06/avoiding-extension-conflicts/}
}

@Article{Barros1996,
  Title                    = {Dynamic Structure Discrete Event System Specification: Structural Inheritance in the DELTA Environment},
  Author                   = {Barros, F.J.},
  Journal                  = {Proceedings of the Sixth Annual Conference on AI, Simulation and Planning in High Autonomy Systems},
  Year                     = {1996},
  Pages                    = {141-147},

  Owner                    = {amcveigh},
  Timestamp                = {2015.07.02}
}

@InProceedings{Batory2006,
  Title                    = {A Tutorial on Feature Oriented Programming and the AHEAD Tool Suite},
  Author                   = {Don Batory},
  Booktitle                = {Generative and Transformational Techniques in Software Engineering},
  Year                     = {2006},
  Pages                    = {3--35},
  Publisher                = {Springer},
  Series                   = {Lecture Notes in Computer Science},
  Volume                   = {4143},

  Abstract                 = {Feature oriented programming (FOP) is the study of feature mod ularity and its use in program synthesis. AHEAD is a theory of FOP that is based on a fundamental concept of generative programming that functions map programs. This enables the design of programs to be expressed compo sitionallyas algebraic expressions, which are suited for automated analysis, manipulation, and program synthesis. This paper is a tutorialon FOP and AHEAD. We review AHEAD’s theory and the tool set that implements it.},
  Interhash                = {6d24ea963d5dfd5b07cd45574025c1f8},
  Intrahash                = {d80e4cbc2e98a823601d1ce51f199f49},
  Owner                    = {andrew},
  Review                   = {nice tutorial that actually makes the AHEAD system concrete!},
  Timestamp                = {2009.06.24}
}

@Article{Batory2002a,
  Title                    = {Achieving Extensibility Through Product-Lines and Domain-Specific Languages: A Case Study},
  Author                   = {Batory, Don and Johnson, Clay and MacDonald, Bob and von Heeder, Dale},
  Journal                  = {ACM Transactions on Software Engineering and Methodology (TOSEM)},
  Year                     = {2002},
  Number                   = {2},
  Pages                    = {191--214},
  Volume                   = {11},

  Address                  = {New York, NY, USA},
  Doi                      = {http://doi.acm.org/10.1145/505145.505147},
  ISSN                     = {1049-331X},
  Owner                    = {andrew},
  Publisher                = {ACM},
  Timestamp                = {2009.06.26}
}

@InProceedings{Batory2003,
  Title                    = {Refinements and Multi-Dimensional Separation of Concerns},
  Author                   = {Batory, D. and Liu, J. and Sarvela, J.N.},
  Booktitle                = {Proceedings of the 9th European Software Engineering Conference},
  Year                     = {2003},

  Address                  = {Helsinki, Finland},
  Pages                    = {48--57},
  Publisher                = {ACM Press},

  Abstract                 = {Step-wise refinement (SWR) asserts that complex programs can be derived from simple programs by progressively adding features. The length of a program specification is the number of features that the program has. Critical to the scalability of SWR are multi-dimensional models that separate orthogonal feature sets. Let n be the dimensionality of a model and k be the number of features along a dimension. We show program specifications that could be O(kn) features long have short and easy-to-understand specifications of length O(kn) when multi-dimensional models are used. We present new examples of multidimensional models: a micro example of a product-line (whose programs are 30 lines of code) and isomorphic macro examples (whose programs exceed 30K lines of code). Our work provides strong evidence that SWR scales to synthesis of large systems.},
  Comment                  = {Applies a 2d matrix where each axis represents a set of features. To share features, two columns or two rows etc are combined. Seems like an equational approach. Not sure about how useful or actually how scalable this technique is in practice. Relies on ordering in some cases. Matrix type is called Origami due to folding.
2005-12-12},
  ISSN                     = {1-58113-743-5},
  Keywords                 = {SPECIFICATION, SYSTEMS},
  Owner                    = {amcveigh},
  Refid                    = {69},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=940079&coll=Portal&dl=GUIDE&CFID=70282723&CFTOKEN=98894328#}
}

@InProceedings{Batory2002,
  Title                    = {Generating Product-Lines of Product-Families},
  Author                   = {Don Batory and Roberto E. Lopez-Herrejon and Jean-Philippe Martin},
  Booktitle                = {ASE '02: Proceedings of the 17th IEEE International Conference on Automated Software Engineering},
  Year                     = {2002},

  Address                  = {Washington, DC, USA},
  Pages                    = {81},
  Publisher                = {IEEE Computer Society},

  ISBN                     = {0-7695-1736-6},
  Review                   = {interesting but sometimes confusing due to overcomplex terminology and lack of discussion about how gluons are implemented.

it turns out that gluons are methods etc that are part of adding a feature to a product inside a family inside a product line! i.e. a product family is a suite -- e.g. java compiler, java ida. a product line is a java compiler, a java state machine compiler etc. layers are a horizontal grouping of gluons that add a consistent set of features across a family. facets are a vertical grouping of gluons (in the origami matrix) that add a full set of features to a single product in the family.

it also turns out that gluons are implemented using hyper/j -- they are in effect just aspects. so gluons and facets are effectively a way to organise aspects for a product line and product family combination.

there are parallels to what I'm doing, and this serves as a credible way for me to tie my stuff to aspects and feature sets.

class extension = redefinition (interestingly, they have a very similar concept as described in the note on page 4)
inheritance = resemblance (they use classes rather than components)
constant/layer/feature set = stratum
design rules = dependencies between stratum / feature sets},
  Timestamp                = {2007.04.02}
}

@InProceedings{Batory2003a,
  Title                    = {Scaling Step-Wise Refinement},
  Author                   = {Batory,, Don and Sarvela,, Jacob Neal and Rauschmayer,, Axel},
  Booktitle                = {ICSE '03: Proceedings of the 25th International Conference on Software Engineering},
  Year                     = {2003},

  Address                  = {Washington, DC, USA},
  Pages                    = {187--197},
  Publisher                = {IEEE Computer Society},

  Abstract                 = {Step-wise refinement is a powerful paradigm for developing a complex program from a simple program by adding features incrementally. We present the AHEAD (Algebraic Hierarchical Equations for Application Design) model that shows how step-wise refinement scales to synthesize multiple programs and multiple non-code representations. AHEAD shows that software can have an elegant, hierarchical mathematical structure that is expressible as nested sets of equations. We review a tool set that supports AHEAD. As a demonstration of its viability, we have bootstrapped AHEAD tools solely from equational specifications, generating Java and non-Java artifacts automatically, a task that was accomplished only by ad hoc means previously.},
  ISBN                     = {0-7695-1877-X},
  Location                 = {Portland, Oregon},
  Review                   = {Presents AHEAD which offers ability to "refine" existing classes. Need to read properly. Important reference, as it is one of the leaders of the compositional approach.}
}

@InProceedings{Bauerdick2004,
  Title                    = {Detecting {OCL} Traps in the {UML} 2.0 Superstructure: An Experience Report},
  Author                   = {Hanna Bauerdick and Martin Gogolla and Fabian Gutsche},
  Booktitle                = {{UML} 2004 - The Unified Modeling Language. Model Languages and Applications. 7th International Conference, Lisbon, Portugal, October 11-15, 2004, Proceedings},
  Year                     = {2004},
  Editor                   = {Thomas Baar and Alfred Strohmeier and Ana Moreira and Stephen J. Mellor},
  Pages                    = {188--196},
  Publisher                = {Springer},
  Series                   = {LNCS},
  Volume                   = {3273},

  Owner                    = {andrew},
  Timestamp                = {2009.06.09}
}

@Misc{Beaton2005,
  Title                    = {{Eclipse Hints, Tips, and Random Musings}},

  Author                   = {Wayne Beaton},
  HowPublished             = {http://dev.eclipse.org/blogs/wayne/2005/10/03/fun-with-combinatorics/},
  Year                     = {last accessed August 2009},

  Journal                  = {Blog entry},
  Owner                    = {amcveigh},
  Review                   = {decent explanation of the main focus of the eclipse platform, including plugin architecture.},
  Timestamp                = {2006.05.15},
  Url                      = {http://wbeaton.blogspot.com/2005/10/fun-with-combinatorics.html}
}

@Electronic{Beck2001,
  Title                    = {Manifesto for agile software development},
  Author                   = {Beck, K.},
  Url                      = {http://agilemanifesto.org},
  Year                     = {2001},

  Owner                    = {amcveigh},
  Timestamp                = {2015.07.02}
}

@InProceedings{Bederson2000,
  Title                    = {Fisheye Menus},
  Author                   = {Bederson, Benjamin B.},
  Booktitle                = {UIST '00: Proceedings of the 13th annual ACM Symposium on User Interface Software and Technology},
  Year                     = {2000},

  Address                  = {New York, NY, USA},
  Pages                    = {217--225},
  Publisher                = {ACM},

  Doi                      = {http://doi.acm.org/10.1145/354401.354782},
  ISBN                     = {1-58113-212-3},
  Location                 = {San Diego, California, United States},
  Owner                    = {andrew},
  Timestamp                = {2009.06.09}
}

@Article{Belady1976,
  Title                    = {A Model of Large Program Development},
  Author                   = {Belady, L. A. and Lehman, M. M.},
  Journal                  = {IBM Syst. J.},
  Year                     = {1976},

  Month                    = sep,
  Number                   = {3},
  Pages                    = {225--252},
  Volume                   = {15},

  Acmid                    = {1661014},
  Address                  = {Riverton, NJ, USA},
  Doi                      = {10.1147/sj.153.0225},
  ISSN                     = {0018-8670},
  Issue_date               = {September 1976},
  Numpages                 = {28},
  Owner                    = {amcveigh},
  Publisher                = {IBM Corp.},
  Timestamp                = {2015.07.02},
  Url                      = {http://dx.doi.org/10.1147/sj.153.0225}
}

@Conference{Bennett2004,
  Title                    = {Software Evolution},
  Author                   = {Keith Bennett and David Budgen and Tony Hoare and Paul Layzell},
  Booktitle                = {Grand Challenges for Computing Research Conference Announcement},
  Year                     = {2004},

  Address                  = {University of Newcastle upon Tyne},

  Owner                    = {andrew},
  Review                   = {Fantastic article which puts evolution on a par with creation. Very good for my work.

Some great quotes:

"It is sometimes advocated that software should be designed to make change easy.
However enticing, this is hard. It seems impossible to predict change, and very often, a
successful system will change in ways which are inconceivable to the original designers."

"It does seem clear that two aspects are central to research:
? Architectural design for dependability and evolution: including issues relating to
structure, granularity of components and interfaces between them, as well as
architectural mismatches. We do not really understand how change and its
propagation can be contained."

Wow -- this dovetails neatly into my work.},
  Timestamp                = {2009.03.18},
  Url                      = {http://www.nesc.ac.uk/esi/events/Grand_Challenges/gcconf04/submissions.html}
}

@Article{Birsan2005,
  Title                    = {On Plug-Ins and Extensible Architectures},
  Author                   = {Birsan, Dorian},
  Journal                  = {ACM Queue},
  Year                     = {2005},
  Number                   = {2},
  Pages                    = {40--46},
  Volume                   = {3},

  Owner                    = {amcveigh},
  Publisher                = {ACM Press
},
  Timestamp                = {2006.05.15}
}

@InBook{Blandy2009,
  Title                    = {Beautiful Architecture: Leading Thinkers Reveal the Hidden Beauty in Software Design},
  Author                   = {Jim Blandy},
  Chapter                  = {11: GNU Emacs: Creeping Featurism Is a Strength},
  Editor                   = {Diomidis Spinellis and Georgios Gousios},
  Pages                    = {263-278},
  Publisher                = {O'Reilly Media, Inc.},
  Year                     = {2009},

  Owner                    = {andrew},
  Timestamp                = {2009.03.09}
}

@Misc{Blewitt2007,
  Title                    = {{A Comparison of Eclipse Extensions and OSGi Services}},

  Author                   = {Neil Blewitt},
  HowPublished             = {http://www.eclipsezone.com/articles/extensions-vs-services/},
  Year                     = {last accessed August 2009},

  Journal                  = {EclipseZone},
  Owner                    = {amcveigh},
  Timestamp                = {2007.07.09},
  Url                      = {http://www.eclipsezone.com/articles/extensions-vs-services/}
}

@Article{Boehm1988,
  Title                    = {A Spiral Model of Software Development and Enhancement},
  Author                   = {Boehm, Barry W.},
  Journal                  = {Computer},
  Year                     = {1988},

  Month                    = may,
  Number                   = {5},
  Pages                    = {61--72},
  Volume                   = {21},

  Acmid                    = {45801},
  Address                  = {Los Alamitos, CA, USA},
  Doi                      = {10.1109/2.59},
  ISSN                     = {0018-9162},
  Issue_date               = {May 1988},
  Numpages                 = {12},
  Owner                    = {amcveigh},
  Publisher                = {IEEE Computer Society Press},
  Timestamp                = {2015.07.02},
  Url                      = {http://dx.doi.org/10.1109/2.59}
}

@Article{Bosch1999,
  Title                    = {Superimposition: A Component Adaptation Technique},
  Author                   = {Jan Bosch},
  Journal                  = {Information and Software Technology},
  Year                     = {1999},

  Month                    = {25~March},
  Number                   = {5},
  Pages                    = {257--273},
  Volume                   = {41},

  Url                      = {citeseer.ist.psu.edu/281749.html}
}

@Article{Bosch2000,
  Title                    = {Object-oriented Framework-based Software Development: Problems and Experiences},
  Author                   = {Bosch, Jan and Molin, Peter and Mattsson, Michael and Bengtsson, PerOlof},
  Journal                  = {ACM Comput. Surv.},
  Year                     = {2000},

  Month                    = mar,
  Number                   = {1es},
  Volume                   = {32},

  __markedentry            = {[amcveigh:6]},
  Acmid                    = {351939},
  Address                  = {New York, NY, USA},
  Articleno                = {3},
  Doi                      = {10.1145/351936.351939},
  ISSN                     = {0360-0300},
  Issue_date               = {March 2000},
  Keywords                 = {object-oriented frameworks, software reuse},
  Owner                    = {amcveigh},
  Publisher                = {ACM},
  Timestamp                = {2015.07.06},
  Url                      = {http://doi.acm.org/10.1145/351936.351939}
}

@Book{Box1997,
  Title                    = {Essential COM},
  Author                   = {Box, D.},
  Publisher                = {Addison-Wesley Professional},
  Year                     = {1997},

  Owner                    = {amcveigh},
  Timestamp                = {2006.05.30}
}

@InProceedings{Bracha1990,
  Title                    = {Mixin-Based Inheritance},
  Author                   = {Bracha, G. and Cook, W.},
  Booktitle                = {OOPSLA/ECOOP '90: Proceedings of the European Conference on Object-Oriented Programming Systems, Languages, and Applications},
  Year                     = {1990},

  Address                  = {New York, NY, USA},
  Pages                    = {303--311},
  Publisher                = {ACM Press},

  Doi                      = {http://doi.acm.org/10.1145/97945.97982},
  ISBN                     = {0-201-52430-X},
  Location                 = {Ottawa, Canada}
}

@TechReport{Bruce1998,
  Title                    = {Modules in LOOM: Classes are Not Enough (extended abstract)},
  Author                   = {Kim B. Bruce and Leaf Petersen and Joseph Vanderwaart},
  Institution              = {Williams College},
  Year                     = {1998},

  Owner                    = {amcveigh},
  Timestamp                = {2007.07.10},
  Url                      = {http://www.cs.williams.edu/kim}
}

@TechReport{Buchi1999,
  Title                    = {The Greybox Approach: When Blackbox Specifications Hide Too Much},
  Author                   = {Buchi,, Martin and Weck,, Wolfgang},
  Institution              = {Turku Centre for Computer Science},
  Year                     = {1999},

  Abstract                 = {Development of different parts of large software systems by separate teams, replacement of individual software parts during maintenance without changing other parts, and marketing of independently developed software components require interface descriptions. Interoperation is impossible without sufficient description; only abstraction leaves room for alternate implementations. Specifications that only relate the state prior to service invocation (precondition) to that after service termination (postcondition) do not sufficiently capture external calls made during operation execution. If other methods called in the specification cannot be fully specified, it is not sufficient that the implementation only performs the specified state transformation. The implementation must also make the prescribed external calls in the respective states. We show how to specify both state change and external call sequences using simple extensions of programming languages. Furthermore, we give a formal definition of the correctness of implementations with respect to such specifications and show how to prove correctness in practice with data refinement in context.},
  Publisher                = {Turku Centre for Computer Science},
  Source                   = {http://www.ncstrl.org:8900/ncstrl/servlet/search?formname=detail\&id=oai%3Ancstrlh%3Atucs_fi%3Ancstrl.tucs.fi%2F%2FTUCS-TR-297}
}

@Book{Budgen2003,
  Title                    = {Software Design},
  Author                   = {David Budgen},
  Publisher                = {Addison Wesley},
  Year                     = {2003},
  Edition                  = {2nd},
  Month                    = {July},

  Owner                    = {andrew},
  Review                   = {used for the good pattern description},
  Timestamp                = {2009.06.15}
}

@InBook{Bullen2005,
  Title                    = {Professional Excel Development: The Definitive Guide to Developing Applications Using Microsoft Excel and VBA},
  Author                   = {Stephen Bullen and Rob Bovey and John Green},
  Chapter                  = {5: Function, General and Application-Specific Add-Ins},
  Pages                    = {109-142},
  Publisher                = {Addison Wesley},
  Year                     = {2005},

  Owner                    = {andrew},
  Timestamp                = {2009.03.09}
}

@Book{Buschmann1996,
  Title                    = {Pattern-Oriented Software Architecture, Volume 1: A System of Patterns},
  Author                   = {Buschmann, F. and Meunier, R. and Rohnert, H. and Sommerlad, P. and Stal, M. and Sommerlad, P.},
  Publisher                = {John Wiley \& Sons; 1st edition (August 8, 1996)},
  Year                     = {1996},

  ISSN                     = {0471958697},
  Keywords                 = {Buschmann,F.; Meunier,R.; Rohnert,H.; Sommerlad,P.; Stal,M.; Sommerlad,P.; Stal,M.},
  Owner                    = {amcveigh},
  Refid                    = {59},
  Timestamp                = {2006.03.14}
}

@Book{Chappell1996,
  Title                    = {Understanding ActiveX and OLE},
  Author                   = {Chappell, D.},
  Publisher                = {Microsoft Press},
  Year                     = {1996},

  Owner                    = {amcveigh},
  Timestamp                = {2006.05.30}
}

@InProceedings{Chatley2004a,
  Title                    = {Predictable Dynamic Plugin Systems},
  Author                   = {R. Chatley and S. Eisenbach and J. Kramer and J. Magee and S. Uchitel},
  Booktitle                = {FASE 2004 : Fundamental Approaches to Software Engineering},
  Year                     = {2004},
  Pages                    = {129--143},

  Owner                    = {andrew},
  Timestamp                = {2009.07.27}
}

@Article{Chatley2004,
  Title                    = {MagicBeans: A Platform for Deploying Plugin Components},
  Author                   = {Chatley, R. and Eisenbach, S. and Magee, J.},
  Journal                  = {Component Deployment},
  Year                     = {2004},
  Pages                    = {97--112},
  Volume                   = {3083},

  Abstract                 = {Plugins are optional components which can be used to enable the dynamic construction of flexible and complex systems, passing as much of the configuration management effort as possible to the system rather than the user, allowing graceful upgrading of systems over time without stopping and restarting. Using plugins as a mechanism for evolving applications is appealing, but current implementations have limited functionality. In this paper we present a framework that supports the construction and evolution of applications with a plugin architecture},
  Address                  = {Univ London Imperial Coll Sci Technol \& Med, Dept Comp, London SW7 2AZ, England},
  Comment                  = {Times Cited: 0 Article English Chatley, R Univ London Imperial Coll Sci Technol & Med, Dept Comp, 180 Queensgate, London SW7 2AZ, England Cited References Count: 23
Read part of this to see what type of plugin model Rob was modelling. The model is not hierarchical, and is based on auto-matching plugins based on (a) the interfaces exposed in Java by the implementation and (b) the running model. Develops a formal model in Alloy for the plugin approach. Cardinality / multiplicity is used. Probably worth revisiting to re-examine the Alloy model and the 1st order logical statements about the model.
2005-10-04},
  ISSN                     = {0302-9743},
  Keywords                 = {component, configuration, SYSTEMS},
  Owner                    = {amcveigh},
  Refid                    = {1},
  Timestamp                = {2006.03.14},
  Url                      = {ISI:000221782700007}
}

@InProceedings{Chatley2003,
  Title                    = {Modelling a Framework for Plugins},
  Author                   = {Chatley, Robert and Eisenbach, Susan and Magee, Jeff},
  Booktitle                = {Specification and Verification of Component-Based Systems},
  Year                     = {2003},

  Url                      = {http://pubs.doc.ic.ac.uk/ModellingPluginFramework/}
}

@Article{Ping2004,
  Title                    = {Differencing and Merging Within an Evolving Product Line Architecture},
  Author                   = {Chen, P.H. and Critchlow, M. and Garg, A. and Van der Westhuizen, C. and van der Hoek, A.},
  Journal                  = {Software Product-Family Engineering},
  Year                     = {2004},
  Pages                    = {269--281},
  Volume                   = {3014},

  Owner                    = {amcveigh},
  Review                   = {looks at diffing between 2 architectures and then merging back into a different line. needs to work out diffs, but merging is simplistic.},
  Timestamp                = {2006.05.15}
}

@InProceedings{Chern2006,
  Title                    = {Refactoring with Difference-Based Modules: An Experience Report},
  Author                   = {Rick Chern},
  Booktitle                = {CPSC 511 Mini Conference},
  Year                     = {2006},

  Owner                    = {amcveigh},
  Timestamp                = {2007.07.09},
  Url                      = {http://www.cs.ubc.ca/~kdvolder/CPSC511/conference-program.html}
}

@InProceedings{Clarke2001,
  Title                    = {Composition Patterns: An Approach to Designing Reusable Aspects},
  Author                   = {Clarke, S. and Walker, R.J.},
  Booktitle                = {Proceedings of the 23rd International Conference on Software Engineering},
  Year                     = {2001},

  Address                  = {Toronto, Ontario, Canada},
  Pages                    = {5--14},
  Publisher                = {IEEE Computer Society},

  Abstract                 = {Requirements such as distribution or tracing have an impact on multiple classes in a system. They are cross-cutting requirements, or aspects. Their support is, by necessity, scattered across those multiple classes. A look at an individual class may also show support for cross-cutting requirements tangled up with the core responsibilities of that class. Scattering and tangling make object-oriented software difficult to understand, extend and reuse. Though design is an important activity within the software lifecycle with well-documented benefits, those benefits are reduced when cross-cutting requirements are present. This paper presents a means to mitigate these problems by separating the design of cross-cutting requirements into composition patterns. Composition patterns require extensions to the UML, and are based on a combination of the subject-oriented model for composing separate, overlapping designs, and UML templates. This paper also demonstrates how composition patterns map to one programming model that provides a solution for separation of cross-cutting requirements in code-aspect-oriented programming. This mapping serves to illustrate that separation of aspects may be maintained throughout the software lifecycle.},
  Comment                  = {Looks at the idea of templated design concepts which are expressed as independent design models. Main aim is to assemble programs out of these. Doesn't address conflicts directly. Has a behavioural approach based on sequence diagrams. Deals with merging.
2006-02-01},
  ISSN                     = {0-7695-1050-7},
  Owner                    = {amcveigh},
  Refid                    = {66},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=381474&coll=Portal&dl=GUIDE&CFID=70282723&CFTOKEN=98894328#}
}

@Book{Clements2001,
  Title                    = {Software Product Lines: Practices and Patterns},
  Author                   = {Paul C. Clements and Linda Northrop},
  Publisher                = {Addison-Wesley},
  Year                     = {2001},
  Month                    = {August},
  Series                   = {SEI Series in Software Engineering},

  Abstract                 = {(...) In providing a comprehensive set of practices and patterns, this book defines and explores the key activities for software product line development and explains specific practice areas in engineering, technical management, and organizational management. (...)},
  Available                = {1},
  Category                 = {General},
  Interhash                = {cd614386b56e1a8c1d8db57c1a505411},
  Intrahash                = {18cfb5d792f79120506c1d5440baad7a},
  Newinversion             = {2.19},
  Owner                    = {andrew},
  Timestamp                = {2009.06.24}
}

@Article{Codenie1997,
  Title                    = {From Custom Applications to Domain-Specific Frameworks},
  Author                   = {Codenie, W. and De Hondt, K. and Steyaert, P. and Vercammen, A.},
  Journal                  = {Communications of the ACM},
  Year                     = {1997},
  Number                   = {10},
  Pages                    = {70--77},
  Volume                   = {40},

  Abstract                 = {As a provider of broadcast planning software for television stations, we have to create highly customized software while maintaining the quality standards of an offthe- shelf product. Framework technology plays a strategic role in our business, because there are many similarities in the complex broadcast planning processes of different stations, yet a standard product would satisfy only 70% to 80% of the needs of a typical station. Thanks to frameworks, customers can be offered a standard product that is easily customizable by a small team of software engineers in a cost-effective way. Moreover, the adaptive nature of frameworks provides another advantage; like any other business, television stations need to respond to new and rapidly changing market opportunities. They are faced with rapidly evolving hardware (e.g., digital video broadcasting, distributed video production) and rapid evolution of their products (e.g., interactive TV, electronic program guides). These changes require more malleable software. For broadcasters, the ability to cope with change more efficiently than from similar off-the-shelf applications results in a competitive advantage.},
  Comment                  = {Contains an excellent description of some reuse problems of frameworks. Also defines reuse operators, and looks at a matrix of changes by the extender and the developer of the framework. Extremely relevant and very clear.
2005-10-25},
  ISSN                     = {0001-0782},
  Owner                    = {amcveigh},
  Publisher                = {ACM Press},
  Refid                    = {35},
  Timestamp                = {2006.03.14}
}

@Article{Cortes2003,
  Title                    = {Using Refactoring and Unification Rules to Assist Framework Evolution},
  Author                   = {Cortes, M. and Fontoura, M. and Lucena, C.},
  Journal                  = {ACM SIGSOFT Software Engineering Notes},
  Year                     = {2003},
  Number                   = {6},
  Pages                    = {1--1},
  Volume                   = {28},

  Abstract                 = {Although object-oriented software development has experienced the benefits of using frameworks, a thorough understanding of how to change them to meet evolving requirement needs is still object of research. Therefore framework development is very expensive, not only because of the intrinsic difficulty related to capturing the domain theory, but also because of the lack of appropriate methods and techniques to support the evolution and redesign of the framework architecture. This paper proposes the use of refactoring and unification rules to assist framework evolution. The approach is illustrated through the JUnit testing framework.},
  Comment                  = {Looks directly at the evolution of frameworks, which makes this relevant to my work. Proposes use of refactoring, which are behavior preserving transformations, and unifications, which are ways to incorporate new abstractions into a framework structure. This works by taking 2 forked versions of a framework (called architectural drift) and unifying them through transformations.
2005-10-03},
  ISSN                     = {0163-5948},
  Owner                    = {amcveigh},
  Publisher                = {ACM Press},
  Refid                    = {46},
  Timestamp                = {2006.03.14}
}

@InProceedings{Councill2001,
  Title                    = {Definition of a Software Component and its Elements},
  Author                   = {Councill,, Bill and Heineman,, George T.},
  Booktitle                = {Component-Based Software Engineering: Putting the Pieces Together},
  Year                     = {2001},

  Address                  = {Boston, MA, USA},
  Pages                    = {5--19},
  Publisher                = {Addison-Wesley Longman Publishing Co., Inc.},

  Book                     = {Component-based software engineering: putting the pieces together},
  ISBN                     = {0-201-70485-4}
}

@Book{Cox1991,
  Title                    = {Object-Oriented Programming: An Evolutionary Approach},
  Author                   = {Cox, B.J. and Novobilski, A.J.},
  Publisher                = {Addison-Wesley},
  Year                     = {1991},

  Owner                    = {amcveigh},
  Timestamp                = {2006.05.30}
}

@InProceedings{Crane1995,
  Title                    = {Configuration Management for Distributed Software Services},
  Author                   = {Crane,, S. and Dulay,, N. and Foss{\aa},, H. and Kramer,, J. and Magee,, J. and Sloman,, M. and Twidle,, K.},
  Booktitle                = {Proceedings of the Fourth International Symposium on Integrated Network Management},
  Year                     = {1995},

  Address                  = {London, UK, UK},
  Pages                    = {29--42},
  Publisher                = {Chapman \& Hall, Ltd.},

  ISBN                     = {0-412-71570-8},
  Owner                    = {andrew},
  Review                   = {interesting paper on SysMan and the active badge system. has first details I've seen on 1st party versus thirdy party versus dynamic bindings in an ADL.},
  Timestamp                = {2009.04.15}
}

@InProceedings{Dashofy2007,
  Title                    = {ArchStudio 4: An Architecture-Based Meta-Modeling Environment},
  Author                   = {Dashofy,, Eric and Asuncion,, Hazel and Hendrickson,, Scott and Suryanarayana,, Girish and Georgas,, John and Taylor,, Richard},
  Booktitle                = {ICSE COMPANION '07: Companion to the proceedings of the 29th International Conference on Software Engineering},
  Year                     = {2007},

  Address                  = {Washington, DC, USA},
  Pages                    = {67--68},
  Publisher                = {IEEE Computer Society},

  Doi                      = {http://dx.doi.org/10.1109/ICSECOMPANION.2007.21},
  ISBN                     = {0-7695-2892-9},
  Owner                    = {andrew},
  Timestamp                = {2009.04.04}
}

@Misc{Dashofy2002,
  Title                    = {{Variants Extension for xADL 2.0}},

  Author                   = {Eric M. Dashofy},
  HowPublished             = {http://www.isr.uci.edu/projects/xarchuci/ext-overview.html},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.04.04},
  Url                      = {http://www.isr.uci.edu/projects/xarchuci/ext-overview.html#variants}
}

@Article{Dashofy2005,
  Title                    = {A Comprehensive Approach for the Development of Modular Software Architecture Description Languages},
  Author                   = {Dashofy,, Eric M. and Hoek,, Andr\'{e} van der and Taylor,, Richard N.},
  Journal                  = {ACM Transactions on Software Engineering and Methodology (TOSEM)},
  Year                     = {2005},
  Number                   = {2},
  Pages                    = {199--245},
  Volume                   = {14},

  Address                  = {New York, NY, USA},
  Doi                      = {http://doi.acm.org/10.1145/1061254.1061258},
  ISSN                     = {1049-331X},
  Owner                    = {andrew},
  Publisher                = {ACM},
  Timestamp                = {2009.04.04}
}

@Misc{Delap2006,
  Title                    = {{Understanding How Eclipse Plug-Ins Work with OSGi}},

  Author                   = {Scott Delap},
  HowPublished             = {http://www.ibm.com/developerworks/library/os-ecl-osgi/index.html},
  Year                     = {2009},

  Journal                  = {IBM Developerworks},
  Owner                    = {amcveigh},
  Timestamp                = {2007.06.25},
  Url                      = {http://www.ibm.com/developerworks/library/os-ecl-osgi/index.html},
  Volume                   = {http://www.ibm.com/developerworks/library/os-ecl-osgi/index.html}
}

@Misc{DeMichiel2006,
  Title                    = {{JSR-000220 Enterprise JavaBeans 3.0}},

  Author                   = {Linda DeMichiel and Michael Keith},
  HowPublished             = {http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Review                   = {The EJB 3.0 spec},
  Timestamp                = {2009.04.01},
  Url                      = {http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html}
}

@Misc{Fireheadaches2005,
  Title                    = {{Firefox 1.5 Upgrade Brings Extension Headaches}},

  Author                   = {{DesktopLinux.com}},
  HowPublished             = {http://www.desktoplinux.com/news/NS2432314568.html},
  Year                     = {last accessed 2009},

  Owner                    = {amcveigh},
  Timestamp                = {2007.06.25},
  Url                      = {http://www.desktoplinux.com/news/NS2432314568.html},
  Volume                   = {http://www.desktoplinux.com/news/NS2432314568.html}
}

@InProceedings{Doucet2005,
  Title                    = {Typing Abstractions and Management in a Component Framework},
  Author                   = {Doucet, F. and Shukla, S. and Gupta, R.},
  Booktitle                = {Asia and South Pacific Design Automation Conference},
  Year                     = {2005},
  Pages                    = {--},

  Abstract                 = {We consider the type inference problems in a compositional design environment where the components are automatically instantiated from pre-existing C++-based intellectual property (IP) libraries. We present a component integration language based on scripting for design specification. Our focus is architectural aspects in specification that uses aggregation- as opposed to the more commonly used inheritance- for composition of components. Our approach simplifies architectural specification by employing a type inference and typemanagement environment. We show that the type inference problem is NP-complete. We present a heuristic based on code generation and parameterization to solve the type inference for IP selection in our C++-based composition environment. We have implemented the composition and type management in the BALBOA framework. The results show the utility of our approach.},
  Comment                  = {need to read fully. uses type inferencing + type constraints to propagage types and infer them into connectors and parts of nested components.},
  Keywords                 = {component, SPECIFICATION},
  Owner                    = {amcveigh},
  Refid                    = {52},
  Timestamp                = {2006.03.14},
  Url                      = {http://mesl.ucsd.edu/balboa/}
}

@TechReport{DSE1997,
  Title                    = {The Darwin Language, Version 3d.},
  Author                   = {{DSE, Imperial College}},
  Institution              = {Imperial College},
  Year                     = {1997},

  File                     = {darwin-lang.pdf:http\://www-dse.doc.ic.ac.uk/Software/Darwin/darwin-lang.pdf:PDF},
  Owner                    = {amcveigh},
  Timestamp                = {2007.07.09},
  Url                      = {http://www-dse.doc.ic.ac.uk/Software/Darwin/darwin-lang.pdf}
}

@Misc{Consortium2006,
  Title                    = {{Platform Plug-in Developer Guide: OSGi Bundle Manifest Headers}},

  Author                   = {{Eclipse Foundation}},
  HowPublished             = {http://help.eclipse.org/stable/index.jsp?topic=/org.eclipse.platform.doc.isv/\\\-reference/misc/bundle\_manifest.html},
  Year                     = {2009},

  Journal                  = {Eclipse 3.2.1 Online Help},
  Owner                    = {amcveigh},
  Timestamp                = {2007.06.25},
  Url                      = {http://help.eclipse.org/help32/index.jsp?topic=/org.eclipse. platform.doc.isv/reference/misc/bundle\_manifest.html},
  Volume                   = {http://help.eclipse.org/help32/index.jsp?topic=/org.eclipse. platform.doc.isv/reference/misc/bundle\_manifest.html}
}

@Misc{Foundation,
  Title                    = {{Rich client platform (RCP) applications}},

  Author                   = {{Eclipse Foundation}},
  HowPublished             = {http://www.eclipse.org/community/rcp.php},
  Year                     = {2009},

  Owner                    = {andrew},
  Timestamp                = {2009.06.19},
  Url                      = {http://www.eclipse.org/community/rcp.php}
}

@Misc{GEF2009,
  Title                    = {{Eclipse Graphical Editing Framework (GEF)}},

  Author                   = {{Eclipse Foundation}},
  HowPublished             = {http://www.eclipse.org/gef/},
  Year                     = {2009},

  Owner                    = {andrew},
  Timestamp                = {2009.06.09},
  Url                      = {http://www.eclipse.org/gef/}
}

@InProceedings{Engels1997,
  Title                    = {A View-Oriented Approach to System Modelling Based on Graph Transformation},
  Author                   = {Gregor Engels and Reiko Heckel and Gabi Taentzer and Hartmut Ehrig},
  Booktitle                = {ESEC '97/FSE-5: Proceedings of the 6th European Conference},
  Year                     = {1997},

  Address                  = {New York, NY, USA},
  Pages                    = {327--343},
  Publisher                = {Springer-Verlag New York, Inc.},

  Abstract                 = {The idea of a combined reference model- and view-based
specification approach has been proposed recently in the software engineering
community. In this paper we present a specification technique
based on graph transformations which supports such a development approach.
The use of graphs and graph transformations supports an intuitive
understanding and an integration of static and dynamic aspects
on a well-defined semantical base. On this background, formal notions
of view and view relation are developed and the behaviour of views is
described by a loose semantics. We define a construction for automatic
view integration which assumes that the dependencies between different
views are described by a reference model. The views and the reference
model are kept consistent manuahy, which is the task of a model manager.
AII concepts and results are illustrated at the weII-known example
of a banking system.},
  Doi                      = {http://doi.acm.org/10.1145/267895.267919},
  ISBN                     = {3-540-63531-9},
  Location                 = {Zurich, Switzerland},
  Review                   = {discusses viewpoint engineering. this is very much relevant to my approach.

this is a fairly simple approach, where views are defined on a reference model and these are then merged back into a consistent sysstem model.

views can rename or add -- no deletion and it is not hierarchical.},
  Timestamp                = {2006.08.07}
}

@InProceedings{Erdogmus1998,
  Title                    = {Representing Architectural Evolution},
  Author                   = {Erdogmus, H.},
  Booktitle                = {Proceedings of the 1998 Conference of the Centre for Advanced Studies on Collaborative Research},
  Year                     = {1998},

  Address                  = {Toronto, Ontario, Canada},
  Pages                    = {11--},
  Publisher                = {IBM Press},

  Abstract                 = {Software engineers informally use block diagrams with boxes and lines to express system architectures. Diagrammatic representations of this type are also found in many speci�- cation techniques. However, rarely are architectural documents containing such representations systematically maintained; as a system evolves, architectural documents become obsolete, and the design history of the system is ultimately lost. Additionally, box-and-line representations used in these documents do not possess a precise semantics invariant across the di�erent techniques that rely on them. This paper addresses expression of system evolution at the architectural level based on a formal model of box-and-line diagrams. The formal model (a) provides semantic uniformity and precision; and (b) allows evolutionary steps to be represented as structural transformations. Interesting classes of such transformations are characterized in terms of the underlying operators. With these tools, the architectural evolution of a system is captured as a directed acyclic graph of baselines, where each baseline consists of a system of box-and-line diagrams, and is mapped to a successor baseline by a set of structural transformations. It is also shown how familiar design concepts|such as extension, abstraction, and structural re�nement| can be formalized in simple terms within the framework developed.},
  Comment                  = {Not fully read yet. Looks at a way to represent architectural evolution by the transformation of component-connector graphs. Attempts to generalise this across component systems with different semantics. Introduces different types of structural transformations, where the intent is exposed.
!read fully},
  Owner                    = {amcveigh},
  Refid                    = {41},
  Timestamp                = {2006.03.14}
}

@Article{Eriksson2006,
  Title                    = {Software Product Line Modeling Made Practical},
  Author                   = {Magnus Eriksson and J\"{u}rgen B\"{o}rstler and Kjell Borg},
  Journal                  = {Communications of the ACM},
  Year                     = {2006},
  Number                   = {12},
  Pages                    = {49--54},
  Volume                   = {49},

  Address                  = {New York, NY, USA},
  Doi                      = {http://doi.acm.org/10.1145/1183236.1183265},
  ISSN                     = {0001-0782},
  Publisher                = {ACM Press}
}

@InProceedings{Escoffier2007,
  Title                    = {Dynamically Adaptable Applications with iPOJO Service Components},
  Author                   = {Clement Escoffier and Richard S. Hall},
  Booktitle                = {6th International Symposium on Software Composition (SC 2007)},
  Year                     = {2007},

  Abstract                 = {Traditional component models and frameworks simplified software
system development by enabling developers to break software systems into
independent pieces with well-defined interfaces. This approach led to looser
coupling among the system pieces and enhanced possibilities for reuse. While the
component-based approach led to advancements in the software development
process, it still has its limitations. In particular, after a component-based
application is developed and deployed it typically is a monolithic and static
configuration of components. The advent of service-oriented component (SOC),
the rise in popularity of consumer devices, and the ubiquity of connectivity have
fostered a growing interest in applications that react dynamically to changes in
the availability of various services. To simplify the creation of such dynamic
software systems, it is possible to borrow concepts from SOC and include them
into a component model, resulting in a service-oriented component model that
specifically supports dynamically adaptable applications. This paper presents
iPOJO, a service-oriented component framework to help developers implement
dynamically adaptable software systems.},
  Journal                  = {6th International Symposium on Software Composition (SC 2007)},
  Owner                    = {amcveigh},
  Review                   = {this is one I reviewed for the Jeffs.

It discusses the merging of service oriented (dynamic) and component oriented ideas. it has clear language, and it proposes to deal with disappearing leaf services by repeatedly moving upwards and disabling upward services. could end up with a very fragile architecture.

benefit over declarative services is unclear...},
  Timestamp                = {2007.04.02}
}

@InProceedings{Evans1999a,
  Title                    = {Meta-Modelling Semantics of UML: The pUML Approach},
  Author                   = {Evans, Andy and Kent, Stuart},
  Booktitle                = {2nd International Conference on the Unified Modeling Language},
  Year                     = {1999},
  Month                    = {January},
  Pages                    = {140--155},

  Abstract                 = {The current UML semantics documentation has made a significant step towards providing a precise description of the UML. However, at present the semantic model it proposes only provides a description of the language's syntax and well-formedness rules. The meaning of the language, which is mainly described in English, is too informal and unstructured to provide a foundation for developing formal analysis and development techniques. Another problem is the scope of the model, which is both complex and large. This paper describes work currently being undertaken by the precise UML group (<SPAN style='background:silver;'>pUML</SPAN>), an international group of researchers and practitioners, to address these problems. A formalisation strategy is presented which concentrates on giving a precise denotational semantics to core elements of UML. This is illustrated through the development of precise definitions of two important concepts: generalization and packages. Finally, a viewpoint architecture is proposed as a means of providing improved separation of concerns in the semantics definition.},
  Citeulike-article-id     = {197546},
  Journal                  = {Lecture Notes in Computer Science},
  Keywords                 = {semantic, uml},
  Owner                    = {andrew},
  Posted-at                = {2005-05-12 15:53:46},
  Priority                 = {0},
  Timestamp                = {2009.06.09},
  Url                      = {http://www.metapress.com/link.asp?id=NYU563JRFGC86CYW}
}

@InProceedings{Evans1999,
  Title                    = {Zones, Contracts and Absorbing Changes: An Approach to Software Evolution},
  Author                   = {Evans, H. and Dickman, P.},
  Booktitle                = {Proceedings of the 14th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
  Year                     = {1999},

  Address                  = {Denver, Colorado, United States},
  Pages                    = {415--434},
  Publisher                = {ACM Press},

  Abstract                 = {This paper describes a novel approach to managing the evolution of distributed, persistent systems at run-time. This is achieved by partitioning a system into disjoint zones, each of which can be evolved without affecting code in any other. Contracts are defined between zones, making type-level interdependencies and inter-zone communication explicit. Programmer supplied code is added to the running system, at the boundary between zones, to constrain the scope of changes. A change methodology is presented which the software engineer uses to help describe and manage the evolution of the system. Knowledge of the application semantics is essential when evolving a system and our approach allows the engineer to concentrate on these semantic aspects of change. Our Java-based demonstration platform and methodology reduce or remove some of the burdensome tasks the software engineer is normally expected to perform when changing a system, making evolution more tractable.},
  Comment                  = {Defines several constructs to allow a system to evolve at runtime. A system is partitioned into several disjoint zones. Each zone has its own types. It communicates with other zones by means of service level interfaces, which are described by "contracts". These contracts are declarative, and describe how to translate information passed between zones. To evolve a zone, all processes into the zone are exited (by buffering comms maybe?) and then the zone can be fully evolved.
2005-11-03},
  ISSN                     = {1-58113-238-7},
  Keywords                 = {SYSTEMS},
  Owner                    = {amcveigh},
  Refid                    = {42},
  Timestamp                = {2006.03.14},
  Url                      = {http://doi.acm.org/10.1145/320384.320430}
}

@InProceedings{Fahmy2000,
  Title                    = {Using Graph Rewriting to Specify Software Architectural Transformations},
  Author                   = {Fahmy, H. and Holt, R.C.},
  Booktitle                = {Proceedings of the The Fifteenth IEEE International Conference on Automated Software Engineering (ASE'00)},
  Year                     = {2000},
  Pages                    = {187--},
  Publisher                = {IEEE Computer Society},

  Abstract                 = {In order to understand, analyze and possibly modify software, we commonly examine and manipulate its architecture. For example, we may want to examine the architecture at different levels of abstraction or repair the architecture if it has deviated from our mental model of the software. We can view such manipulations as architectural transformations, and more specifically, as graph transformations. In this paper, we use graph rewriting to specify these transformations so that we can work towards automating them. Specifically, we use the PROGRES tool to formulate executable graph-rewriting specifications for various architectural transformations in order to demonstrate the strengths of using graph rewriting. We have applied our executable specifications to small graphs and our results confirm that graph rewriting offers a high-level visual notation that can be used to neatly specify graph modifications, as well as supporting prototype implementations. It also provides a convenient and intuitive framework for exploring various architectural transformations},
  Comment                  = {Nice paper that deswcribes how graph rewriting can be used to specify simple architectural transformations. A basic example is worked through that shows how "unexpected" intermodule dependencies can be detected and repaired.
2005-11-07},
  ISSN                     = {0-7695-0710-7},
  Keywords                 = {SPECIFICATION},
  Owner                    = {amcveigh},
  Refid                    = {44},
  Timestamp                = {2006.03.14},
  Url                      = {http://csdl2.computer.org/persagen/DLAbsToc.jsp?resourcePath=/dl/proceedings/&toc=comp/proceedings/ase/2000/0710/00/0710toc.xml&DOI=10.1109/ASE.2000.873663}
}

@Article{Fayad1997,
  Title                    = {Object-Oriented Application Frameworks},
  Author                   = {Fayad, M.E. and Schmidt, D.C.},
  Journal                  = {Communications of the ACM},
  Year                     = {1997},

  Month                    = oct,
  Number                   = {10},
  Pages                    = {32--38},
  Volume                   = {40},

  Abstract                 = {Computing power and network bandwidth have increased dramatically over the past decade, yet the design and implementation of complex software remain expensive and error-prone. Much of the cost and effort stems from the continuous rediscovery and reinvention of core concepts and components across the software industry. In particular, the growing heterogeneity of hardware architectures and diversity of operating system and communication platforms make it difficult to build correct, portable, efficient, and inexpensive applications from scratch.},
  Address                  = {WASHINGTON UNIV,DEPT COMP SCI,ST LOUIS,MO 63130},
  Comment                  = {Times Cited: 48 Article English Fayad, M. E UNIV NEVADA,COLL ENGN,RENO,NV 89557 Cited References Count: 9
Very clear introductory paper to frameworks. Defines (informally) a framework, inversion of control, framework reuse, white vs grey vs black box frameworks and benefits of frameworks. Discusses the strengths and weaknesses of the approach. Mentions current frameworks suffer from an inability to define control flow explicitly.
2005-10-23},
  ISSN                     = {0001-0782},
  Keywords                 = {component},
  Owner                    = {amcveigh},
  Refid                    = {33},
  Timestamp                = {2006.03.14}
}

@Article{Feldman2005,
  Title                    = {A Conversation with Alan Kay},
  Author                   = {Feldman, Stuart},
  Journal                  = {ACM Queue},
  Year                     = {2005},
  Number                   = {9},
  Pages                    = {20--30},
  Volume                   = {2},

  Address                  = {New York, NY, USA},
  Doi                      = {http://doi.acm.org/10.1145/1039511.1039523},
  ISSN                     = {1542-7730},
  Owner                    = {andrew},
  Publisher                = {ACM},
  Timestamp                = {2009.07.31}
}

@InProceedings{Figueiredo2008,
  Title                    = {Evolving Software Product Lines with Aspects: An Empirical Study on Design Stability},
  Author                   = {Figueiredo,, Eduardo and Cacho,, Nelio and Sant'Anna,, Claudio and Monteiro,, Mario and Kulesza,, Uira and Garcia,, Alessandro and Soares,, Sergio and Ferrari,, Fabiano and Khan,, Safoora and Castor Filho,, Fernando and Dantas,, Francisco},
  Booktitle                = {ICSE '08: Proceedings of the 30th International Conference on Software Engineering},
  Year                     = {2008},

  Address                  = {New York, NY, USA},
  Pages                    = {261--270},
  Publisher                = {ACM},

  Abstract                 = {Software product lines (SPLs) enable modular, large-scale reuse through a software architecture addressing multiple core and varying features. To reap the benefits of SPLs, their designs need to be stable. Design stability encompasses the sustenance of the product line's modularity properties in the presence of changes to both the core and varying features. It is usually assumed that aspect-oriented programming promotes better modularity and changeability of product lines than conventional variability mechanisms, such as conditional compilation. However, there is no empirical evidence on its efficacy to prolong design stability of SPLs through realistic development scenarios. This paper reports a quantitative study that evolves two SPLs to assess various design stability facets of their aspect-oriented implementations. Our investigation focused upon a multi-perspective analysis of the evolving product lines in terms of modularity, change propagation, and feature dependency. We have identified a number of scenarios which positively or negatively affect the architecture stability of aspectual SPLs.},
  Doi                      = {http://doi.acm.org/10.1145/1368088.1368124},
  ISBN                     = {978-1-60558-079-1},
  Location                 = {Leipzig, Germany},
  Review                   = {looks at how they evolved a product line using aspects. interestingly, it discusses the need to alter the underlying source to introduce aspect cutpoints!

good case study, shows limitations of aspects somewhat as an evolutionary mechanism.}
}

@TechReport{Filman2000,
  Title                    = {Aspect-Oriented Programming is Quantification and Obliviousness},
  Author                   = {Robert E. Filman and Daniel P. Friedman},
  Institution              = {RIACS},
  Year                     = {2000},

  Publisher                = {RIACS},
  Source                   = {http://www.ncstrl.org:8900/ncstrl/servlet/search?formname=detail\&id=oai%3ARIACS%3A00000046}
}

@InProceedings{Findler1998,
  Title                    = {Modular Object-Oriented Programming with Units and Mixins},
  Author                   = {Robert Bruce Findler and Matthew Flatt},
  Booktitle                = {ICFP '98: Proceedings of the third ACM SIGPLAN International Conference on Functional Programming},
  Year                     = {1998},

  Address                  = {New York, NY, USA},
  Pages                    = {94--104},
  Publisher                = {ACM},

  Doi                      = {http://doi.acm.org/10.1145/289423.289432},
  ISBN                     = {1-58113-024-4},
  Location                 = {Baltimore, Maryland, United States},
  Review                   = {mentioned in my "rejection" for SAVCBS 2007. Is a way of delaying binding until composition, but suffers from "taking up the slot" problem.}
}

@Article{Finkelstein1992,
  Title                    = {Viewpoints: A Framework for Integrating Multiple Perspectives in System Development},
  Author                   = {Finkelstein, A. and Kramer, J. and Nuseibeh, B. and Finkelstein, L. and Goedicke, M.},
  Journal                  = {International Journal of Software Engineering and Knowledge Engineering},
  Year                     = {1992},
  Pages                    = {31--58},
  Volume                   = {2(1)},

  Abstract                 = {This paper outlines a framework which supports the use of multiple perspectives in system development, and provides a means for developing and applying systems design methods. The framework uses "viewpoints" to partition the system specification, the development method and the formal representations used to express the system specifications. This VOSE (viewpoint-oriented systems engineering) framework can be used to support the design of heterogeneous and composite systems. We illustrate the...},
  Review                   = {interesting approach to system construction that differs from UML style views -- this approach has multiple representations and checks and transfers between them. interesting but a bit simplistic.},
  Timestamp                = {2006.09.07},
  Url                      = {citeseer.ist.psu.edu/141147.html}
}

@InProceedings{Foote1999,
  Title                    = {Big Ball of Mud},
  Author                   = {Brian Foote and Joseph Yoder},
  Booktitle                = {Fourth Conference on Patterns Languages of Programs},
  Year                     = {1999},

  Owner                    = {amcveigh},
  Timestamp                = {2007.07.10}
}

@Misc{Fowler2004,
  Title                    = {{Inversion of Control Containers and the Dependency Injection Pattern}},

  Author                   = {Fowler, M.},
  HowPublished             = {http://www.martinfowler.com/articles/injection.html},
  Year                     = {2009},

  Journal                  = {Website},
  Owner                    = {amcveigh},
  Review                   = {Eclipse plugin site, showing thousands of plugins.},
  Timestamp                = {2006.05.15},
  Url                      = {http://www.martinfowler.com/articles/injection.html},
  Volume                   = {http://www.martinfowler.com/articles/injection.html}
}

@InProceedings{Froehlich1997,
  Title                    = {Hooking into Object-Oriented Application Frameworks},
  Author                   = {Froehlich, G. and Hoover, J. and Liu, L. and Sorenson, P.},
  Booktitle                = {Proceedings of the 19th International Conference on Software Engineering},
  Year                     = {1997},

  Address                  = {Boston, Massachusetts, United States},
  Pages                    = {491--501},
  Publisher                = {ACM Press},

  Abstract                 = {An object-oriented application framework provides a generic design within a given domain and a reusable implementation of that design. Frameworks have great potential for reuse, but that potential can only be achieved if the framework can be understood and used effectively by application developers. The complexity of the design and implementation of a framework can make understanding the framework difficult, and so good documentation and guidance to the framework user is needed. Several methods exist for documenting the design of the framework, but less work has been done on documenting the purpose of the framework and how it is intended to be used. In this paper, we introduce the concept of hooks as a means of documenting and providing guidance on the intended use of a framework. Each hook provides a concise solution to a focused requirement or problem within the context of the framework. Solutions for more complex requirements can be provided by combining several hooks. A discussion and means of describing hooks is given, with a focus on the method of adaption used to fulfill the requirement and the level of support provided for the solution within the framework.},
  Comment                  = {must read. Have used as a reference for "hooks".},
  ISSN                     = {0-89791-914-9},
  Owner                    = {amcveigh},
  Refid                    = {51},
  Timestamp                = {2006.03.14}
}

@Book{Gamma2003,
  Title                    = {Contributing to Eclipse: Principles, Patterns, and Plugins},
  Author                   = {Erich Gamma and Kent Beck},
  Publisher                = {Addison Wesley Longman Publishing Co., Inc.},
  Year                     = {2003},

  Address                  = {Redwood City, CA, USA},

  ISBN                     = {0321205758}
}

@Book{Gamma1995,
  Title                    = {Design Patterns: Elements of Reusable Object-Oriented Software},
  Author                   = {Gamma, E. and Helm, R. and Johnson, R. and Vlissides J.},
  Publisher                = {Addison-Wesley},
  Year                     = {1995},

  Owner                    = {amcveigh},
  Timestamp                = {2006.05.30}
}

@InProceedings{Garlan1997,
  Title                    = {Acme: An Architecture Description Interchange Language},
  Author                   = {David Garlan and Robert Monroe and David Wile},
  Booktitle                = {CASCON '97: Proceedings of the 1997 Conference of the Centre for Advanced Studies on Collaborative research},
  Year                     = {1997},
  Pages                    = {7},
  Publisher                = {IBM Press},

  Location                 = {Toronto, Ontario, Canada}
}

@Misc{Gentleware2009,
  Title                    = {{Poseidon UML}},

  Author                   = {{Gentleware AG}},
  HowPublished             = {http://www.gentleware.com/products.html},
  Year                     = {last accessed June 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.06.09},
  Url                      = {http://www.gentleware.com/products.html}
}

@Article{Giannakopoulou2003,
  Title                    = {Fluent Model Checking for Event-based Systems},
  Author                   = {Giannakopoulou, Dimitra and Magee, Jeff},
  Journal                  = {SIGSOFT Softw. Eng. Notes},
  Year                     = {2003},

  Month                    = sep,
  Number                   = {5},
  Pages                    = {257--266},
  Volume                   = {28},

  Acmid                    = {940106},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/949952.940106},
  ISSN                     = {0163-5948},
  Issue_date               = {September 2003},
  Keywords                 = {linear temporal logic, model-checking, software architecture analysis},
  Numpages                 = {10},
  Owner                    = {amcveigh},
  Publisher                = {ACM},
  Timestamp                = {2015.07.02},
  Url                      = {http://doi.acm.org/10.1145/949952.940106}
}

@Article{Gogolla2007,
  Title                    = {USE: A UML-Based Specification Environment for Validating UML and OCL},
  Author                   = {Gogolla, Martin and B\"{u}ttner, Fabian and Richters, Mark},
  Journal                  = {Science of Computer Programming},
  Year                     = {2007},
  Number                   = {1-3},
  Pages                    = {27--34},
  Volume                   = {69},

  Address                  = {Amsterdam, The Netherlands, The Netherlands},
  Doi                      = {http://dx.doi.org/10.1016/j.scico.2007.01.013},
  ISSN                     = {0167-6423},
  Owner                    = {andrew},
  Publisher                = {Elsevier North-Holland, Inc.},
  Timestamp                = {2009.06.09}
}

@InProceedings{Gogolla2003,
  Title                    = {Validation of UML and OCL Models by Automatic Snapshot Generation.},
  Author                   = {Martin Gogolla and J{\"o}rn Bohling and Mark Richters},
  Booktitle                = {UML},
  Year                     = {2003},
  Pages                    = {265-279},

  Abstract                 = {This extended abstract recalls how visual language editors benefit from graph grammars and how the editor-generator DiaGen is based on this approach. We then outline how generated editors can create abstract diagram representations for further processing, e. g. for communication with other tools or for diagram visualizations with varying, adjustable detail level which is a valuable aid when editing large diagrams. These concepts are illustrated with UML class diagrams.},
  Bibsource                = {DBLP, http://dblp.uni-trier.de},
  Ee                       = {http://springerlink.metapress.com/openurl.asp?genre=article{\&}issn=0302-9743{\&}volume=2863{\&}spage=265},
  Review                   = {simple and fairly accessible.

snapshots are constructed using a language or manually. state space is limited very much like alloy.

interesting, possibly better than alloy for checking well defined instances, but you can't really ask it questions as with alloy.}
}

@InProceedings{Gomaa1998,
  Title                    = {Composition of Software Architectures from Reusable Architecture Patterns},
  Author                   = {H. Gomaa and G. A. Farrukh},
  Booktitle                = {ISAW '98: Proceedings of the Third International Workshop on Software Architecture},
  Year                     = {1998},

  Address                  = {New York, NY, USA},
  Pages                    = {45--48},
  Publisher                = {ACM Press},

  Abstract                 = {In this paper a software architecture
perspective is taken to designing reusable
software applications. An application
domain is defined as a family of systems that
have some features in common and others
that differentiate them. During domain
engineering, reusable specifications,
architectural design patterns, and component
types are developed, which capture the
similarities and variations of the family of
systems that compose the application domain.
This paper describes the composition of
software architectures from reusable feature
based domain specific architectural design
patterns.},
  Doi                      = {http://doi.acm.org/10.1145/288408.288420},
  ISBN                     = {1-58113-081-3},
  Location                 = {Orlando, Florida, United States},
  Review                   = {very nify idea of tying features into layers that connect. nice pictures showing layers of component joining up.

what about feature interaction? doesn't really cover...}
}

@Misc{GWT,
  Title                    = {{Google Web Toolkit}},

  Author                   = {Google},
  HowPublished             = {http://code.google.com/webtoolkit/},
  Year                     = {2009},

  Owner                    = {andrew},
  Timestamp                = {2009.06.29},
  Url                      = {http://code.google.com/webtoolkit/}
}

@Misc{GWT-Apps,
  Title                    = {{Google Web Toolkit Application Gallery -- Google Code}},

  Author                   = {Google},
  HowPublished             = {http://gwtgallery.appspot.com/},
  Year                     = {2009},

  Owner                    = {andrew},
  Timestamp                = {2009.06.29},
  Url                      = {http://gwtgallery.appspot.com/}
}

@InProceedings{Goulo2003,
  Title                    = {Bridging the Gap between Acme and UML 2.0 for CBD},
  Author                   = {Goulo, M. and Abreu, F.},
  Booktitle                = {Specification and Verification of Component-Based Systems (SAVCBS 2003)},
  Year                     = {2003},

  Comment                  = {Abstract: Architecture Description Languages (ADLs) such as Acme (a mainstream second generation ADL which contains the most common ADL constructs) provide formality in the description of software architectures, but are not easily reconciled with day-today development concerns, thus hampering their adoption by a larger community. UML, on the other hand, has become the de facto standard notation for design modeling, both in industry and in academia. In this paper we map Acme modeling abstractions into UML ...
A decent paper that looks at the UML2 features for expressing an architecture, and concludes that connectors are underspecified and need to be phrased as separate components rather than UML connectors.
2004-01-01},
  Comments                 = {Abstract: Architecture Description Languages (ADLs) such as Acme (a mainstream second generation ADL which contains the most common ADL constructs) provide formality in the description of software architectures, but are not easily reconciled with day-today development concerns, thus hampering their adoption by a larger community. UML, on the other hand, has become the de facto standard notation for design modeling, both in industry and in academia. In this paper we map Acme modeling abstractions into UML ...
A decent paper that looks at the UML2 features for expressing an architecture, and concludes that connectors are underspecified and need to be phrased as separate components rather than UML connectors.
2004-01-01},
  Keywords                 = {architecture description language, software architecture},
  Owner                    = {amcveigh},
  Refid                    = {28},
  Timestamp                = {2006.03.14},
  Url                      = {http://citeseer.ist.psu.edu/680515.html}
}

@Book{Greenfield2004,
  Title                    = {Software Factories: Assembling Applications with Patterns, Models, Frameworks, and Tools},
  Author                   = {Greenfield, J. and Short, K. and Cook, S. and Kent, S. and Crupi, J.},
  Publisher                = {Wiley; 1st edition (August 16, 2004)},
  Year                     = {2004},

  Owner                    = {amcveigh},
  Pages                    = {--},
  Refid                    = {60},
  Timestamp                = {2006.03.14}
}

@Article{Gurp2001,
  Title                    = {Design, Implementation and Evolution of Object Oriented Frameworks: Concepts and Guidelines},
  Author                   = {van Gurp,, J. and Bosch,, J.},
  Journal                  = {Software - Practice And Experience In the Second International Workshop on Component-Oriented Programming},
  Year                     = {2001},
  Number                   = {3},
  Pages                    = {277--300},
  Volume                   = {31},

  Abstract                 = {Object-oriented frameworks provide software developers with the means to build an infrastructure for
their applications. Unfortunately, frameworks do not always deliver on their promises of reusability and
flexibility. To address this, we have developed a conceptual model for frameworks and a set of guidelines
to build object oriented frameworks that adhere to this model. Our guidelines focus on improving the
flexibility, reusability and usability (i.e. making it easy to use a framework) of frameworks.},
  Address                  = {New York, NY, USA},
  Doi                      = {http://dx.doi.org/10.1002/spe.366},
  ISSN                     = {0038-0644},
  Publisher                = {John Wiley \& Sons, Inc.}
}

@Misc{Haggar2002,
  Title                    = {{Double-Checked Locking and the Singleton Pattern}},

  Author                   = {Peter Haggar},
  HowPublished             = {http://www.ibm.com/developerworks/java/library/j-dcl.html},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.06.15}
}

@Article{Harel1987,
  Title                    = {Statecharts: A Visual Formalism for Complex Systems},
  Author                   = {Harel, David},
  Journal                  = {Science of Computer Programming},
  Year                     = {1987},
  Number                   = {3},
  Pages                    = {231--274},
  Volume                   = {8},

  Address                  = {Amsterdam, The Netherlands, The Netherlands},
  Doi                      = {http://dx.doi.org/10.1016/0167-6423(87)90035-9},
  ISSN                     = {0167-6423},
  Owner                    = {andrew},
  Publisher                = {Elsevier North-Holland, Inc.},
  Timestamp                = {2009.06.26}
}

@Book{Harrop2005,
  Title                    = {Pro Spring},
  Author                   = {Harrop, R. and Machacek, J.},
  Publisher                = {Apress},
  Year                     = {2005},

  Owner                    = {amcveigh},
  Timestamp                = {2006.05.30}
}

@InProceedings{Hay2000,
  Title                    = {Composing Features and Resolving Interactions},
  Author                   = {Hay, J.D. and Atlee, J.M.},
  Booktitle                = {SIGSOFT '00/FSE-8: Proceedings of the 8th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  Year                     = {2000},

  Address                  = {New York, NY, USA},
  Pages                    = {110--119},
  Publisher                = {ACM Press},

  Abstract                 = {One of the accepted techniques for developing and maintaining feature-rich applications is to treat each feature as a separate concern. However, most features are not separate concerns because they override and extend the same basic service. That is, �independent� features are coupled to one another through the system's basic service. As a result, seemingly unrelated features subtly interfere with each other when trying to override the system behaviour in different directions. The problem is how to coordinate features' access to the service's shared variables.

This paper proposes coordinating features via feature composition. We model each feature as a separate labelled-transition system and define a 1conflict-free (CF) composition operator that prevents enabled transitions from synchronizing if they interact: if several features' transitions are simultaneously enabled but have conflicting actions, a non-conflicting subset of the enabled transitions are synchronized in the composition. We also define a conflict- and violation-free (CVF) composition operator that prevents enabled transitions from executing if they violate features' invariants. Both composition operators use priorities among features to decide whether to synchronize transitions.},
  Comments                 = {Looks at feature interaction from a telco perspective. The idea is taht features should be developed as separate concerns, because this "illusion" simplifies the design and development of features. i.e. features can be contracted out, potentially. Each feature is abstracted to a set of assertions and transitions, with invariants also possible. Each feature specifies these transitions, and you can compose these to find interactions. Interestingly, sometimes interactions are desirable -- i.e. you want to update the feature in the presence of another.

The formalisms are simple, but presented in a complex, and comprehensive way. The basic idea is that conflicts are picked up and resolved by prioritising features. Finally, weak invariants are added which allow the service to say something about the properties that must hold for the service. These can be "relaxed" by higher priority features, but are still asserted to handle interaction with lower priority features.

There is a lot of good language and phrases in this paper. Well worth a re-read. This is also valuable as a source of info about why features interact, in case I need to reverse engineer feature conflicts etc.},
  Doi                      = {http://doi.acm.org/10.1145/355045.355061},
  ISBN                     = {1-58113-205-0},
  Location                 = {San Diego, California, United States},
  Timestamp                = {2006.03.03},
  Url                      = {http://portal.acm.org/citation.cfm?id=355061&coll=Portal&dl=GUIDE&CFID=73394572&CFTOKEN=93442719#}
}

@Misc{Headway,
  Title                    = {{Structure101 - Software Architecture Analysis for Java, C/C++ and Anything}},

  Author                   = {{Headway Software Technologies Ltd}},
  HowPublished             = {http://www.headwaysoftware.com/index.php},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.07.24},
  Url                      = {http://www.headwaysoftware.com/index.php}
}

@InProceedings{Helm1990,
  Title                    = {Contracts: Specifying Behavioral Compositions in Object-Oriented Systems},
  Author                   = {Helm, R. and Holland, I.M. and Gangopadhyay, D.},
  Booktitle                = {Proceedings of the European Conference on Object-Oriented Programming: Systems, Languages, and Applications},
  Year                     = {1990},

  Address                  = {Ottawa, Canada},
  Pages                    = {169--180},
  Publisher                = {ACM Press},

  Comment                  = {97967
http://doi.acm.org/10.1145/97945.97967},
  ISSN                     = {0-201-52430-X},
  Keywords                 = {SYSTEMS},
  Owner                    = {amcveigh},
  Refid                    = {61},
  Timestamp                = {2006.03.14}
}

@InCollection{Henderson-Sellers2006,
  Title                    = {Uses and Abuses of the Stereotype Mechanism in UML 1.x and 2.0},
  Author                   = {Henderson-Sellers, B. and Gonzalez-Perez, C.},
  Booktitle                = {Model Driven Engineering Languages and Systems},
  Publisher                = {Springer},
  Year                     = {2006},
  Pages                    = {16--26},

  Abstract                 = {Stereotypes were introduced into the UML in order to offer extensibility to the basic metamodel structure by the user and without actually modifying the metamodel. In UML version 1.x, this was accomplished by means of permitting virtual subtyping in the metamodel. However, this facility led many to misuse stereotypes, particularly in places where regular domain-level modelling would be more appropriate. In version 2.0 of the UML, the portion of the metamodel pertaining to stereotypes was drastically revised. The resulting mechanism is reviewed here and compared with that of version 1.x. From a set theory point of view, the new (2.0) metamodel is unfortunately untenable and the examples used in the OMG documentation unconvincing. This paper outlines the issues and suggests some possible steps to improve the UML 2.0 stereotype theory and practice.},
  Citeulike-article-id     = {4079645},
  Doi                      = {10.1007/11880240\_2},
  Journal                  = {Model Driven Engineering Languages and Systems},
  Keywords                 = {get-it},
  Owner                    = {andrew},
  Posted-at                = {2009-02-22 10:56:46},
  Priority                 = {2},
  Timestamp                = {2009.04.04},
  Url                      = {http://dx.doi.org/10.1007/11880240\_2}
}

@InProceedings{Hendrickson2007,
  Title                    = {Modeling Product Line Architectures Through Change Sets and Relationships},
  Author                   = {Hendrickson, Scott A. and van der Hoek, Andre},
  Booktitle                = {ICSE '07: Proceedings of the 29th International Conference on Software Engineering},
  Year                     = {2007},

  Address                  = {Washington, DC, USA},
  Pages                    = {189--198},
  Publisher                = {IEEE Computer Society},

  Abstract                 = {The essence of any modeling approach for product line architectures lies in its ability to express variability. Existing approaches do so by explicitly specifying variation points inside the architectural specification of the entire product line, usually with optional and alternative elements of some form. This, however, leads to a sizable mismatch between conceptual variability (i.e., the features through which architects logically view and interpret differences in product architectures) and actual variability (i.e., the modeling constructs through which the logical differences must be expressed). We contribute a new product line architecture modeling approach that unites the two. Our approach uses change sets to group related architectural differences and relationships to govern which change set combinations are valid when composed into a particular product architecture. The result lifts modeling of variability out of modeling architectural structure, consolidates related variation points, and explicitly and separately manages their compatibilities.},
  Doi                      = {http://dx.doi.org/10.1109/ICSE.2007.56},
  ISBN                     = {0-7695-2828-7},
  Review                   = {Applies changes sets to underlying ADL to allow arbitrary changes. then allows relationships between change sets.

very comparable to Backbone approach, but merging is very much limited. No resemblance, so it doesn't apply to local reuse. Concerns about usability for larger architectures.

Also, doesn't appear to feature any form of replacement. Does use UUIDs though.}
}

@InProceedings{heuzeroth99b,
  Title                    = {Dynamic Coupling of Binary Components and its Technical Support},
  Author                   = {Dirk Heuzeroth and Ralf Reussner},
  Booktitle                = {First Workshop on Generative and Component based Software Engineering (GCSE) -- Young Researchers Workshop},
  Year                     = {1999},

  Abstract                 = {The aim of todays software development is to build applications by the reuse of binary components.
This requires the composition of components and as special cases component enhancement
as well as adaption. We demonstrate how to deal with these cases by furnishing components with
a type consisting of two protocols � a call and a use protocol. We model these protocols by finite
automata and show how those reflect component enhancement and adaption. This mechanism allows
for automatic adaption of components in changing environments.
In order to obtain binary components we have to compile corresponding sources. In view of the
required features of the binary components and with the problems of compiling generic classes in
mind, we describe an approach to generate such pre-compiled components by appropriate compiler
extensions.},
  Adress                   = {Erfurt, Germany},
  Review                   = {this is very poor and hard to understand. It is also *very* incorrect in places. e.g. binary compilation of frameworks.

tries to use automata to verify protocols.},
  Timestamp                = {2006.09.11},
  Url                      = {citeseer.ist.psu.edu/article/heuzeroth99dynamic.html}
}

@InProceedings{Hillman2004,
  Title                    = {An Open Framework for Dynamic Reconfiguration},
  Author                   = {Hillman, J. and Warren, I.},
  Booktitle                = {Proceedings of the 26th International Conference on Software Engineering},
  Year                     = {2004},
  Pages                    = {594--603},
  Publisher                = {IEEE Computer Society},

  Comment                  = {Recommended by Jeff K. Describes an "open" implementation of a system to allow dynamic reconfiguration of architectures. Separates out the algorithm from the reconfiguration manager, and defines their responsibilities. Discusses 2 approaches to achieving quiescent state: blocking components and blocking connectors.
2005-10-11},
  ISSN                     = {0-7695-2163-0},
  Owner                    = {amcveigh},
  Refid                    = {3},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=999462&coll=GUIDE&dl=GUIDE&CFID=57996419&CFTOKEN=31358059#}
}

@InProceedings{Hoek1996,
  Title                    = {A Generic, Peer-to-Peer Repository for Distributed Configuration Management},
  Author                   = {Andr\'{e} van der Hoek and Dennis Heimbigner and Alexander L. Wolf},
  Booktitle                = {ICSE '96: Proceedings of the 18th International Conference on Software engineering},
  Year                     = {1996},

  Address                  = {Washington, DC, USA},
  Pages                    = {308--317},
  Publisher                = {IEEE Computer Society},

  ISBN                     = {0-8186-7246-3},
  Location                 = {Berlin, Germany},
  Review                   = {earliest academic paper i could find that addressed distributed config mgmt directly.}
}

@InProceedings{Hoek2001,
  Title                    = {Taming Architectural Evolution},
  Author                   = {van der Hoek, A. and Mikic-Rakic, M. and Roshandel, R. and Medvidovic, N.},
  Booktitle                = {Proceedings of the 8th European Software Engineering Conference held jointly with 9th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  Year                     = {2001},

  Address                  = {Vienna, Austria},
  Pages                    = {1--10},
  Publisher                = {ACM Press},

  Abstract                 = {In the world of software development everything evolves. So, then, do software architectures. Unlike source code, for which the use of a configuration management (CM) system is the predominant approach to capturing and managing evolution, approaches to capturing and managing architectural evolution span a wide range of disconnected alternatives. This paper contributes a novel architecture evolution environment, called Mae, which brings together a number of these alternatives. The environment facilitates an incremental design process in which all changes to all architectural elements are integrally captured and related. Key to the environment is a rich system model that combines architectural concepts with those from the field of CM. Not only does this system model form the basis for Mae, but in precisely capturing architectural evolution it also facilitates automated support for several innovative capabilities that rely on the integrated nature of the system model. This paper introduces three of those: the provision of design guidance at the architectural level, the use of specialized software connectors to ensure run-time reliability during component upgrades, and the creation of component-level patches to be applied to deployed system configurations.},
  Comment                  = {!read},
  ISSN                     = {1-58113-390-1},
  Keywords                 = {software architecture, configuration, connector, component},
  Owner                    = {amcveigh},
  Refid                    = {39},
  Timestamp                = {2006.03.14}
}

@InProceedings{Holzle1993,
  Title                    = {Integrating Independently-Developed Components in Object-Oriented Languages},
  Author                   = {Holzle, U.},
  Booktitle                = {Proceedings of the 7th European Conference on Object-Oriented Programming},
  Year                     = {1993},
  Pages                    = {36--56},
  Publisher                = {Springer-Verlag},

  Comment                  = {Good paper, very early and influential, but examples are too simplistic. Proposes type adaptation to adjust types in place. Need to look into extension hierarchies referenced in the paper -- sound a bit like BB extensions. The wrapping ideas here are very relevant.
2005-12-12},
  ISSN                     = {3-540-57120-5},
  Keywords                 = {component},
  Owner                    = {amcveigh},
  Refid                    = {76},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=679351#}
}

@InProceedings{Hou2001,
  Title                    = {Towards Specifying Constraints for Object-Oriented Frameworks},
  Author                   = {Hou, D. and Hoover, J.},
  Booktitle                = {Proceedings of the 2001 Conference of the Centre for Advanced Studies on Collaborative Research},
  Year                     = {2001},

  Address                  = {Toronto, Ontario, Canada},
  Pages                    = {5},
  Publisher                = {IBM Press},

  Abstract                 = {Object-oriented frameworks are often hard to learn and use [1, 3]. As a result, software cost rises and quality suers. Thus the capabil- ity to automatically detect errors occurring at the boundary between frameworks and applica- tions is considered crucial to mitigate the prob- lem. This paper introduces the notion of frame- work constraints and a specication language, FCL (Framework Constraints Language), to formally specify them. Framework constraints are rules that frameworks impose on the code of framework-based applications. The semantics of FCL is primarily based on rst order predi- cate logic and set theory though the syntax is designed to resemble that of programming lan- guages as much as possible. We take examples from the MFC (Microsoft Foundation Classes) framework [19] demonstrating both the nature of framework constraints and the semantics of FCL. Essentially, framework constraints can be regarded as framework-specic typing rules conveyed by the specication language FCL, and thus can be enforced by techniques analo- gous to those of conventional type checking.},
  Comment                  = {Introduces a framework constraint language (FCL) that documents and specifies a framework. Intended to (at least partially) record intentions of the original designers. The language is a bit simplistic, but it allows sequencing and other simple terms to be specified. Impractical for use, as it needs to parse the code (!) to work out if the constraints are violated!!!
2005-10-24},
  Owner                    = {amcveigh},
  Refid                    = {34},
  Timestamp                = {2006.03.14}
}

@Book{Hoy2002,
  Title                    = {Java Swing},
  Author                   = {Hoy,, Marc and Wood,, Dave and Loy,, Marc and Elliot,, James and Eckstein,, Robert},
  Publisher                = {O'Reilly \& Associates, Inc.},
  Year                     = {2002},

  Address                  = {Sebastopol, CA, USA},

  ISBN                     = {0596004087},
  Owner                    = {andrew},
  Timestamp                = {2009.03.31}
}

@Misc{IBM,
  Title                    = {{Rational Software Architect for WebSphere Software}},

  Author                   = {IBM},
  HowPublished             = {http://www-01.ibm.com/software/awdtools/swarchitect/websphere/},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.06.19},
  Url                      = {http://www-01.ibm.com/software/awdtools/swarchitect/websphere/}
}

@Misc{IBMa,
  Title                    = {{Rational Application Developer for WebSphere Software}},

  Author                   = {IBM},
  HowPublished             = {http://www-01.ibm.com/software/awdtools/developer/application/},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.06.19},
  Url                      = {http://www-01.ibm.com/software/awdtools/developer/application/}
}

@TechReport{Ichisugi2002a,
  Title                    = {Layered Class Diagram --The Way to Express Class Structures of MixJuice Programs.},
  Author                   = {Yuuji Ichisugi},
  Institution              = {National Institute of Advanced Industrial Science and Technology (AIST)},
  Year                     = {2002},

  File                     = {lclass-diag-20021030.pdf:http\://staff.aist.go.jp/y-ichisugi/mj/papers/lclass-diag-20021030.pdf:PDF},
  Owner                    = {amcveigh},
  Review                   = {Nice pictures of MixJuice programs.},
  Timestamp                = {2007.07.09},
  Url                      = {http://staff.aist.go.jp/y-ichisugi/mj/papers/lclass-diag-20021030.pdf}
}

@InProceedings{Ichisugi2002,
  Title                    = {Difference-Based Modules: A Class-Independent Module Mechanism},
  Author                   = {Yuuji Ichisugi and Akira Tanaka},
  Booktitle                = {ECOOP '02: Proceedings of the 16th European Conference on Object-Oriented Programming},
  Year                     = {2002},

  Address                  = {London, UK},
  Pages                    = {62--88},
  Publisher                = {Springer-Verlag},

  Abstract                 = {We describe a module mechanism, which we call differencebased
modules, and an object-oriented language we call MixJuice. MixJuice
is an enhancement to the Java language that adopts difference-based
modules instead of Java�s original module mechanism. Modules are units
of information hiding, reuse and separate compilation. We have completely
separated the class mechanism and the module mechanism, and
then unified the module mechanism and the differential programming
mechanism. Although this module mechanism is simpler than that of
Java, it enhances ease with which programs can be extended, reused and
maintained. Collaborations that crosscut several classes can be separated
into different modules. Modules are composable in the same way as mixins.
The composition of modules sometimes causes name collision and
an interesting phenomenon, which we call implementation defects. We
describe solutions to these problems.},
  ISBN                     = {3-540-43759-2},
  Review                   = {Paper is very similar to what I am doing, except rather than use an ADL and components, they apply the ideas directly to Java and propose that their modules be used instead of packages. My work has major parallels with this and must cite this!

Basically, they use inheritance instead of resemblance, and they use class and interface "extension" instead of redefinition. I strongly suspect that it is rewriting everything in terms of inheritance under the covers although I don't think it explicitly indicates this.

This paper is important because it gives insight on how well the approach of development-by-difference works, and it also shows that a module can be regarded as a feature set or as an aspect. Nice for reference in my work.

NOTE: has further papers on modeling approach (UML), extension rules for safely composing, and an experience report on how refactoring works in this approach.

Limitations of approach:
--------------------
1. limited to the semantics of inheritance, which makes full evolution impossible
2. trying to replace packages and nested classes, but it doesn't provide the full functionality of nested classes (c.f. poor example in 3.3)
3. needs to linearise modules -- conflict resolution is not powerful enough, possible because of (1)

Similarities:
----------
1. difference modules = stratum, class = component, inheritance = resemblance, extension = redefinition, dependencies between modules provide a partial order
2. non-hierarchical modules
3. discusses independently developed modules and clashes that can result.
4. idea of complementary modules to resolve conficts between independent modules
5. NoSource -- doesn't require the source of java to extensively change. Maybe better at this than my stuff, which requires ADL source.
6. Use of fully-qualified-names / UUIDs to solve problem with name clashes in independently developed modules
7. use of .original() for delegation versus actual delegation/wrapping in Backbone

MixJuice is better at:
-----------------
1. unit of change granularity is naturally lower, as it works with implementation classes/interfaces directly. low design overhead.
2. no need for 2 languages (ADL, Java)
3. complementary modules are included automatically

Backbone is better at:
------------------
1. component model is recursive and more architecturally powerful
 a. attribute aliasing -- notion of higher state
 b. ability to change original instance config + factories -- i.e. natural object graphs
2. resemblance/redefinition allows arbitrary changes, can model software evolution more fully
3. baselining, as a result of (2)
4. behavioural specs + goal specs -- ties into recursive approach + FSP
5. formal semantics -- does MixJuice have these?
6. deals with partial order through merge and resolution rules -- made more powerful by 2.
7. multiple resemblance, even for components
8. modelling approach (view as at a particular stratum)
9. renaming support via modelling approach for refactoring etc.

Some techniques I can use from the paper
-----------------------------------
1. separation of specification of component in one module, and multiple implementations in another which "redefine" the spec
2. nested if statements through chaining / delegation},
  Timestamp                = {2007.03.26}
}

@Misc{Jackson2005,
  Title                    = {{Alloy Home Page}},

  Author                   = {Jackson, D.},
  HowPublished             = {http://alloy.mit.edu/},
  Year                     = {last accessed August 2009},

  Address                  = {http://alloy.mit.edu/},
  Owner                    = {amcveigh},
  Pages                    = {--},
  Refid                    = {65},
  Timestamp                = {2006.03.14},
  Url                      = {http://alloy.mit.edu/}
}

@Book{Jackson2006,
  Title                    = {Software Abstractions: Logic, Language, and Analysis},
  Author                   = {Daniel Jackson},
  Publisher                = {The MIT Press},
  Year                     = {2006},
  Month                    = {April},

  Abstract                 = {In Software Abstractions Daniel Jackson introduces a new approach to software design that draws on traditional formal methods but exploits automated tools to find flaws as early as possible. This approach—which Jackson calls "lightweight formal methods" or "agile modeling"—takes from formal specification the idea of a precise and expressive notation based on a tiny core of simple and robust concepts but replaces conventional analysis based on theorem proving with a fully automated analysis that gives designers immediate feedback. Jackson has developed Alloy, a language that captures the essence of software abstractions simply and succinctly, using a minimal toolkit of mathematical notions. The designer can use automated analysis not only to correct errors but also to make models that are more precise and elegant. This approach, Jackson says, can rescue designers from "the tarpit of implementation technologies" and return them to thinking deeply about underlying concepts.

Software Abstractions introduces the key elements of the approach: a logic, which provides the building blocks of the language; a language, which adds a small amount of syntax to the logic for structuring descriptions; and an analysis, a form of constraint solving that offers both simulation (generating sample states and executions) and checking (finding counterexamples to claimed properties). The book uses Alloy as a vehicle because of its simplicity and tool support, but the book's lessons are mostly language-independent, and could also be applied in the context of other modeling languages.},
  Owner                    = {andrew},
  Review                   = {the definitive book!!},
  Timestamp                = {2009.05.13}
}

@Article{Jackson2002,
  Title                    = {Alloy: A Lightweight Object Modelling Notation},
  Author                   = {Daniel Jackson},
  Journal                  = {ACM Transactions on Software Engineering and Methodology (TOSEM)},
  Year                     = {2002},
  Number                   = {2},
  Pages                    = {256--290},
  Volume                   = {11},

  Address                  = {New York, NY, USA},
  Doi                      = {http://doi.acm.org/10.1145/505145.505149},
  ISSN                     = {1049-331X},
  Publisher                = {ACM Press}
}

@Article{Johnson1997,
  Title                    = {Frameworks = (Components + Patterns)},
  Author                   = {Johnson, R.E.},
  Journal                  = {Communications of the ACM},
  Year                     = {1997},
  Number                   = {10},
  Pages                    = {39--42},
  Volume                   = {40},

  Comment                  = {Defines a framework, and looks at how it differs from components and patterns. Mentions their similarity to components.
2005-10-24},
  ISSN                     = {0001-0782},
  Keywords                 = {component},
  Owner                    = {amcveigh},
  Publisher                = {ACM Press},
  Refid                    = {36},
  Timestamp                = {2006.03.14}
}

@InProceedings{Johnson1997a,
  Title                    = {Components, Frameworks, Patterns},
  Author                   = {Johnson, R.E.},
  Booktitle                = {Proceedings of the 1997 Symposium on Software Reusability},
  Year                     = {1997},

  Address                  = {Boston, Massachusetts, United States},
  Pages                    = {10--17},
  Publisher                = {ACM Press},

  Abstract                 = {Frameworks are an object-oriented reuse technique. They share a lot of characteristics with reuse techniques in general, and object-oriented reuse techniques in particular. Although they have been used successfully for some time, and are an important part of the culture of long-time object-oriented developers, most framework development projects are failures, and most object-oriented met homologies do not describe how to use frameworks. Moreover, there is a lot of confusion about whether frameworks are just large+ scale patterns, or whether they are just another kind of component.},
  Comment                  = {Very similar to the Frameworks = (Components + Patterns) paper. Has extra references.
2005-10-27},
  ISSN                     = {0-89791-945-9},
  Keywords                 = {component},
  Owner                    = {amcveigh},
  Refid                    = {37},
  Timestamp                = {2006.03.14}
}

@Book{Johnson2005,
  Title                    = {Professional Java Development with the Spring Framework},
  Author                   = {Rod Johnson and Juergen Hoeller and Alef Arendsen and Thomas Risberg and Colin Sampaleanu},
  Publisher                = {Hungry Minds Inc, U.S.},
  Year                     = {2005},

  Owner                    = {amcveigh},
  Timestamp                = {2007.07.09}
}

@InProceedings{Jorgensen2004,
  Title                    = {Language Support for Incremental Integration of Independently Developed Components in Java},
  Author                   = {Jorgensen, B.N.},
  Booktitle                = {SAC '04: Proceedings of the 2004 ACM Symposium on Applied Computing},
  Year                     = {2004},

  Address                  = {New York, NY, USA},
  Pages                    = {1316--1322},
  Publisher                = {ACM Press},

  Doi                      = {http://doi.acm.org/10.1145/967900.968166},
  ISBN                     = {1-58113-812-1},
  Location                 = {Nicosia, Cyprus}
}

@TechReport{Kang1990,
  Title                    = {Feature-Oriented Domain Analysis (FODA) Feasibility Study},
  Author                   = {K. C. Kang and S. G. Cohen and J. A. Hess and W. E. Novak and A. S. Peterson},
  Institution              = {Carnegie-Mellon University Software Engineering Institute},
  Year                     = {1990},
  Month                    = {November},

  Interhash                = {7d9a7ab3a80077c31cfd2a83150d5b3f},
  Intrahash                = {1910de1c3156c3a5821385760069cc52},
  Owner                    = {andrew},
  Timestamp                = {2009.06.24}
}

@InProceedings{Kastner2008,
  Title                    = {Granularity in Software Product Lines},
  Author                   = {Kastner, Christian and Apel, Sven and Kuhlemann, Martin},
  Booktitle                = {ICSE '08: Proceedings of the 30th International Conference on Software Engineering},
  Year                     = {2008},

  Address                  = {New York, NY, USA},
  Pages                    = {311--320},
  Publisher                = {ACM},

  Abstract                 = {Building software product lines (SPLs) with features is a challenging task. Many SPL implementations support features with coarse granularity - e.g., the ability to add and wrap entire methods. However, fine-grained extensions, like adding a statement in the middle of a method, either require intricate workarounds or obfuscate the base code with annotations. Though many SPLs can and have been implemented with the coarse granularity of existing approaches, fine-grained extensions are essential when extracting features from legacy applications. Furthermore, also some existing SPLs could benefit from fine-grained extensions to reduce code replication or improve readability. In this paper, we analyze the effects of feature granularity in SPLs and present a tool, called Colored IDE (CIDE), that allows features to implement coarse-grained and fine-grained extensions in a concise way. In two case studies, we show how CIDE simplifies SPL development compared to traditional approaches.},
  Doi                      = {http://doi.acm.org/10.1145/1368088.1368131},
  ISBN                     = {978-1-60558-079-1},
  Location                 = {Leipzig, Germany},
  Review                   = {provides the CIDE (coloured IDE) which allows for bits of code to be annotated and changes to be made to arbitrary methods etc. they compare their approach to the compositional approach, which uses Jak. interstingly Jak features the refine concept -- definitely need to reference.

Excellent references, but a fragile approach which breaks when changes are made bottom up to existing artifacts.}
}

@Article{Kemerer1999,
  Title                    = {An Empirical Approach to Studying Software Evolution},
  Author                   = {Chris F. Kemerer and Sandra Slaughter},
  Journal                  = {IEEE Transactions on Software Engineering},
  Year                     = {1999},
  Number                   = {4},
  Pages                    = {493--509},
  Volume                   = {25},

  Abstract                 = {With the approach of the new millennium, a primary focus in software engineering involves issues relating to upgrading, migrating, and evolving existing software systems. In this environment, the role of careful empirical studies as the basis for improving software maintenance processes, methods, and tools is highlighted. One of the most important processes that merits empirical evaluation is software evolution. Software evolution refers to the dynamic behavior of software systems as they are maintained and enhanced over their lifetimes. Software evolution is particularly important as systems in organizations become longer-lived. However, evolution is challenging to study due to the longitudinal nature of the phenomenon in addition to the usual difficulties in collecting empirical data. In this paper, we describe a set of methods and techniques that we have developed and adapted to empirically study software evolution. Our longitudinal empirical study involves collecting, coding, and analyzing more than 25,000 change events to 23 commercial software systems over a 20-year period. Using data from two of the systems, we illustrate the efficacy of flexible phase mapping and gamma sequence analytic methods originally developed in social psychology to examine group problem solving processes. We have adapted these techniques in the context of our study to identify and understand the phases through which a software system travels as it evolves over time. We contrast this approach with time series analysis, the more traditional way of studying longitudinal data. Our work demonstrates the advantages of applying methods and techniques from other domains to software engineering and illustrates how, despite difficulties, software evolution can be empirically studied.},
  Address                  = {Piscataway, NJ, USA},
  Doi                      = {http://dx.doi.org/10.1109/32.799945},
  ISSN                     = {0098-5589},
  Publisher                = {IEEE Press},
  Review                   = {contains the 50% figure for software maintenance and evolution.}
}

@InProceedings{Khare2001,
  Title                    = {xADL: Enabling Architecture-Centric Tool Integration with XML},
  Author                   = {Khare,, R. and Guntersdorfer,, M. and Oreizy,, P. and Medvidovic,, N. and Taylor,, R.},
  Booktitle                = {HICSS '01: Proceedings of the 34th Annual Hawaii International Conference on System Sciences ( HICSS-34)-Volume 9},
  Year                     = {2001},

  Address                  = {Washington, DC, USA},
  Pages                    = {9053},
  Publisher                = {IEEE Computer Society},

  ISBN                     = {0-7695-0981-9},
  Owner                    = {andrew},
  Timestamp                = {2009.04.04}
}

@InBook{Kiczales1993,
  Title                    = {Object-Oriented Programming: The CLOS Perspective},
  Author                   = {Gregor Kiczales and J. Michael Ashley and Luis H. Rodriguez Jr. and Amin Vahdat and Daniel G. Bobrow},
  Chapter                  = {4: Metaobject Protocols: Why We Want Them and What Else Can They Do},
  Editor                   = {Andreas Paepcke},
  Pages                    = {101-131},
  Publisher                = {MIT Press},
  Year                     = {1993},

  Abstract                 = {Originally conceived as a neat idea that could help solve problems in the design and implementation
of CLOS, the metaobject protocol framework now appears to have applicability to a wide range
of problems that come up in high-level languages. This chapter sketches this wider potential, by
drawing an analogy to ordinary language design, by presenting some early design principles, and
by presenting an overview of three new metaobject protcols we have designed that, respectively,
control the semantics of Scheme, the compilation of Scheme, and the static parallelization of Scheme
programs.},
  Owner                    = {andrew},
  Timestamp                = {2009.03.31}
}

@InProceedings{Kiczales1992,
  Title                    = {Issues in the Design and Specification of Class Libraries},
  Author                   = {Kiczales, G. and Lamping, J.},
  Booktitle                = {ACM SIGPLAN Notices},
  Year                     = {1992},

  Address                  = {Vancouver, British Columbia, Canada},
  Pages                    = {435--451},
  Publisher                = {ACM Press},

  Abstract                 = {The design and specification of an extensible class library presents a difficult challenge: because extensibility comes from allowing the user to override parts of the implementation, more of the internal structure must be exposed to the user than in a typical procedure library. This raises issues in both how the library is designed and how its specification is written. Specification of the CLOS Metaobject Protocol required a combination of new and existing techniques to address these issues. We present those techniques, and discuss their relation to the underlying issues.},
  Comment                  = {An older paper which predates the framework term. Looks at the issues with making an extensible class library. Has very clear, precise terminology and explains the notion of framework extension very well. Mentions layered protocols as a possible way of solving the issues, in order to resolve the tension between ease of use and extensibility.
2005-11-16},
  ISSN                     = {0-201-53372-3},
  Keywords                 = {SPECIFICATION, SYSTEMS},
  Owner                    = {amcveigh},
  Refid                    = {49},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=141971&coll=Portal&dl=GUIDE&CFID=60884982&CFTOKEN=64386172#}
}

@InCollection{kiczales97aspectoriented,
  Title                    = {Aspect-Oriented Programming},
  Author                   = {Kiczales, G. and Lamping, J. and Menhdhekar, A. and Maeda, C. and Lopes, C. and Loingtier, J.M. and Irwin, J.},
  Booktitle                = {Proceedings European Conference on Object-Oriented Programming},
  Publisher                = {Springer-Verlag},
  Year                     = {1997},

  Address                  = {Berlin, Heidelberg, and New York},
  Editor                   = {Mehmet Ak\c{s}it and Satoshi Matsuoka},
  Pages                    = {220--242},
  Volume                   = {1241},

  Url                      = {citeseer.ist.psu.edu/kiczales97aspectoriented.html}
}

@Book{Kiczales1991,
  Title                    = {The Art of the Metaobject Protocol},
  Author                   = {Kiczales, Gregor and des Rivieres, Jim and Bobrow, Daniel G.},
  Publisher                = {The MIT Press},
  Year                     = {1991},

  Owner                    = {andrew},
  Timestamp                = {2009.03.31}
}

@Article{Kramer1990,
  Title                    = {The Evolving Philosophers Problem - Dynamic Change Management},
  Author                   = {Kramer, J. and Magee, J.},
  Journal                  = {IEEE Transactions on Software Engineering},
  Year                     = {1990},

  Month                    = nov,
  Number                   = {11},
  Pages                    = {1293--1306},
  Volume                   = {16},

  Comment                  = {Times Cited: 44 Article English KRAMER, J UNIV LONDON,IMPERIAL COLL SCI TECHNOL,DEPT COMP,180 QUEENS GATE,LONDON SW7 2BZ,ENGLAND Cited References Count: 21
A very clear and amazingly innovative paper. Probably one of the seminal papers for the field. Moves on from configuration of component systems to look at dynamic reconfiguration of these, using "configuration changes" which express the difference between the past architecture and the future one. Describes approaches where part of the system may be dynamically reconfigured during runtime, and strategies involved. Develops the notion of lifecycle state and the use of this in a reconfiguration approach.
2005-10-17},
  Comments                 = {Times Cited: 44 Article English KRAMER, J UNIV LONDON,IMPERIAL COLL SCI TECHNOL,DEPT COMP,180 QUEENS GATE,LONDON SW7 2BZ,ENGLAND Cited References Count: 21

A very clear and amazingly innovative paper. Probably one of the seminal papers for the field. Moves on from configuration of component systems to look at dynamic reconfiguration of these, using "configuration changes" which express the difference between the past architecture and the future one. Describes approaches where part of the system may be dynamically reconfigured during runtime, and strategies involved. Develops the notion of lifecycle state and the use of this in a reconfiguration approach.
2005-10-17},
  ISSN                     = {0098-5589},
  Owner                    = {amcveigh},
  Refid                    = {26},
  Timestamp                = {2006.03.14},
  Url                      = {ISI:A1990ED91000007}
}

@InCollection{Kramer1995,
  Title                    = {Modelling Darwin in pi-Calculus},
  Author                   = {Kramer, Jeff and Magee, Jeff and Eisenbach, Susan},
  Booktitle                = {Theory and Practice in Distributed Systems},
  Publisher                = {Springer-Verlag},
  Year                     = {1995},
  Month                    = {July},
  Pages                    = {133--152},
  Series                   = {Lecture Notes in Computer Science},

  Abstract                 = {DARWIN is a configuration language for distributed
and parallel programs, providing a hierarchical structure
of components with dynamic binding. In order to
specify precisely the behaviour of DARWIN programs,
we sketch a translation of the features of the language
into the pi-calculus, a formalism for modelling concurrent
processes. The match between underlying models
for DARWIN and pi-calculus is good. Examples done
in the calculus are clean abstractions of the same solutions
in other concurrent languages.},
  Url                      = {http://pubs.doc.ic.ac.uk/darwin-in-pi-calculus/}
}

@InProceedings{Kramer1989,
  Title                    = {Configuration Support for System Description, Construction and Evolution},
  Author                   = {Kramer, J. and Magee, J. and Sloman, M.},
  Booktitle                = {Proceedings of the 5th International Workshop on Software Specification and Design},
  Year                     = {1989},

  Address                  = {Pittsburgh, Pennsylvania, United States},
  Pages                    = {28--33},
  Publisher                = {ACM Press},

  Comment                  = {Defines configuration programming. Specifically mentions the need to be able to evolve the system at runtime, using change specifications. Uses CONIC (ADL + superset of Pascal) for examples. Interesting that it specifically creates an implementation language for implementing the components. Work is way ahead of its time, in a historical sense. Preceeds much of the OO era, yet is in many ways more advanced...
2005-10-23},
  ISSN                     = {0-89791-305-1},
  Keywords                 = {configuration, SPECIFICATION},
  Owner                    = {amcveigh},
  Refid                    = {30},
  Timestamp                = {2006.03.14},
  Url                      = {http://doi.acm.org/10.1145/75199.75204}
}

@InBook{Kramer2000,
  Title                    = {Software Architecture for Product Families: Principles and Practice},
  Author                   = {Kramer, K. and Magee, J. and Keng N. and Dulay, N.},
  Chapter                  = {2. Software Architecture Description},
  Editor                   = {Jazayeri, M. and Ran, A. and van der Linde, F.},
  Pages                    = {31-65},
  Publisher                = {Addison Wesley},
  Year                     = {2000},

  Owner                    = {amcveigh},
  Timestamp                = {2006.05.30}
}

@InProceedings{Krishnamurthi1998,
  Title                    = {Toward a Formal Theory of Extensible Software},
  Author                   = {Shriram Krishnamurthi and Matthias Felleisen},
  Booktitle                = {In SIGSOFT '98/FSE-6: Proceedings of the 6th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  Year                     = {1998},
  Pages                    = {88--98},
  Publisher                = {ACM Press},

  Abstract                 = {As software projects continue to grow in scale and scope, it becomes important to reuse software. An important kind of reuse is extensibility, i.e., the extension of software without accessing existing code to edit or copy it. In this paper, we propose a rigorous, semantics-based definition of software extensibility. Then we illustrate the utility of our definitions by applying them to several programs. The examination shows how programming style affects extensibility and also drives the creation of a variant of an existing design pattern. We consider programs in both object-oriented and functional languages to prove the robustness of our definitions},
  Owner                    = {andrew},
  Review                   = {Excellent definition of "extensible" in this paper:

"extensibility: the extension of software without accessing existing code to edit or copy it".},
  Timestamp                = {2009.03.18}
}

@Article{Krueger2006,
  Title                    = {New methods in Software Product Line Practice},
  Author                   = {Krueger, Charles W.},
  Journal                  = {Communications of the ACM},
  Year                     = {2006},
  Number                   = {12},
  Pages                    = {37--40},
  Volume                   = {49},

  Abstract                 = {Examining the benefits of next-generation SPL methods.},
  Address                  = {New York, NY, USA},
  Doi                      = {http://doi.acm.org/10.1145/1183236.1183262},
  ISSN                     = {0001-0782},
  Owner                    = {andrew},
  Publisher                = {ACM},
  Review                   = {nice definition of sorftware product lines.},
  Timestamp                = {2009.06.24}
}

@InCollection{Kulesza2006,
  Title                    = {Improving Extensibility of Object-Oriented Frameworks with Aspect-Oriented Programming},
  Author                   = {Kulesza, Uir\'{a} and Alves, Vander and Garcia, Alessandro and de Lucena, Carlos and Borba, Paulo},
  Booktitle                = {Lecture Notes in Computer Science},
  Publisher                = {Springer},
  Year                     = {2006},
  Pages                    = {231--245},

  Abstract                 = {Object-oriented frameworks are nowadays a common and useful technology used in the implementation of software system families. Despite their benefits, over the last years many researchers have described the inadequacy of object-oriented mechanisms to address the modularization and composition of many framework features, thus reducing the extent to which a framework can be extended. The crosscutting nature of many framework features is identified as one of the main causes of these problems. In this paper, we analyze how aspect-oriented programming can help to improve the design, implementation, and extension of object-oriented frameworks. We propose the concept of Extension Join Points (EJPs) as a way of designing and documenting existing crosscutting extension points. EJPs improve framework extensibility, including superior composability of the framework core functionality with other modules or frameworks. Four case studies of frameworks from diverse domains are presented to illustrate our proposal. This paper also discusses lessons learned on the application of our approach to the development and extension of these frameworks.},
  Citeulike-article-id     = {3743794},
  Doi                      = {10.1007/11763864\_17},
  Journal                  = {Reuse of Off-the-Shelf Components},
  Keywords                 = {aspectoriented, softwareengineering},
  Owner                    = {andrew},
  Posted-at                = {2008-12-03 19:08:57},
  Priority                 = {2},
  Timestamp                = {2009.03.31},
  Url                      = {http://dx.doi.org/10.1007/11763864\_17}
}

@InProceedings{Lai2000,
  Title                    = {Separating Concerns with Hyper/J: An Experience Report},
  Author                   = {Lai, A. and Murphy, G. and Walker, R.},
  Booktitle                = {Multi-Dimensional Separation of Concerns in Software
Engineering},
  Year                     = {2000},
  Pages                    = {79--91},

  Owner                    = {andrew},
  Timestamp                = {2009.03.31},
  Url                      = {http://pages.cpsc.ucalgary.ca/~rwalker/publications/lai2000a.pdf}
}

@InProceedings{Lau2006,
  Title                    = {Composing Components in Design Phase using Exogenous Connectors},
  Author                   = {Kung-Kiu Lau and Ling Ling and Zheng Wang},
  Booktitle                = {EUROMICRO '06: Proceedings of the 32nd EUROMICRO Conference on Software Engineering and Advanced Applications},
  Year                     = {2006},

  Address                  = {Washington, DC, USA},
  Pages                    = {12--19},
  Publisher                = {IEEE Computer Society},

  Abstract                 = {Composition can take place during different stages of component life cycle. We identify two main stages : design phase - components are composed into composite components for reuse; deployment phase - components are compiled and the resulting binaries are assembled into executable systems. Ideally, the design phase composition should maximise component reuse. However, this ideal is not realised in current component-based development because they can not reuse composite components in design phase. In this paper, we propose a novel approach for composing components in design phase using exogenous connectors. In contrast to existing composition approaches, our approach allows composite components built in design phase to be further reusable in both design and deployment phases so as to achieve both component reuse and design flexibility. We demonstrate the feasibility of our approach in an industrial-strength case study - Automatic Train Protection system, and compare them with the closely-related existing composition approaches.},
  Doi                      = {http://dx.doi.org/10.1109/EUROMICRO.2006.30},
  ISBN                     = {0-7695-2594-6},
  Review                   = {this is a very odd paper, but these guys are quite well published. an exogeneous connector is one that is not owned explicitly by a component -- it is "out of the family". In essence they propose putting all login in connectors and removing it from components. components can then only provide itnerfaces! connectors end up taking on most of the qualities of components, with no real benefit as far as I can see.

also -- seems to confuse the concept of component types and component instances. very poor...},
  Timestamp                = {2007.01.23}
}

@InProceedings{Lehman1976,
  Title                    = {Program Evolution and its Impact on Software Engineering},
  Author                   = {Lehman, M.M. and Parr, .F.N.},
  Booktitle                = {Proceedings of the 2nd International Conference on Software Engineering},
  Year                     = {1976},

  Address                  = {San Francisco, California, United States},
  Pages                    = {350--357},
  Publisher                = {IEEE Computer Society Press},

  Comment                  = {Looks at the forces of evolution on programs, and produces some metrics. Just skimmed.
2005-10-11},
  Owner                    = {amcveigh},
  Refid                    = {2},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=807698&coll=GUIDE&dl=GUIDE&CFID=57996419&CFTOKEN=31358059#}
}

@Article{Lehman1991,
  Title                    = {Software Engineering, the Software Process and Their Support},
  Author                   = {Lehman, M. M.},
  Journal                  = {Softw. Eng. J.},
  Year                     = {1991},

  Month                    = sep,
  Number                   = {5},
  Pages                    = {243--258},
  Volume                   = {6},

  Acmid                    = {137659},
  Address                  = {Herts, UK, UK},
  Doi                      = {10.1049/sej.1991.0028},
  ISSN                     = {0268-6961},
  Issue_date               = {Sept. 1991},
  Numpages                 = {16},
  Owner                    = {amcveigh},
  Publisher                = {Michael Faraday House},
  Timestamp                = {2015.07.02},
  Url                      = {http://dx.doi.org/10.1049/sej.1991.0028}
}

@Book{Lehrmann1993,
  Title                    = {Object-Oriented Programming in the Beta Programming Language},
  Author                   = {Lehrmann Madsen, Ole and Moller-Pedersen, Birger and Nygaard, Kristen},
  Publisher                = {Association for Computing Machinery},
  Year                     = {1993},

  Owner                    = {amcveigh},
  Timestamp                = {2007.07.10}
}

@TechReport{Leicher2004,
  Title                    = {A Framework for Identifying Compositional Conflicts in Component-Based Systems},
  Author                   = {Andreas Leicher},
  Institution              = {Computation and Information Structures, Technical University of Berline},
  Year                     = {2004},

  Owner                    = {amcveigh},
  Timestamp                = {2007.07.10}
}

@InProceedings{Li2008,
  Title                    = {View-Based Maintenance of Graphical User Interfaces},
  Author                   = {Li, Peng and Wohlstadter, Eric},
  Booktitle                = {AOSD '08: Proceedings of the 7th International Conference on Aspect-Oriented Software Development},
  Year                     = {2008},

  Address                  = {New York, NY, USA},
  Pages                    = {156--167},
  Publisher                = {ACM},

  Doi                      = {http://doi.acm.org/10.1145/1353482.1353501},
  ISBN                     = {978-1-60558-044-9},
  Location                 = {Brussels, Belgium},
  Owner                    = {andrew},
  Timestamp                = {2009.06.29}
}

@InProceedings{Magee1995,
  Title                    = {Specifying Distributed Software Architectures},
  Author                   = {Magee, Jeff and Dulay, Naranker and Eisenbach, Susan and Kramer Jeff},
  Booktitle                = {Proceedings of the 5th European Software Engineering Conference},
  Year                     = {1995},

  Address                  = {Sitges, Spain},
  Editor                   = {W. Schafer and P. Botella},
  Pages                    = {137--153},
  Publisher                = {Springer-Verlag, Berlin},
  Volume                   = {989},

  Abstract                 = {There is a real need for clear and sound design specica-
tions of distributed systems at the architectural level. This is the level
of the design which deals with the high-level organisation of computa-
tional elements and the interactions between those elements. The paper
presents the Darwin notation for specifying this high-level organisation.
Darwin is in essence a declarative binding language which can be used to
dene hierarchic compositions of interconnected components. Distribu-
tion is dealt with orthogonally to system structuring. The language sup-
ports the specication of both static structures and dynamic structures
which may evolve during execution. The central abstractions managed
by Darwin are components and services. Services are the means by which
components interact.
In addition to its use in specifying the architecture of a distributed sys-
tem, Darwin has an operational semantics for the elaboration of speci-
cations such that they may be used at runtime to direct the construction
of the desired system. The paper describes the operational semantics of
Darwin in terms of the -calculus, Milner's calculus of mobile processes.
The correspondence between the treatment of names in the -calculus
and the management of services in Darwin leads to an elegant and con-
cise -calculus model of Darwin's operational semantics. The model is
used to argue the correctness of the Darwin elaboration process. The
overall objective is to provide a soundly based notation for specifying
and constructing distributed software architectures.},
  Review                   = {The best paper (original?) on Darwin with full details of the semantics via a translation to pi-calculus also.},
  Url                      = {citeseer.ist.psu.edu/article/magee95specifying.html}
}

@Article{Magee1994,
  Title                    = {Regis: A Constructive Development Environment for Distributed Programs},
  Author                   = {Jeff Magee and Naranker Dulay and Jeff Kramer},
  Journal                  = {Distributed Systems Engineering Journal},
  Year                     = {1994},
  Pages                    = {304--312},
  Volume                   = {1},

  Owner                    = {andrew},
  Review                   = {Better paper than the SysMan one, but doesn't explain bindings in huge detail. The SysMan one does.},
  Timestamp                = {2009.04.15}
}

@Book{Magee1999,
  Title                    = {Concurrency (State Models and Java Programs)},
  Author                   = {Magee, J. and Kramer, J.},
  Publisher                = {John Wiley and Sons Ltd},
  Year                     = {2006},
  Edition                  = {2nd},

  Comment                  = {The seminal text on FSP and applying hierarchical techniques to practical architectures.},
  ISSN                     = {0 471 98710 7},
  Keywords                 = {concurrency, FSP, state},
  Owner                    = {amcveigh},
  Pages                    = {-},
  Refid                    = {78},
  Timestamp                = {2006.03.14}
}

@InProceedings{Magee1996,
  Title                    = {Dynamic Structure in Software Architectures},
  Author                   = {Magee, J. and Kramer, J.},
  Booktitle                = {Proceedings of the 4th ACM SIGSOFT Symposium on Foundations of Software Engineering},
  Year                     = {1996},

  Address                  = {San Francisco, California, United States},
  Pages                    = {3--14},
  Publisher                = {ACM Press},

  Comment                  = {239104
http://doi.acm.org/10.1145/239098.239104},
  ISSN                     = {0-89791-797-9},
  Keywords                 = {software architecture},
  Owner                    = {amcveigh},
  Refid                    = {58},
  Timestamp                = {2006.03.14}
}

@InBook{Martin2000,
  Title                    = {More C++ Gems},
  Author                   = {Martin,, Robert C.},
  Chapter                  = {The Open-Closed principle},
  Pages                    = {97--112},
  Publisher                = {Cambridge University Press},
  Year                     = {2000},

  Address                  = {New York, NY, USA},

  Book                     = {More C++ gems},
  ISBN                     = {0-521-78618-5},
  Owner                    = {andrew},
  Timestamp                = {2009.03.31}
}

@InProceedings{Mattsson1997,
  Title                    = {Framework Composition: Problems, Causes and Solutions},
  Author                   = {Mattsson, M. and Bosch, J.},
  Booktitle                = {Proceedings of the Tools-23: Technology of Object-Oriented Languages and Systems},
  Year                     = {1997},
  Pages                    = {203--},
  Publisher                = {IEEE Computer Society},

  Comment                  = {832661},
  ISSN                     = {0-8186-8383-X},
  Keywords                 = {SYSTEMS},
  Owner                    = {amcveigh},
  Refid                    = {62},
  Timestamp                = {2006.03.14}
}

@InProceedings{Mayer2003,
  Title                    = {Lightweight Plug-In-Based Application Development},
  Author                   = {Johannes Mayer and Ingo Melzer and Franz Schweiggert},
  Booktitle                = {NODe '02: Revised Papers from the International Conference NetObjectDays on Objects, Components, Architectures, Services, and Applications for a Networked World},
  Year                     = {2003},

  Address                  = {London, UK},
  Pages                    = {87--102},
  Publisher                = {Springer-Verlag},

  ISBN                     = {3-540-00737-7},
  Review                   = {nice paper on a plug-in pattern. very simple class diagram, nice mapping onto eclipse.}
}

@InBook{McIlroy1968,
  Title                    = {Mass Produced Software Components: NATO Science Committee Report},
  Author                   = {McIlroy, M.D.},
  Editor                   = {P. Naur and B. Randell},
  Publisher                = {NATO},
  Year                     = {1968},

  Booktitle                = {NATO Science Committee Report},
  Journal                  = {NATO Science Committee Report},
  Owner                    = {amcveigh},
  Timestamp                = {2006.05.30}
}

@Misc{McVeigh2008,
  Title                    = {{The Rich Engineering Heritage Behind Dependency Injection}},

  Author                   = {Andrew McVeigh},
  HowPublished             = {http://www.javalobby.org/articles/di-heritage},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.04.01},
  Url                      = {http://www.javalobby.org/articles/di-heritage}
}

@Misc{McVeigh2015,
  Title                    = {Evolve software suite},

  Author                   = {A McVeigh},
  Year                     = {2015},

  Owner                    = {amcveigh},
  Timestamp                = {2015.07.02},
  Url                      = {Retrieved from http://intrinsarc.com in 2015}
}

@PhdThesis{McVeigh2009,
  Title                    = {A rigorous, architectural approach to extensible systems},
  Author                   = {McVeigh, A},
  School                   = {Imperial College},
  Year                     = {2009},

  Owner                    = {amcveigh},
  Timestamp                = {2015.07.02},
  Url                      = {Retrieved from http://intrinsarc.com/research in 2015}
}

@InProceedings{McVeigh2011,
  Title                    = {Evolve: Tool Support for Architecture Evolution},
  Author                   = {McVeigh, Andrew and Kramer, Jeff and Magee, Jeff},
  Booktitle                = {Proceedings of the 33rd International Conference on Software Engineering},
  Year                     = {2011},

  Address                  = {New York, NY, USA},
  Pages                    = {1040--1042},
  Publisher                = {ACM},
  Series                   = {ICSE '11},

  Acmid                    = {1985990},
  Doi                      = {10.1145/1985793.1985990},
  ISBN                     = {978-1-4503-0445-0},
  Keywords                 = {software architecture evolution},
  Location                 = {Waikiki, Honolulu, HI, USA},
  Numpages                 = {3},
  Owner                    = {amcveigh},
  Timestamp                = {2015.07.02},
  Url                      = {http://doi.acm.org/10.1145/1985793.1985990}
}

@InProceedings{McVeigh2006,
  Title                    = {Using Resemblance to Support Component Reuse and Evolution},
  Author                   = {McVeigh, A. and Magee, J. and Kramer, J.},
  Booktitle                = {Specification and Verification of Component Based Systems Workshop},
  Year                     = {2006},

  Owner                    = {andrew},
  Timestamp                = {2006.10.04}
}

@PhdThesis{Medvidovic1999a,
  Title                    = {Architecture-Based Specification-Time Software Evolution},
  Author                   = {Medvidovic,, Nenad},
  School                   = {University of California, Irvine},
  Year                     = {1999},
  Note                     = {Taylor, Richard N.},

  ISBN                     = {0-599-10342-6},
  Order_no                 = {AAI9912025},
  Publisher                = {University of California, Irvine}
}

@InProceedings{Medvidovic1996,
  Title                    = {ADLs and Dynamic Architecture Changes},
  Author                   = {Medvidovic, N.},
  Booktitle                = {Joint Proceedings of the Second international Software Architecture Workshop (ISAW-2) and International Workshop on Multiple Perspectives in Software Development (Viewpoints '96)},
  Year                     = {1996},

  Address                  = {San Francisco, California, United States},
  Pages                    = {24--27},
  Publisher                = {ACM Press},

  Comment                  = {A paper discussion dynamic evolution of ADLs at runtime. Seems to focus on evolution rather than runtime instantiation of components. Motivation is upgrades, addition of new components etc.
2005-10-23},
  ISSN                     = {0-89791-867-3},
  Keywords                 = {software architecture},
  Owner                    = {amcveigh},
  Refid                    = {31},
  Timestamp                = {2006.03.14},
  Url                      = {http://doi.acm.org/10.1145/243327.243340}
}

@InProceedings{Medvidovic1996a,
  Title                    = {Using Object-Oriented Typing to Support Architectural Design in the C2 Style},
  Author                   = {Medvidovic, N. and Oreizy, P. and Robbins, J.E. and Taylor, R.N.},
  Booktitle                = {Proceedings of the 4th ACM SIGSOFT Symposium on Foundations of Software Engineering},
  Year                     = {1996},

  Address                  = {San Francisco, California, United States},
  Pages                    = {24--32},
  Publisher                = {ACM Press},

  Abstract                 = {Software architectures enable large-scale software development. Component reuse and substitutability, two key aspects of large-scale development, must be planned for during software design. Object-oriented (OO) type theory supports reuse by structuring inter-component relationships and verifying those relationships through type checking in an architecture definition language (ADL). In this paper, we identify the issues and discuss the ramifications of applying OO type theory to the C2 architectural style. This work stems from a series of experiments that were conducted to investigate component reuse and substitutability in C2. We also discuss the limits of applicability of OO typing to C2 and how we addressed them in the C2 ADL.},
  Comment                  = {This is a really good paper, which introduces the idea of placeholder components in an architecture. These are components which are only there to show the space and properties that a concrete extension component must provide.
2005-11-15},
  ISSN                     = {0-89791-797-9},
  Keywords                 = {software architecture, component, definition},
  Owner                    = {amcveigh},
  Refid                    = {48},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=239106&coll=Portal&dl=GUIDE&CFID=60884982&CFTOKEN=64386172#}
}

@InProceedings{Medvidovic1999,
  Title                    = {A Language and Environment for Architecture-Based Software Development and Evolution},
  Author                   = {Medvidovic, N. and Rosenblum, D.S. and Taylor, R.N.},
  Booktitle                = {ICSE '99: Proceedings of the 21st International Conference on Software Engineering},
  Year                     = {1999},

  Address                  = {Los Alamitos, CA, USA},
  Pages                    = {44--53},
  Publisher                = {IEEE Computer Society Press},

  ISBN                     = {1-58113-074-0},
  Location                 = {Los Angeles, California, United States}
}

@Article{Medvidovic2000,
  Title                    = {A Classification and Comparison Framework for Software Architecture Description Languages},
  Author                   = {Medvidovic, N. and Taylor, R.N.},
  Journal                  = {IEEE Transactions on Software Engineering},
  Year                     = {2000},

  Month                    = jan,
  Number                   = {1},
  Pages                    = {70--93},
  Volume                   = {26},

  Abstract                 = {Software architectures shift the focus of developers from lines-of-code to coarser-grained architectural elements and their overall interconnection structure. Architecture description languages (ADLs) have been proposed as modeling notations to support architecture-based development. There is, however, little consensus in the research community on what is an ADL, what aspects of an architecture should be modeled in an ADL, and which of several possible ADLs is best suited for a particular problem. Furthermore, the distinction is rarely made between ADLs on one hand and formal specification, module interconnection, simulation, and programming languages on the other. This paper attempts to provide an answer to these questions. It motivates and presents a definition and a classification framework for ADLs. The utility of the definition is demonstrated by using it to differentiate ADLs from other modeling notations. The framework is used to classify and compare several existing ADLs, enabling us, in the process, to identify key properties of ADLs. The comparison highlights areas where existing ADLs provide extensive support and those in which they are deficient, suggesting a research agenda for the future},
  Address                  = {Univ So Calif, Dept Comp Sci, Los Angeles, CA 90007 USA Univ Calif Irvine, Dept Informat \& Comp Sci, Irvine, CA 92697 USA},
  Comment                  = {Times Cited: 72 Article English Medvidovic, N Univ So Calif, Dept Comp Sci, Los Angeles, CA 90007 USA Cited References Count: 74
Read this before starting phd. It looks at the underlying concepts of ADLs and distills a feature graph that ADLs map onto. Interesting features are "implementation generation" and "evolution". Not entirely sure if evolution represents run-time or design-time (pretty sure it is design-time). Then maps a number of existing ADLs onto the feature set (including Darwin). Of interest in table 2 is the fact that evolution is particularly poorly supported. This area is ripe for doing work on... Strangely, they haven't seemed to have picked up on the Jeffs work on structural evolution for ADLs. Maybe this didn't form part of Darwin?
2004-01-01},
  ISSN                     = {0098-5589},
  Keywords                 = {architecture description language, CALCULUS, classification, comparison, component, configuration, connector, definition, MOBILE PROCESSES, software architecture, SPECIFICATION, SYSTEMS},
  Owner                    = {amcveigh},
  Refid                    = {25},
  Timestamp                = {2006.03.14},
  Url                      = {ISI:000085891100005}
}

@InProceedings{mehta02evolving,
  Title                    = {Evolving Legacy System Features into Fine-Grained Components},
  Author                   = {A. Mehta and G. Heineman},
  Booktitle                = {24th International Conference on Software Engineering},
  Year                     = {2002},

  Abstract                 = {There is a constant need for practical, efficient, and cost-effective software evolution techniques. We propose a novel evolution methodology that integrates the concepts of features, regression tests, and component-based software engineering (CBSE). Regression test cases are untapped resources, full of information about system features. By exercising each feature with its associated test cases using code profilers and similar tools, code can be located and refactored to create components. These components are then inserted back into the legacy system, ensuring a working system structure. This methodology is divided into three parts. Part one identifies the source code associated with features that need evolution. Part two deals with creating components and part three measures results. By applying this methodology, AFS has successfully restructured its enterprise legacy system and reduced the costs of future maintenance. Additionally, the components that were refactored from the legacy system are currently being used within a web-enabled application.},
  Review                   = {this is simplistive -- concerned mainly with evolving legacy systems. read 5 pages -- no real mean, no real intersection with my work.},
  Text                     = {A. Mehta and G. T. Heineman. Evolving legacy system features into fine-grained components. In Proceedings of the 24th International Conference on Software Engineering, pages 417--427. ACM Press, 2002.},
  Timestamp                = {2006.03.20},
  Url                      = {citeseer.ist.psu.edu/mehta02evolving.html}
}

@Article{Meijer2002,
  Title                    = {Overcoming Independent Extensibility Challenges},
  Author                   = {Meijer, E. and Szyperski, C.},
  Journal                  = {Communications of the ACM},
  Year                     = {2002},
  Number                   = {10},
  Pages                    = {41--44},
  Volume                   = {45},

  Abstract                 = {As Huxley observed, it isn't always clear what a name is supposed to stand for. In this article we go beyond prosaic observations and analyze aspects of the challenge posed by requirements of independent extensibility. Independent extensibility amounts to the use of software components beyond source sharing. Examples of independent extensibility include operating systems supporting independently developed applications, as well as applications supporting independently developed plug-ins. As a consequence of independent extensibility, we must to deal with multiple versions of components, which is a difficult problem. Relating back to the development and deployment process, we show how name resolution issues are often at the heart of this problem.},
  Comment                  = {Not particularly insightful or useful. Looks at need for versioning and proposes side-by-side running of different versions except in cases where this represents a unique external resource.
2005-12-05},
  ISSN                     = {0001-0782},
  Keywords                 = {component, SYSTEMS},
  Owner                    = {amcveigh},
  Publisher                = {ACM Press},
  Refid                    = {74},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=570929#}
}

@Article{Mencl2004,
  Title                    = {Specifying Component Behavior with Port State Machines},
  Author                   = {Vladimir Mencl},
  Journal                  = {Electronic Notes in Theoretical Computer Science},
  Year                     = {2004},
  Note                     = {Special issue: Proceedings of the Workshop on the Compositional Verification of UML Models CVUML Edited by F. de Boer and M. Bonsangue},
  Pages                    = {129-153},
  Volume                   = {101C},

  Abstract                 = {Protocol State Machines (PSM) in UML 2.0 [13] describe valid sequences of operation
calls. To support modeling components, UML 2.0 introduces a Port associated
with a set of provided and required interfaces. Unfortunately, a PSM is applicable
only to a single interface, either a provided or required one; moreover, nested
calls cannot be modeled with a PSM. Furthermore, the definition of protocol conformance
is rather fuzzy and reasoning on this relation is not possible in general;
thus reasoning on consistency in component composition is not possible with PSMs.
Behavior Protocols [17] capture the behavior of a component via a set of traces.
A textual notation similar to regular expressions is provided to approximate the
behavior with a regular language. In [1,17], the compliance relation and consent
operator are defined to reason on consistency of component composition; a verifier
tool [18] is available for the compliance relation.
In this paper, we propose the Port State Machine (PoSM) to model the communication
on a Port. Building on our experience with behavior protocols, we model
an operation call as two atomic events request and response, permitting PoSM to
capture the interleaving and nesting of operation calls on provided and required
interfaces of the Port. The trace semantics of PoSM yields a regular language. We
apply the compliance relation of behavior protocols to PoSMs, allowing us to reason
on behavior compliance of components in software architectures; the existing
verifier tool can be applied to PoSMs.},
  Review                   = {very strong on UML2.

uses a simplified form of UML23 state machines (no actions of guards). defines a mapping to behaviour protocols.

Q? how does composition work, concurrency etc. why can't guards be used?

what decided the choice points.

this led to my idea of decomposing the behaviour as a set of nested componnets resembling a state diagram.},
  Url                      = {citeseer.ist.psu.edu/article/mencl04specifying.html}
}

@Article{Mens2005,
  Title                    = {Detecting Structural Refactoring Conflicts Using Critical Pair Analysis},
  Author                   = {Tom Mens and Gabriele Taentzer and Olga Runge},
  Journal                  = {Electronic Notes in Theoretical Computer Science},
  Year                     = {2005},

  Month                    = {April},
  Number                   = {3},
  Pages                    = {113-128},
  Volume                   = {127},

  Abstract                 = {Refactorings are program transformations that improve the software structure while preserving the external behaviour. In spite of this very useful property, refactorings can still give rise to structural conflicts when parallel evolutions to the same software are made by different developers. This paper explores this problem of structural evolution conflicts in a formal way by using graph transformation and critical pair analysis. Based on experiments carried out in the graph transformation tool AGG, we show how this formalism can be exploited to detect and resolve refactoring conflicts.},
  Booktitle                = {Proceedings of the Workshop on software evolution through transformations: model-based versus implementation-level solutions},
  Editor                   = {Reiko Heckel and Tom Mens},
  Publisher                = {Elsevier Science},
  Review                   = {uses graph rewriting on attributed graphs to analyse a set of refactorings. has an oo metamodel. then uses "critical pair" analysis to see how independent refactorings conflict over time for parallel development.

a bit simplistic -- only considers one parallel change, combined with one other parallel change. not particularly practical.},
  Timestamp                = {2006.08.07}
}

@Article{Mernik2005,
  Title                    = {When and How to Develop Domain-Specific Languages},
  Author                   = {Mernik, Marjan and Heering, Jan and Sloane, Anthony M.},
  Journal                  = {ACM Computing Survey},
  Year                     = {2005},
  Number                   = {4},
  Pages                    = {316--344},
  Volume                   = {37},

  Address                  = {New York, NY, USA},
  Doi                      = {http://doi.acm.org/10.1145/1118890.1118892},
  ISSN                     = {0360-0300},
  Owner                    = {andrew},
  Publisher                = {ACM},
  Timestamp                = {2009.06.14}
}

@Book{Meyer1997,
  Title                    = {Object-Oriented Software Construction},
  Author                   = {Meyer,, Bertrand},
  Editor                   = {Second edition},
  Publisher                = {Prentice-Hall, Inc.},
  Year                     = {1997},

  Address                  = {Upper Saddle River, NJ, USA},

  ISBN                     = {0-13-629155-4},
  Owner                    = {andrew},
  Timestamp                = {2009.03.31}
}

@Article{mezini97dynamic,
  Title                    = {Dynamic Object Evolution without Name Collisions},
  Author                   = {Mira Mezini},
  Journal                  = {Lecture Notes in Computer Science},
  Year                     = {1997},
  Pages                    = {190--219},
  Volume                   = {1241},

  Review                   = {places a layer b/w an object (and its identity) and the bits that implement the behaviour. the combiner keeps track of the scope and methods (figure 4) to select a sub-object based on context.

this seemed to me to be badly written, with complex descriptions. it describes a system with no real examples.},
  Timestamp                = {2005.12.05},
  Url                      = {citeseer.ist.psu.edu/mezini97dynamic.html}
}

@Misc{Microsoft2006,
  Title                    = {{COM: Component Object Model Technologies}},

  Author                   = {Microsoft},
  HowPublished             = {http://www.microsoft.com/com/default.mspx},
  Year                     = {last accessed August 2009},

  Journal                  = {Website},
  Owner                    = {amcveigh},
  Review                   = {COM model from the horse's mouth...},
  Timestamp                = {2006.05.15},
  Url                      = {http://www.microsoft.com/com/default.mspx},
  Volume                   = {http://www.microsoft.com/com/default.mspx}
}

@Misc{Microsoft2006a,
  Title                    = {{Microsoft Office Online: Excel 2003 Home Page}},

  Author                   = {Microsoft},
  HowPublished             = {http://office.microsoft.com/en-gb/FX010858001033.aspx},
  Year                     = {last accessed August 2009},

  Journal                  = {Website},
  Owner                    = {amcveigh},
  Review                   = {Eclipse plugin site, showing thousands of plugins.},
  Timestamp                = {2006.05.15},
  Url                      = {http://office.microsoft.com/en-gb/FX010858001033.aspx},
  Volume                   = {http://office.microsoft.com/en-gb/FX010858001033.aspx}
}

@Misc{Microsoft,
  Title                    = {{.Net Assemblies}},

  Author                   = {{Microsoft .Net Framework Development Center}},
  HowPublished             = {http://msdn.microsoft.com/en-us/library/hk5f40ct%28VS.71%29.aspx},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.07.28},
  Url                      = {http://msdn.microsoft.com/en-us/library/hk5f40ct%28VS.71%29.aspx}
}

@InProceedings{Milewski1997,
  Title                    = {Distributed Source Control System},
  Author                   = {Bartosz Milewski},
  Booktitle                = {ICSE '97: Proceedings of the SCM-7 Workshop on System Configuration Management},
  Year                     = {1997},

  Address                  = {London, UK},
  Pages                    = {98--107},
  Publisher                = {Springer-Verlag},

  ISBN                     = {3-540-63014-7},
  Review                   = {decent paper with nice diagrams on distributed source code control. i think this is the first example I've found of something that is open (i.e. not peer to peer)}
}

@Book{Milner1999,
  Title                    = {Communicating and Mobile Systems: the pi-Calculus},
  Author                   = {Robin Milner},
  Publisher                = {Cambridge University Press},
  Year                     = {1999},

  Owner                    = {andrew},
  Timestamp                = {2009.04.06}
}

@Article{Minsky2000,
  Title                    = {Law-Governed Interaction: A Coordination and Control Mechanism for Heterogeneous Distributed Systems},
  Author                   = {Minsky, N.H. and Ungureanu, V.},
  Journal                  = {ACM Trans.Softw.Eng.Methodol.},
  Year                     = {2000},
  Number                   = {3},
  Pages                    = {273--305},
  Volume                   = {9},

  Abstract                 = {Software technology is undergoing a transition from monolithic systems, constructed according to a single overall design, into conglomerates of semiautonomous, heterogeneous, and independently designed subsystems, constructed and managed by different organizations, with little, if any, knowledge of each other. Among the problems inherent in such conglomerates, none is more serious than the difficulty to control the activities of the disparate agents operating in it, and the difficulty for such agents to coordinate their activities with each other. We argue that the nature of coordination and control required for such systems calls for the following principles to be satisfied: (1) coordination policies need to be enforced; (2) the enforcement needs to be decentralized; and (3) coordination policies need to be formulated explicitly-rather than being implicit in the code of the agents involved-and they should be enforced by means of a generic, broad spectrum mechanism; and (4) it should be possible to deploy and enforce a policy incrementally, without exacting any cost from agents and activities not subject to it. We describe a mechanism called law-governed interaction (LGI), currently implemented by the Moses toolkit, which has been designed to satisfy these principles. We show that LGI is at least as general as a conventional centralized coordination mechanism (CCM), and that it is more scalable, and generally more efficient, than CCM.},
  Comment                  = {Defines a system called LGI which allows for centralised coordination and control activities to be decentralised. This allows for more efficient and scalable implementation. The system protects itself as it doesn't always require the voluntary participation of agents in order to establish and enforce its policies.
2005-10-26},
  ISSN                     = {1049-331X},
  Keywords                 = {SYSTEMS},
  Owner                    = {amcveigh},
  Publisher                = {ACM Press},
  Refid                    = {38},
  Timestamp                = {2006.03.14}
}

@Misc{Corporation2006,
  Title                    = {{Firefox Internet Browser}},

  Author                   = {{Mozilla Corporation}},
  HowPublished             = {http://www.mozilla.com},
  Year                     = {last accessed August 2009},

  Journal                  = {Website},
  Owner                    = {andrew},
  Review                   = {decent explanation of the main focus of the eclipse platform, including plugin architecture.},
  Timestamp                = {2008.04.01},
  Url                      = {http://www.mozilla.com},
  Volume                   = {http://www.mozilla.com}
}

@Misc{Fireextensions2007,
  Title                    = {{Firefox Extensions}},

  Author                   = {{Mozilla Developer Center}},
  HowPublished             = {http://developer.mozilla.org/en/docs/Extensions},
  Year                     = {last accessed August 2009},

  Owner                    = {amcveigh},
  Timestamp                = {2007.06.25},
  Url                      = {http://developer.mozilla.org/en/docs/Extensions},
  Volume                   = {http://developer.mozilla.org/en/docs/Extensions}
}

@Misc{Firefoxplugins2008,
  Title                    = {{Firefox Plugins}},

  Author                   = {{Mozilla Developer Center}},
  HowPublished             = {http://developer.mozilla.org/en/docs/\\\-Plugins},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2008.04.01},
  Url                      = {http://developer.mozilla.org/en/docs/Plugins},
  Volume                   = {http://developer.mozilla.org/en/docs/Plugins}
}

@PhdThesis{Nelson2003,
  Title                    = {Formal Verification of Projection-Based Software Systems},
  Author                   = {Nelson,, Torsten Paul},
  School                   = {University of Waterloo, Ontario, Canada},
  Year                     = {2003},

  Abstract                 = {Recent implementation languages such as AspectJ and HyperJ allow systems to be decomposed into declaratively complete units. These units are projections of the system, which are partial implementations of the entire system where each program element such as a data structure or procedure may be partially defined in more than one projection. In contrast, traditional languages rely on units that are partitions, which are complete implementations of part of the system: every program element is defined in only one part. Projection-based approaches offer low coupling between units leading to programs that may be easier to maintain and extend.

These implementation languages for projection-based systems offer facilities for composing projections to form a complete software package. This composition usually yields a number of complex interactions between the projections. Some of these interactions may manifest themselves as inconsistencies such as undesired interference among projections. Formal verification is an effective mechanism for detecting inconsistencies. However, existing formal specification languages do not provide the means to express the interactions between projections in a clear and concise fashion.

Existing projection-based implementation languages perform composition using a similar set of basic constructs. The goal of this work is to find representation of projection composition and an approach to formal verification of projection-based systems. In order to accomplish this goal, a formal model of the composition mechanisms used in projection-based languages was developed. This model serves as the semantic basis for C3, a language for formally specifying the composition of projections. An analyst who decomposes a formal specification into projections can compose these projections using C3. A C3 description is easily translated to an implementation in a projection-based language. The original projections and the composed specifications can be verified for desired properties. The C3 language and verification approach are demonstrated through two case studies, one using the Alloy language, and another using the Finite State Process (FSP) language. The contributions of this thesis include: a formal model of the mechanisms for composing projections to produce a complete program; C3, a language for specifying the composition of projections; and approaches to verifying properties of compositions specified using C3, and properties of projections written in different formal specification languages. These contributions increase the body of knowledge regarding the underlying principles of projection-based languages.},
  ISBN                     = {0-612-83013-6},
  Order_no                 = {AAINQ83013},
  Owner                    = {andrew},
  Publisher                = {University of Waterloo},
  Review                   = {Explains how projection based systems such as hyper/j and aspect/j can cause unwanted interference between aspects / slices.},
  Timestamp                = {2009.03.31}
}

@Article{Ng1996,
  Title                    = {A CASE Tool for Software Architecture Design},
  Author                   = {Ng K., Kramer J, Magee J.},
  Journal                  = {Automated Software Engineering},
  Year                     = {1996},
  Pages                    = {261--284},
  Volume                   = {3},

  Owner                    = {amcveigh},
  Timestamp                = {2007.07.09},
  Url                      = {http://www.ingentaconnect.com/content/klu/ause/1996/00000003/F0020003/00111703}
}

@InProceedings{Ng1995,
  Title                    = {The Software Architect's Assistant-A Visual Environment for Distributed Programming},
  Author                   = {Keng Ng and J. Kramer and J. Magee and N. Dulay},
  Booktitle                = {HICSS '95: Proceedings of the 28th Hawaii International Conference on System Sciences (HICSS'95)},
  Year                     = {1995},

  Address                  = {Washington, DC, USA},
  Pages                    = {254},
  Publisher                = {IEEE Computer Society},

  ISBN                     = {0-8186-6935-7}
}

@InProceedings{Nierstrasz1993,
  Title                    = {Regular Types for Acctive Objects},
  Author                   = {Nierstrasz, O.},
  Booktitle                = {Proceedings of the Eighth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications},
  Year                     = {1993},

  Address                  = {Washington, D.C., United States},
  Pages                    = {1--15},
  Publisher                = {ACM Press},

  Abstract                 = {Previous work on type-theoretic foundations for object-oriented programming languages has mostly focussed on applying or extending functional type theory to functional "objects."This approach, while benefitting from a vast body of existing literature, has the disadvantage of dealing with state change either in a roundabout way or not at all, and completely side-stepping issues of concurrency. In particular, dynamic issues of non-uniform service availability and conformance to protocols are not addressed by functional types. We propose a new type framework that characterizes objects as regular (finite state) processes that provide guarantees of service along public channels. We also propose an original notion of subtyping for regular types that extends Wegner and Zdonik's "principle of substitutability" to non-uniform service availability, and we relate it to known process equivalences. Finally, we formalize what it means to "satisfy a client's expectations," and we show how regular types can be used to tell when sequential or concurrent clients are satisfied.},
  Comment                  = {Excellent paper, looking at assigning protocols to objects, and treating the protocol as a regular type. Seminal. Regular types are contrasted with service types.
2006-03-01},
  ISSN                     = {0-89791-587-9},
  Keywords                 = {SYSTEMS},
  Owner                    = {amcveigh},
  Refid                    = {77},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=167976#}
}

@InProceedings{Nistor2005,
  Title                    = {ArchEvol: Versioning Architectural-Implementation Relationships},
  Author                   = {Nistor,, Eugen C. and Erenkrantz,, Justin R. and Hendrickson,, Scott A. and van der Hoek,, Andr\'{e}},
  Booktitle                = {SCM '05: Proceedings of the 12th International Workshop on Software Configuration Management},
  Year                     = {2005},

  Address                  = {New York, NY, USA},
  Pages                    = {99--111},
  Publisher                = {ACM},

  Doi                      = {http://doi.acm.org/10.1145/1109128.1109136},
  ISBN                     = {1-59593-310-7},
  Location                 = {Lisbon, Portugal}
}

@Misc{NoMagic2009,
  Title                    = {{MagicDraw UML}},

  Author                   = {{No Magic Inc.}},
  HowPublished             = {http://magicdraw.com/},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.06.09},
  Url                      = {http://magicdraw.com/}
}

@Article{Nystrom2004,
  Title                    = {Scalable Extensibility via Nested Inheritance},
  Author                   = {Nathaniel Nystrom and Stephen Chong and Andrew C. Myers},
  Journal                  = {ACM SIGPLAN Notices},
  Year                     = {2004},
  Number                   = {10},
  Pages                    = {99--115},
  Volume                   = {39},

  Address                  = {New York, NY, USA},
  Doi                      = {http://doi.acm.org/10.1145/1035292.1028986},
  ISSN                     = {0362-1340},
  Publisher                = {ACM Press}
}

@Article{O.Gruber2005,
  Title                    = {The Eclipse 3.0 platform: adopting OSGi technology},
  Author                   = {O.Gruber and B.J.Hargrave and J.McAffer and P.Rapicault and T.Watson},
  Journal                  = {IBM Systems Journal},
  Year                     = {2005},
  Number                   = {2},
  Pages                    = {289--299},
  Volume                   = {44},

  Comment                  = {1086616},
  ISSN                     = {0018-8670},
  Owner                    = {amcveigh},
  Publisher                = {IBM Corp.},
  Refid                    = {55},
  Timestamp                = {2006.03.14}
}

@Book{O'Neill1998,
  Title                    = {JavaBeans from the Ground Up},
  Author                   = {Joseph O'Neill},
  Publisher                = {Osborne/McGraw-Hill},
  Year                     = {1998},

  Owner                    = {andrew},
  Review                   = {the book kieron gave me on javabeans -- quite good.},
  Timestamp                = {2009.06.09}
}

@Misc{O'Sullivan2009,
  Title                    = {{Mercurial: The Definitive Guide}},

  Author                   = {Byran O'Sullivan},
  HowPublished             = {http://hgbook.red-bean.com/read/},
  Year                     = {2009},

  Owner                    = {andrew},
  Timestamp                = {2009.04.04},
  Url                      = {http://hgbook.red-bean.com/read/}
}

@Misc{OMG2004,
  Title                    = {{Catalog of OMG CORBA and IIOP Specifications}},

  Author                   = {{Object Management Group}},
  HowPublished             = {http://www.omg.org/technology/documents/corba\_spec\_catalog.htm},
  Year                     = {last accessed August 2009},

  Journal                  = {Website},
  Owner                    = {amcveigh},
  Timestamp                = {2006.05.15},
  Url                      = {http://www.omg.org/technology/documents/corba_spec_catalog.htm}
}

@Misc{OMG2006,
  Title                    = {{Model Driven Architecture}},

  Author                   = {{Object Management Group}},
  HowPublished             = {http://www.omg.org/mda/},
  Year                     = {last accessed August 2009},

  Journal                  = {Website},
  Owner                    = {amcveigh},
  Review                   = {Eclipse plugin site, showing thousands of plugins.},
  Timestamp                = {2006.05.15},
  Url                      = {http://www.omg.org/mda/}
}

@Misc{OMG2006a,
  Title                    = {{CORBA Component Model Specification, v4.0}},

  Author                   = {{Object Management Group}},
  HowPublished             = {http://www.omg.org/technology/documents/formal/components.htm},
  Year                     = {last accessed August 2009},

  Journal                  = {Website},
  Owner                    = {amcveigh},
  Timestamp                = {2007.07.09},
  Url                      = {http://www.omg.org/technology/documents/formal/components.htm}
}

@Misc{OMG2007,
  Title                    = {{MOF 2.0 / XMI Mapping Specification, v2.1.1}},

  Author                   = {{Object Management Group}},
  HowPublished             = {http://www.omg.org/docs/formal/07-12-01.pdf},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.06.09},
  Url                      = {http://www.omg.org/docs/formal/07-12-01.pdf}
}

@Misc{OMGUML,
  Title                    = {{UML 2.0 Specification}},

  Author                   = {{Object Management Group}},
  HowPublished             = {http://www.omg.org/spec/UML/2.0/},
  Year                     = {last accessed August 2009},

  Journal                  = {Website},
  Owner                    = {amcveigh},
  Review                   = {Eclipse plugin site, showing thousands of plugins.},
  Timestamp                = {2006.05.15},
  Url                      = {http://www.omg.org/technology/documents/formal/uml.htm}
}

@Misc{Object2001a,
  Title                    = {{Eclipse Platform}},

  Author                   = {{Object Technology International Inc.}},
  HowPublished             = {http://www.eclipse.org},
  Year                     = {last accessed August 2009},

  Journal                  = {URL},
  Owner                    = {amcveigh},
  Review                   = {decent explanation of the main focus of the eclipse platform, including plugin architecture.},
  Timestamp                = {2006.05.15},
  Url                      = {http://www.eclipse.org},
  Volume                   = {http://www.eclipse.org}
}

@Misc{Object2005,
  Title                    = {{Eclipse Plugin Central}},

  Author                   = {{Object Technology International Inc.}},
  HowPublished             = {http://www.eclipseplugincentral.com/},
  Year                     = {last accessed August 2009},

  Journal                  = {Website},
  Owner                    = {amcveigh},
  Review                   = {Eclipse plugin site, showing thousands of plugins.},
  Timestamp                = {2006.05.15},
  Url                      = {http://www.eclipseplugincentral.com/},
  Volume                   = {http://www.eclipseplugincentral.com/}
}

@Misc{Object2001,
  Title                    = {{Eclipse Platform Technical Overview}},

  Author                   = {{Object Technology International Inc.}},
  HowPublished             = {http://www.eclipse.org/whitepapers/eclipse-overview.pdf},
  Year                     = {last access August 2009},

  Journal                  = {Technical Report},
  Owner                    = {amcveigh},
  Review                   = {decent explanation of the main focus of the eclipse platform, including plugin architecture.},
  Timestamp                = {2006.05.15},
  Url                      = {http://www.eclipse.org/whitepapers/eclipse-overview.pdf},
  Volume                   = {http://www.eclipse.org/whitepapers/eclipse-overview.pdf}
}

@Misc{Stan4J,
  Title                    = {{STAN: Structural Analysis for Java}},

  Author                   = {{Odysseus Software GmbH}},
  HowPublished             = {http://stan4j.com/},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.07.24},
  Url                      = {http://stan4j.com/}
}

@Article{Koeth2001,
  Title                    = {Abstraction in Graph-Transformation Based Diagram Editors},
  Author                   = {Oliver Köth , Mark Minas},
  Journal                  = {Electronic Notes in Theoretical Computer Science},
  Year                     = {2001},
  Number                   = {3},
  Pages                    = {1-7},
  Volume                   = {50},

  Abstract                 = {This extended abstract recalls how visual language editors benefit from graph grammars and how the editor-generator DiaGen is based on this approach. We then outline how generated editors can create abstract diagram representations for further processing, e. g. for communication with other tools or for diagram visualizations with varying, adjustable detail level which is a valuable aid when editing large diagrams. These concepts are illustrated with UML class diagrams.},
  Bibsource                = {DBLP, http://dblp.uni-trier.de},
  Ee                       = {http://www.elsevier.com/gej-ng/31/29/23/85/29/show/Products/notes/index.htt\#011},
  Timestamp                = {2006.08.07}
}

@InProceedings{Oliver2006,
  Title                    = {On UML's Composite Structure Diagram},
  Author                   = {Ian Oliver and Vesa Luukala},
  Booktitle                = {Fifth Workshop on System Analysis and Modelling},
  Year                     = {2006},

  Address                  = {Kaiserslautern, Germany},

  Abstract                 = {The composite structure diagram and related notions have
been introduced into UML2.0 to supplement already existing artifacts
such as classes. However the usage of these constructs by engineers
and/or modellers is not always in the spirit of inventors of these constructs.
A number of additional interpretations develop which are not
always consistent with the intended usage of the structure nor with the
language itself. Understanding these additional usages assists in understanding
areas of ambiguity, extension, inconsistency and the future development
of the language.},
  Owner                    = {andrew},
  Review                   = {A really helpful paper explaining in detail about how composite structure diagrams translate into class diagrams. Also the 1st paper I have seen that describes how UML allows behaviour at the composite level, whereas SDL and ROOM do not. In the former case, hidden/private ports make complete sense.},
  Timestamp                = {2008.05.13}
}

@Article{Ommering2003,
  Title                    = {Horizontal Communication: A Style to Compose Control Software},
  Author                   = {van Ommering, R.},
  Journal                  = {Software - Practice And Experience},
  Year                     = {2003},
  Number                   = {12},
  Pages                    = {1117--1150},
  Volume                   = {33},

  Abstract                 = {Consumer products become more complex and diverse, integrating functions that were previously available only in separate products. We believe that to build such products efficiently, a compositional approach is required. While this is quite feasible in hardware, we would like to achieve the same in software, especially in the low-level software that drives the hardware. We found this to be possible, but only if we let software components communicate horizontally, exchanging information along software channels that mirror the hardware signal topology. In this paper a concrete protocol implementing this style of control is described and many examples are given of its use.},
  Comment                  = {Interesting idea of forming a component signal bus, with protocols, to allow components to remain topology-agnostic. i.e. can form a bus that properties are published on, and it doesn't matter where in the bus a consumer is.
2005-11-03},
  ISSN                     = {0038-0644},
  Keywords                 = {component},
  Owner                    = {amcveigh},
  Publisher                = {John Wiley \& Sons, Inc.},
  Refid                    = {43},
  Timestamp                = {2006.03.14},
  Url                      = {http://www3.interscience.wiley.com/cgi-bin/abstract/104556449/ABSTRACT}
}

@InProceedings{Ommering2002,
  Title                    = {Building Product Populations with Software Components},
  Author                   = {van Ommering, R.},
  Booktitle                = {ICSE '02: Proceedings of the 24th International Conference on Software Engineering},
  Year                     = {2002},

  Address                  = {New York, NY, USA},
  Pages                    = {255--265},
  Publisher                = {ACM Press},

  Abstract                 = {Two trends have made reuse of embedded software for consumer electronics an urgent issue: the software of individual products becomes more and more complex, and the market demands a larger variety of products at an increasing rate. For that reason, various business groups within Philips organize their products as product families. A third trend is the integration of functions that until now were only found in separate products (e.g. a TV with Dolby Digital sound and a built-in DVD player). This requires software reuse between product families, which - when organized systematically - leads to a product population approach.We have set up such a product population approach, and applied it in various business groups within our organization. We use a component technology that stimulates context independence, and allows the composition of new products out of existing parts. We use an architectural description language to explicitly describe the architecture, and also to generate efficient bindings. We have aligned our development process and organization with the new 'compositional' way of working. This paper outlines our approach and reports on our experiences with it.},
  Doi                      = {http://doi.acm.org/10.1145/581339.581373},
  ISBN                     = {1-58113-472-X},
  Location                 = {Orlando, Florida},
  Review                   = {A very nice paper, which outlines how Koala deals with composability and variability. In the case of the former, it handles it via Koala specs which have documentation and unit tests. In the case of the latter, it handles it with parameterisation, and variability interfaces. Also, if a component differs from the requirements, then the subcomponents are used to build a new component which does support the requirements.

Leaves a lot of nice space for BB, in that BB can be used to achieve this level of variability. Further, mcveiBB can be used to support testing of composite components by removing some of the internals and replacing them with mocks.}
}

@InProceedings{Ommering2000,
  Title                    = {Mechanisms for Handling Diversity in a Product Population},
  Author                   = {van Ommering, R.},
  Booktitle                = {ISAW-4: The Fourth International Software Architecture Workshop},
  Year                     = {2000},

  Owner                    = {amcveigh},
  Timestamp                = {2006.07.19}
}

@InProceedings{Oplustil2003,
  Title                    = {Inheritance in Architecture Description Languages},
  Author                   = {Oplustil, T.},
  Booktitle                = {Proceedings of the Week of Doctoral Students 2003 Conference (WDS 2003)},
  Year                     = {2003},

  Abstract                 = {This paper explores ways by which inheritance can be defined for and used in
specification languages, especially ADLs and CDLs that are now widely used in software
engineering for specifying software architectures and components. The fact that most
specification languages share many properties with object oriented languages � which use
inheritance for variety of purposes � is the main motivation for this research. We will analyze
the roles of the inheritance concept in specification languages and try to find criteria for
evaluating it. The main focus, however, will be on proposing inheritance for the main
abstractions of SOFA CDL � a practically used component definition language. An introduction
of inheritance mechanisms for the SOFA CDL interfaces, frames and architectures is also the
main results presented in this paper.},
  Owner                    = {amcveigh},
  Review                   = {master's student work.

relevant as it includes a description of frame and architecture (insides) inheritance. look at concatenation inheritance.

includes many relevant statements, particularly about substitutability.},
  Timestamp                = {2006.06.17}
}

@InProceedings{Oreizy1998,
  Title                    = {Architecture-Based Runtime Software Evolution},
  Author                   = {Oreizy,, Peyman and Medvidovic,, Nenad and Taylor,, Richard N.},
  Booktitle                = {ICSE '98: Proceedings of the 20th International Conference on Software Engineering},
  Year                     = {1998},

  Address                  = {Washington, DC, USA},
  Pages                    = {177--186},
  Publisher                = {IEEE Computer Society},

  Abstract                 = {Continuous availability is a critical requirement for an
important class of software systems. For these systems,
runtime system evolution can mitigate the costs and risks
associated with shutting down and restarting the system for
an update. We present an architecture-based approach to
runtime software evolution and highlight the role of software
connectors in supporting runtime change. An initial
implementation of a tool suite for supporting the runtime
modification of software architectures, called ArchStudio, is
presented.},
  ISBN                     = {0-8186-8368-6},
  Location                 = {Kyoto, Japan},
  Review                   = {seems to add little to the jeffs work on dynamic architectural change. no mention of hierarchy.}
}

@Misc{Alliance2005,
  Title                    = {{About the OSGi Service Platform}},

  Author                   = {{OSGi Alliance}},
  HowPublished             = {http://www.osgi.org/documents/collateral/OSGiTechnicalWhitePaper.pdf},
  Year                     = {last accessed August 2009},

  Journal                  = {Website},
  Owner                    = {amcveigh},
  Review                   = {Eclipse plugin site, showing thousands of plugins.},
  Timestamp                = {2006.05.15},
  Url                      = {http://www.osgi.org/documents/collateral/OSGiTechnicalWhitePaper.pdf}
}

@Book{OSGi2003,
  Title                    = {OSGi Service Platform},
  Author                   = {{OSGi Alliance}},
  Publisher                = {IOS Press},
  Year                     = {2003},

  ISSN                     = {1586033115},
  Owner                    = {amcveigh},
  Pages                    = {--},
  Refid                    = {56},
  Timestamp                = {2006.03.14}
}

@Article{Ossher2001,
  Title                    = {Using Multidimensional Separation of Concerns to (Re)Shape Evolving Software},
  Author                   = {Harold Ossher and Peri Tarr},
  Journal                  = {Communications of the ACM},
  Year                     = {2001},
  Number                   = {10},
  Pages                    = {43--50},
  Volume                   = {44},

  Address                  = {New York, NY, USA},
  Doi                      = {http://doi.acm.org/10.1145/383845.383856},
  ISSN                     = {0001-0782},
  Publisher                = {ACM Press}
}

@Article{Ousterhout1998,
  Title                    = {Scripting: Higher-Level Programming for the 21st Century},
  Author                   = {Ousterhout, J.K.},
  Journal                  = {Computer},
  Year                     = {1998},
  Number                   = {3},
  Pages                    = {23--30},
  Volume                   = {31},

  Url                      = {citeseer.ist.psu.edu/article/ousterhout97scripting.html}
}

@InProceedings{Parnas1978,
  Title                    = {Designing Software for Ease of Extension and Contraction},
  Author                   = {Parnas,, David L.},
  Booktitle                = {ICSE '78: Proceedings of the 3rd International Conference on Software Engineering},
  Year                     = {1978},

  Address                  = {Piscataway, NJ, USA},
  Pages                    = {264--277},
  Publisher                = {IEEE Press},

  ISBN                     = {none},
  Location                 = {Atlanta, Georgia, United States},
  Owner                    = {andrew},
  Review                   = {contains good quotes about simplifying and speeding up system. key is the word "contraction".},
  Timestamp                = {2009.03.31}
}

@Book{Pilato2008,
  Title                    = {Version Control with Subversion},
  Author                   = {Pilato, C and Collins-Sussman, Ben and Fitzpatrick, Brian},
  Publisher                = {O'Reilly Media, Inc.},
  Year                     = {2008},
  Edition                  = {2},

  ISBN                     = {0596510330, 9780596510336},
  Owner                    = {amcveigh},
  Timestamp                = {2015.07.02}
}

@Article{Plasil2002,
  Title                    = {Behavior Protocols for Software Components},
  Author                   = {Plasil, F. and Visnovsky, S.},
  Journal                  = {IEEE Transactions on Software Engineering},
  Year                     = {2002},
  Number                   = {11},
  Pages                    = {1056--1076},
  Volume                   = {28},

  Abstract                 = {Abstract�In this paper, we propose a means to enhance an architecture description language with a description of component behavior. A notation used for this purpose should be able to express the interplay" on the component's interfaces and reflect step-by-step refinement of the component's specification during its design. In addition, the notation should be easy to comprehend and allow for formal reasoning about the correctness of the specification refinement and also about the correctness of an implementation in terms of whether it adheres to the specification. Targeting all these requirements together, the paper proposes employing behavior protocols which are based on a notation similar to regular expressions. As proof of the concept, the behavior protocols are used in the SOFA architecture description language at three levels: interface, frame, and architecture. Key achievements of this paper include the definitions of bounded component behavior and protocol conformance relation. Using these concepts, the designer can verify the adherence of a component's implementation to its specification at runtime, while the correctness of refining the specification can be verified at design time.},
  Comment                  = {Very nice paper, looking at behaviour protocols. Has top-down / bottom up issue covered. Easily translatable into FSP for activity errors. Handles removal of components from an architecture, and compatibility with subtypes (although this is a bit axiomatic for my liking).
2006-02-01},
  ISSN                     = {0098-5589},
  Keywords                 = {component, architecture description language, SPECIFICATION, definition},
  Owner                    = {amcveigh},
  Publisher                = {IEEE Press},
  Refid                    = {67},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=631297&coll=Portal&dl=GUIDE&CFID=70282723&CFTOKEN=98894328#}
}

@Misc{Poilpret,
  Title                    = {{designgridlayout: An Easy and Powerful Swing Layout Manager}},

  Author                   = {Jean-Francois Poilpret and J. Osgood},
  HowPublished             = {https://designgridlayout.dev.java.net/},
  Year                     = {last accessed 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.06.29},
  Url                      = {https://designgridlayout.dev.java.net/}
}

@InProceedings{Prasanta1998,
  Title                    = {Change Analysis in an Architectural Model: A Design Rationale Based Approach},
  Author                   = {Prasanta, Bose},
  Booktitle                = {Proceedings of the Third International Workshop on Software Architecture},
  Year                     = {1998},

  Address                  = {Orlando, Florida, United States},
  Pages                    = {5--8},
  Publisher                = {ACM Press},

  Abstract                 = {The architectural model of a system provides a high level description that enables compositional design and analysis of component-based systems. This paper focuses on the problem of evaluation and management of change in an architectural model of the system and presents a design rationale (DR) based approach to such a problem. We consider the types of design rationale knowledge relevant to architectural decisions and describe an initial prototype environment for capture and usage of such knowledge in analysis of change.},
  Comment                  = {Not a great paper. Looks at capturing the design rationale as a way of managing evolution, but the example is very difficult to follow. Good description of design-time evolution.
2005-11-18},
  ISSN                     = {1-58113-081-3},
  Keywords                 = {software architecture, SYSTEMS},
  Owner                    = {amcveigh},
  Refid                    = {53},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=288410&coll=Portal&dl=GUIDE&CFID=60888327&CFTOKEN=91962879#}
}

@InProceedings{Raemaekers2014,
  Title                    = {Semantic Versioning Versus Breaking Changes: A Study of the Maven Repository},
  Author                   = {Raemaekers, Steven and van Deursen, Arie and Visser, Joost},
  Booktitle                = {Proceedings of the 2014 IEEE 14th International Working Conference on Source Code Analysis and Manipulation},
  Year                     = {2014},

  Address                  = {Washington, DC, USA},
  Pages                    = {215--224},
  Publisher                = {IEEE Computer Society},
  Series                   = {SCAM '14},

  Acmid                    = {2709959},
  Doi                      = {10.1109/SCAM.2014.30},
  ISBN                     = {978-1-4799-6148-1},
  Keywords                 = {Semantic versioning, Software libraries},
  Numpages                 = {10},
  Owner                    = {amcveigh},
  Timestamp                = {2015.07.02},
  Url                      = {http://dx.doi.org/10.1109/SCAM.2014.30}
}

@Misc{RationalRealtime,
  Title                    = {{Rational Rose Technical Developer Website}},

  Author                   = {{Rational Corporation, IBM}},
  HowPublished             = {http://www.ibm.com/developerworks/rational/products/rosetechnicaldeveloper/},
  Year                     = {last accessed August 2009},

  Owner                    = {amcveigh},
  Timestamp                = {2009.04.02},
  Url                      = {http://www.ibm.com/developerworks/rational/products/rosetechnicaldeveloper/}
}

@Misc{Reenskaug2007,
  Title                    = {{The Original MVC Reports (1979)}},

  Author                   = {Trygve Reenskaug},
  HowPublished             = {http://heim.ifi.uio.no/trygver/2007/MVC\_Originals.pdf},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.04.03},
  Url                      = {http://heim.ifi.uio.no/~trygver/2007/MVC_Originals.pdf}
}

@InProceedings{Robert2005,
  Title                    = {The CORBA Connector Model},
  Author                   = {Sylvain Robert and Ansgar Radermacher and Vincent Seignole and S\'{e}bastien G\'{e}rard and Virginie Watine and Fran\c{c}ois Terrier},
  Booktitle                = {SEM '05: Proceedings of the Fifth International Workshop on Software Engineering and Middleware},
  Year                     = {2005},

  Address                  = {New York, NY, USA},
  Pages                    = {76--82},
  Publisher                = {ACM Press},

  Abstract                 = {Embedded systems designers are more than ever confronted with issues related to complexity management. New design methods have emerged that could help to face this rising concern, but they do not yet satisfy all specific requirements from this application domain. In this scope, we aim to adapt the CORBA Component Model approach to embedded software design. This adaptation notably requires reworking the CCM interaction support, in order to provide more flexibility and extensibility. We think that this objective can be reached by integrating connectors in the CCM. This paper describes the benefits of this approach, and outlines the modifications we have made to the CCM in order to integrate connectors.},
  Doi                      = {http://doi.acm.org/10.1145/1108473.1108490},
  ISBN                     = {1-59593-204-4},
  Location                 = {Lisbon, Portugal},
  Review                   = {explains the CCM simply, and shows that it doesn't have connectors.}
}

@Book{Robinson2007,
  Title                    = {Aspect-Oriented Programming with the e Verification Language: A Pragmatic Guide for Testbench Developers},
  Author                   = {David Robinson},
  Publisher                = {Morgan Kaufmann},
  Year                     = {2007},

  Abstract                 = {excellent book looking at the use of replacement and resemblance-like facilities in the e verification language to simulate aspects.},
  Owner                    = {amcveigh},
  Timestamp                = {2009.03.26}
}

@Article{Roshandel2004,
  Title                    = {Mae---A System Model and Environment for Managing Architectural Evolution},
  Author                   = {Roshandel, R. and Van Der Hoek, A. and Mikic-Rakic, M. and Medvidovic, N.},
  Journal                  = {ACM Transactions on Software Engineering},
  Year                     = {2004},
  Number                   = {2},
  Pages                    = {240--276},
  Volume                   = {13},

  Address                  = {New York, NY, USA},
  Doi                      = {http://doi.acm.org/10.1145/1018210.1018213},
  ISSN                     = {1049-331X},
  Publisher                = {ACM Press}
}

@InProceedings{Roundy2005,
  Title                    = {Darcs: Distributed Version Management in Haskell},
  Author                   = {Roundy,, David},
  Booktitle                = {Haskell '05: Proceedings of the 2005 ACM SIGPLAN Workshop on Haskell},
  Year                     = {2005},

  Address                  = {New York, NY, USA},
  Pages                    = {1--4},
  Publisher                = {ACM},

  Doi                      = {http://doi.acm.org/10.1145/1088348.1088349},
  ISBN                     = {1-59593-071-X},
  Location                 = {Tallinn, Estonia},
  Owner                    = {andrew},
  Timestamp                = {2009.04.04}
}

@Book{Rumbaugh1996,
  Title                    = {OMT Insights: Perspectives on Modeling from the Journal of Object-Oriented Programming},
  Author                   = {Rumbaugh,, James},
  Publisher                = {Cambridge University Press},
  Year                     = {1996},

  Address                  = {New York, NY, USA},

  ISBN                     = {1884842585},
  Pages                    = {123},
  Review                   = {Excellent collection of articles from JOOP. Particularly useful is the section discussing singletons as being just at 1 point in a compositional hierarchy, on page 123.}
}

@Book{Rumbaugh2004,
  Title                    = {Unified Modeling Language Reference Manual, The (2nd Edition)},
  Author                   = {James Rumbaugh and Ivar Jacobson and Grady Booch},
  Publisher                = {Pearson Higher Education},
  Year                     = {2004},

  ISBN                     = {0321245628}
}

@InProceedings{Eisenbach2004,
  Title                    = {Keeping Control of Reusable Components},
  Author                   = {S. Eisenbach, D. Kayhan, C. Sadler},
  Booktitle                = {2nd International Working Conference on Component Deployment},
  Year                     = {2004},
  Note                     = {Edinburgh, Scotland, 2004},
  Organization             = {e-science Institute},
  Pages                    = {144 - 158},
  Publisher                = {Springer-Verlag},

  Owner                    = {andrew},
  Timestamp                = {2007.06.25}
}

@InProceedings{Schurr1998,
  Title                    = {Formal Definition and Refinement of UML's Module/Package Concept},
  Author                   = {Andy Sch\"{u}rr and Andreas J. Winter},
  Booktitle                = {ECOOP '97: Proceedings of the Workshops on Object-Oriented Technology},
  Year                     = {1998},

  Address                  = {London, UK},
  Pages                    = {211--215},
  Publisher                = {Springer-Verlag},

  ISBN                     = {3-540-64039-8},
  Review                   = {Nice treatment of UML packages, how the export/import rules work and the problems with them as a form of modularity.}
}

@InProceedings{Schneider1999,
  Title                    = {Components, Scripts and Glue},
  Author                   = {Jean-Guy Schneider and Oscar Nierstrasz},
  Booktitle                = {Software Architectures: Advances and Applications},
  Year                     = {1999},
  Pages                    = {13--25},
  Publisher                = {Springer},

  Abstract                 = {Experience has shown us that object-oriented technology alone is not enough to guarantee that the systems we develop will be flexible and adaptable. Even �welldesigned� object-oriented software may be difficult to understand and adapt to new requirements. We propose a conceptual framework that will help yield more flexible object-oriented systems by encouraging explicit separation of computational and compositional elements. We distinguish between components that adhere to an architectural style, scripts that specify compositions, and glue that may be needed to adapt components � interfaces and contracts. We also discuss a prototype of an experimental composition language called P ICCOLA that attempts to combine proven ideas from scripting languages, coordination models and languages, glue techniques, and architectural specification. 1},
  Review                   = {Fantastic start to this article, looking at how object architectures are limited in extensibility. Some great quotes here.

Discusses compositional component approaches -- very relevant to my work. Rapidly degenerates though, on start of JPiccola material.}
}

@InProceedings{Seiwald1996,
  Title                    = {Inter-File Branching - A Practical Method for Representing Variants},
  Author                   = {Christopher Seiwald},
  Booktitle                = {ICSE '96: Proceedings of the SCM-6 Workshop on System Configuration Management},
  Year                     = {1996},

  Address                  = {London, UK},
  Pages                    = {67--75},
  Publisher                = {Springer-Verlag},

  ISBN                     = {3-540-61964-X},
  Review                   = {seems like a hacky way to implement distributed artifacts. used by MAE. need to look into it more, but it seemingly contradicts itself in several places --> does it require the same names for branched files or not?}
}

@Misc{Selic2003,
  Title                    = {{Tutorial D: An Overview of UML 2.0}},

  Author                   = {Selic, B.},
  HowPublished             = {UML 2003},
  Year                     = {2003},

  Booktitle                = {Sixth International Conference on the Unified Modeling Language, October 20-24, 2003, San Francisco},
  Comment                  = {Bran's excellent UML tutorial which shows some of the rationale behind his work in ROOM on composite structures, connectors and structural refinement. Should revisit this and get back in touch with him.
2003-10-22},
  Owner                    = {amcveigh},
  Pages                    = {--},
  Refid                    = {54},
  Timestamp                = {2006.03.14}
}

@InCollection{Selic1994,
  Title                    = {Inheritance},
  Author                   = {Selic, B. and Gullekson, G. and Ward, P.T.},
  Booktitle                = {Real-Time Object-Oriented Modeling},
  Publisher                = {Wiley},
  Year                     = {1994},
  Edition                  = {1st},
  Number                   = {9},
  Pages                    = {255--285},

  ISSN                     = {0471599174},
  Owner                    = {amcveigh},
  Refid                    = {64},
  Timestamp                = {2006.03.14}
}

@Book{Selic1994a,
  Title                    = {Real-Time Object-Oriented Modeling},
  Author                   = {Selic, B. and Gullekson, G. and Ward, P.T.},
  Publisher                = {John Wiley \& Sons},
  Year                     = {1994},

  Owner                    = {amcveigh},
  Timestamp                = {2006.05.30}
}

@InProceedings{Shukla2002,
  Title                    = {Structured Component Composition Frameworks for Embedded System Design},
  Author                   = {Sandeep K. Shukla and Frederic Doucet and Rajesh K. Gupta},
  Booktitle                = {HiPC '02: Proceedings of the 9th International Conference on High Performance Computing},
  Year                     = {2002},

  Address                  = {London, UK},
  Pages                    = {663--678},
  Publisher                = {Springer-Verlag},

  Abstract                 = {The increasing integration of system-chips is leading to a widening
gap in the size and complexity of the chip-level design and the design capabilities.
A number of advances in high-level modeling and validation have been proposed
over the past decade in an attempt to bridge the gap in design productivity.
Prominent among these are advances in Abstraction and Reuse and structured design
methods such as Component-Based Design and Platform-Based Design. In
this paper, we present an overview of the recent advances in reuse, abstraction,
and component frameworks.We describe a compositional approach to high-level
modeling as implemented in the BALBOA project.},
  ISBN                     = {3-540-00303-7},
  Review                   = {contains a re-explanation of type inference in a component-based system. also contains details on partial/loose typing...},
  Timestamp                = {2005.11.25}
}

@Article{Spinellis2001,
  Title                    = {Notable Design Patterns for Domain Specific Languages},
  Author                   = {Diomidis Spinellis},
  Journal                  = {Journal of Systems and Software},
  Year                     = {2001},

  Month                    = feb,
  Number                   = {1},
  Pages                    = {91--99},
  Volume                   = {56},

  Doi                      = {doi:10.1016/S0164-1212(00)00089-3},
  ISSN                     = {0164-1212},
  Owner                    = {andrew},
  Timestamp                = {2009.06.14},
  Url                      = {http://www.dmst.aueb.gr/dds/pubs/jrnl/2000-JSS-DSLPatterns/html/dslpat.html}
}

@Book{Spivey1992,
  Title                    = {The Z Notation: A Reference Manual},
  Author                   = {J. Michael Spivey},
  Publisher                = {Prentice-Hall, Inc.},
  Year                     = {1992},

  Owner                    = {andrew},
  Timestamp                = {2009.05.13}
}

@InProceedings{Sreedhar2002,
  Title                    = {Mixin'Up Components},
  Author                   = {Vugranam C. Sreedhar},
  Booktitle                = {ICSE '02: Proceedings of the 24th International Conference on Software Engineering},
  Year                     = {2002},

  Address                  = {New York, NY, USA},
  Note                     = {2005.11.28},
  Pages                    = {198--207},
  Publisher                = {ACM Press},

  Abstract                 = {Recently we proposed a language called ACOEL (A Component-Oriented Extension Language) for abstracting and composing software components. Components in ACOEL are black-box components, and each component consists of (1) an internal implementation containing classes, methods, and fields that is hidden to the external world, and (2) an external contract consisting of a set of typed input and output ports. Components in ACOEL interact with each other only via these ports. In this paper we extend ACOEL in two directions: (1) use mixins to customize the services provided by a component without exposing its internal implementation, (2) add support for virtual types and sub-type relation among components. We will show how mixins and virtual types together allows us to build adaptable applications based on black-box component principles.},
  Doi                      = {http://doi.acm.org/10.1145/581339.581366},
  ISBN                     = {1-58113-472-X},
  Location                 = {Orlando, Florida},
  Review                   = {uses mixins + type parameters to allow adding functionality + ports and overriding, using inheritance. maybe reread.}
}

@InProceedings{Steffen2004,
  Title                    = {Encapsulation of Structural Adaptation by Composite Components},
  Author                   = {Steffen, G.},
  Booktitle                = {Proceedings of the 1st ACM SIGSOFT workshop on Self-managed systems},
  Year                     = {2004},

  Address                  = {Newport Beach, California},
  Pages                    = {64--68},
  Publisher                = {ACM Press},

  Comment                  = {Looks at how various reconfigurations of components can be mapped onto component parameters. For example, an audio player may have one "mode" for low-cpu power and another for high-cpu power. The parameter "cpuPower" would map onto 2 reconfigurations of the component, which substituted the codec for an appropriate one. The component model is called CC, and it has been extended to a unit of structural adaptation that allows for: changed parameter, removed connections, added connections, removed subcomponents, added subcomponents, replaced subcomponents. Very similar to the Jeffs idea of reconfiguration primitives.
2005-10-23},
  ISSN                     = {1-58113-989-6},
  Keywords                 = {component, SYSTEMS},
  Owner                    = {amcveigh},
  Refid                    = {29},
  Timestamp                = {2006.03.14},
  Url                      = {http://doi.acm.org/10.1145/1075405.1075418}
}

@InProceedings{Steyaert1996,
  Title                    = {Reuse Contracts: Managing the Evolution of Reusable Assets},
  Author                   = {Steyaert, P. and Lucas, C. and Mens, K. and D'Hondt, T.},
  Booktitle                = {Proceedings of the 11th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
  Year                     = {1996},

  Address                  = {San Jose, California, United States},
  Pages                    = {268--285},
  Publisher                = {ACM Press},

  Abstract                 = {A critical concern in the reuse of software is the propagation of changes made to reusable artifacts, Without techniques to manage these changes, multiple versions of these artifacts will propagate through different systems and reusers will not be able to benefit from improvements to the original artifact. We propose to codify the management of change in a software system by means of reuse contracts that record the protocol between managers and users of a reusable asset. Just as real world contracts can be extended, amended and customised, reuse contracts are subject to parallel changes encoded by formal reuse operators: extension, refinement and concretisation. Reuse contracts and their operators serve as structured documentation and facilitate the propagation of changes to reusable assets by indicating how much work is needed to update previously built applications, where and how to test and how to adjust these applications.},
  Comment                  = {Not fully read. Looks at the challenges of maintaining and evolving reusable assets such as framework. Proposes reuse contracts offer guidelines for reusing assets in some problem domain, via recording of protocols on interfaces.},
  ISSN                     = {0-89791-788-X},
  Keywords                 = {SYSTEMS},
  Owner                    = {amcveigh},
  Refid                    = {50},
  Timestamp                = {2006.03.14}
}

@Article{Stuckenholz2005,
  Title                    = {Component Evolution and Versioning State of the Art},
  Author                   = {Stuckenholz, A.},
  Journal                  = {SIGSOFT Software Engineering Notes},
  Year                     = {2005},
  Number                   = {1},
  Pages                    = {7--},
  Volume                   = {30},

  Abstract                 = {Emerging component-based software development architectures promise better re-use of software components, greater flexibility, scalability and higher quality of services. But like any other piece of software too, software components are hardly perfect, when being created. Problems and bugs have to be fixed and new features need to be added. This paper analyzes the problem of component evolution and the incompatibilities which result during component upgrades. We present the state of the art in component versioning and compare the different methods in component models, frameworks and programming languages. Special attention is put on the automation of processes and tool support in this area. The concluding section sketches a possible solution of these problems we are currently working on.},
  Comment                  = {Focussed mainly on versioning artifacts involved in component architecture. Looks at mechanisms to sort out versioning (CM issues), detection of changes, substitutability checks, and minimization of incompatibilities. Not particularly interesting
2005-11-07},
  ISSN                     = {0163-5948},
  Keywords                 = {component},
  Owner                    = {amcveigh},
  Publisher                = {ACM Press},
  Refid                    = {40},
  Timestamp                = {2006.03.14}
}

@Misc{Network2006,
  Title                    = {{Java SE Desktop Technologies - JavaBeans}},

  Author                   = {{SUN Developer Network}},
  HowPublished             = {http://java.sun.com/products/javabeans/},
  Year                     = {2009},

  Journal                  = {Website},
  Owner                    = {amcveigh},
  Review                   = {Eclipse plugin site, showing thousands of plugins.},
  Timestamp                = {2006.05.15},
  Url                      = {http://java.sun.com/products/javabeans/}
}

@Misc{Network2006a,
  Title                    = {{Enterprise JavaBeans Technology}},

  Author                   = {{SUN Developer Network}},
  HowPublished             = {http://java.sun.com/products/ejb/},
  Year                     = {2009},

  Journal                  = {Website},
  Owner                    = {amcveigh},
  Review                   = {Eclipse plugin site, showing thousands of plugins.},
  Timestamp                = {2006.05.15},
  Url                      = {http://java.sun.com/products/ejb/}
}

@Misc{EJBRestrictions2009,
  Title                    = {{EJB Restrictions}},

  Author                   = {{SUN Microsystems}},
  HowPublished             = {http://java.sun.com/blueprints/qanda/ejb\_tier/\\\-restrictions.html},
  Year                     = {Last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.06.16},
  Url                      = {http://java.sun.com/blueprints/qanda/ejb_tier/restrictions.html}
}

@Misc{JavaCC,
  Title                    = {{JavaCC}},

  Author                   = {{SUN Microsystems}},
  HowPublished             = {https://javacc.dev.java.net/},
  Year                     = {last accessed August 2009},

  Journal                  = {Website},
  Owner                    = {andrew},
  Timestamp                = {2006.10.04},
  Url                      = {https://javacc.dev.java.net/}
}

@InProceedings{Svahnberg1999,
  Title                    = {Characterizing Evolution in Product Line Architectures},
  Author                   = {Svahnberg, M. and Bosch, J.},
  Booktitle                = {Proceedings of the IASTED 3rd International Conference on Software Engineering and Applications},
  Year                     = {1999},

  Owner                    = {amcveigh},
  Timestamp                = {2006.05.30}
}

@InProceedings{Szyperski2006,
  Title                    = {Independently Extensible Systems -- Software Engineering Potential and Challenges},
  Author                   = {Szyperski, C.},
  Booktitle                = {In Proceedings of the 19th Australasian Computer Science Conference},
  Year                     = {2006},

  Address                  = {Melbourne, Australia},

  Abstract                 = {Component-based software, open systems, and document-based user interfaces are about to revolutionise most areas traditionally addressed by the software engineer. We claim that many traditional software engineering methods, from life-cycle models to programming languages to system architectures are at least insufficient when facing the new trends. In this paper we present the main points of criticism and state a few unavoidable facts of life: extensible systems are in principle modular, have no ...},
  Comment                  = {Interesting exposition of the problems involved with integrating modular extensions. Discusses issues with global integrity checking. Good example of operating systems.
2005-12-05},
  Keywords                 = {SYSTEMS},
  Owner                    = {amcveigh},
  Refid                    = {73},
  Timestamp                = {2006.03.14},
  Url                      = {http://citeseer.ist.psu.edu/szyperski96independently.html}
}

@Book{Szyperski2002,
  Title                    = {Component Software: Beyond Object-Oriented Programming},
  Author                   = {Szyperski,, Clemens},
  Publisher                = {Addison-Wesley Longman Publishing Co., Inc.},
  Year                     = {2002},

  Address                  = {Boston, MA, USA},

  ISBN                     = {0201745720},
  Review                   = {the infamous (and confused) book about software components.}
}

@Article{Taivalsaari1996,
  Title                    = {On the Notion of Inheritance},
  Author                   = {Antero Taivalsaari},
  Journal                  = {ACM Computing Surveys},
  Year                     = {1996},
  Number                   = {3},
  Pages                    = {438--479},
  Volume                   = {28},

  Address                  = {New York, NY, USA},
  Doi                      = {http://doi.acm.org/10.1145/243439.243441},
  ISSN                     = {0360-0300},
  Publisher                = {ACM Press},
  Review                   = {useful for referring to inheritance.}
}

@InProceedings{Tarr2002,
  Title                    = {Hyper/J: Multi-Dimensional Separation of Concerns for Java},
  Author                   = {Tarr,, Peri and Ossher,, Harold and Sutton,Jr., Stanley M.},
  Booktitle                = {ICSE '02: Proceedings of the 24th International Conference on Software Engineering},
  Year                     = {2002},

  Address                  = {New York, NY, USA},
  Pages                    = {689--690},
  Publisher                = {ACM},

  Doi                      = {http://doi.acm.org/10.1145/581339.581447},
  ISBN                     = {1-58113-472-X},
  Location                 = {Orlando, Florida},
  Owner                    = {andrew},
  Timestamp                = {2009.03.31}
}

@InProceedings{Taylor1995,
  Title                    = {A Component- and Message-based Architectural Style for GUI Software},
  Author                   = {Taylor, R.N. and Medvidovic, N. and Anderson, M. and Whithead Jr., E.J. and Robbins, J.E.},
  Booktitle                = {Proceedings of the 17th International Conference on Software Engineering},
  Year                     = {1995},

  Address                  = {Seattle, Washington, United States},
  Pages                    = {295--304},
  Publisher                = {ACM Press},

  Abstract                 = {While a large fraction of application system code is devoted to user interface functions, support for reuse in this domain has largely been conjined to creation of UI toolkits ("widgets"). We present a novel architectural style directed at supporting larger grain reuse andjexible system composition. Moreover the style supports design of distributed, concurrent, applications. A key aspect of the style is that components are not built with any dependencies on what typically would be considered lower-level components, such as user interface toolkits. Indeed, all components are oblivious to the existence of any components to which notijcation messages are sent. Asynchronous notification messages and asynchronous request messages are the sole basis for inter-component communication. While our focus has been on applications involving graphical user interfaces, the style has the potential for broader applicability. Several trial applications using the style are described.},
  Comment                  = {Introduces the Chiron-2 style of architecture (often called just C2) which consists of active components each potentially with their own thread of control. Components offer a set of services, and generate a set of notifications which are called the top domain. Components require a set of services, and respond to a set of notifications, which is known as the bottom domain. No nested components appear possible. Multiple components can connect to notification buses. All services are invoked asynchronously, leading I presume to a state-based approach for handling notifications. It is proposed that this represents a viable and advanced architectural style for forming GUI applications. Several examples of GUI applications are presented including a KLAX game which is interesting.
2005-10-23},
  ISSN                     = {0-89791-708-1},
  Keywords                 = {component},
  Owner                    = {amcveigh},
  Refid                    = {45},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=225042&coll=Portal&dl=GUIDE&CFID=60882501&CFTOKEN=91583883#}
}

@Book{Taylor2010,
  Title                    = {Software Architecture: Foundations, Theory and Practice},
  Author                   = {Richard N. Taylor and Nend Medvidovic and Eric M. Dashofy},
  Publisher                = {John Wiley \& Sons},
  Year                     = {2010},

  Owner                    = {andrew},
  Timestamp                = {2009.04.03}
}

@Misc{Templin2005,
  Title                    = {{Escape DLL Hell: Simplify App Deployment with ClickOnce and Registration-Free COM}},

  Author                   = {Dave Templin},
  HowPublished             = {http://msdn2.microsoft.com/en-us/magazine/cc188708.aspx},
  Year                     = {last accessed August 2009},

  Journal                  = {MSDN Magazine},
  Owner                    = {amcveigh},
  Review                   = {decent explanation of the main focus of the eclipse platform, including plugin architecture.},
  Timestamp                = {2006.05.15},
  Url                      = {http://msdn2.microsoft.com/en-us/magazine/cc188708.aspx}
}

@InProceedings{Thomas1988,
  Title                    = {Orwell---A Configuration Management System for Team Programming},
  Author                   = {Thomas,, Dave and Johnson,, Kent},
  Booktitle                = {OOPSLA '88: Conference proceedings on Object-Oriented Programming Systems, Languages and Applications},
  Year                     = {1988},

  Address                  = {New York, NY, USA},
  Pages                    = {135--141},
  Publisher                = {ACM},

  Doi                      = {http://doi.acm.org/10.1145/62083.62096},
  ISBN                     = {0-89791-284-5},
  Location                 = {San Diego, California, United States},
  Owner                    = {andrew},
  Timestamp                = {2009.04.04}
}

@InProceedings{Truyen2001,
  Title                    = {Dynamic and Selective Combination of Extensions in Component-Based Applications},
  Author                   = {Truyen, E. and Vanhaute, B. and Jorgensen, B.N. and Joosen, W. and Verbaeton, P.},
  Booktitle                = {ICSE '01: Proceedings of the 23rd International Conference on Software Engineering},
  Year                     = {2001},

  Address                  = {Washington, DC, USA},
  Pages                    = {233--242},
  Publisher                = {IEEE Computer Society},

  ISBN                     = {0-7695-1050-7},
  Location                 = {Toronto, Ontario, Canada}
}

@InProceedings{Uchitel2004,
  Title                    = {System Architecture: the Context for Scenario-Based Model Synthesis},
  Author                   = {Uchitel, S. and Chatley, R. and Kramer, J. and Magee, J.},
  Booktitle                = {Proceedings of the 12th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  Year                     = {2004},

  Address                  = {Newport Beach, CA, USA},
  Pages                    = {33--42},
  Publisher                = {ACM Press},

  Abstract                 = {Constructing rigorous models for analysing the behaviour of concurrent and distributed systems is a complex task. Our aim is to facilitate model construction. Scenarios provide simple, intuitive, example based descriptions of the behaviour of component instances in the context of a simplified architecture instance. The specific architecture instance is generally chosen to provide sufficient context to indicate the expected behaviour of particular instances of component types to be used in the real system. Existing synthesis techniques provide mechanisms for building behaviour models for these simplified and specific architectural settings. However, the behaviour models required are those for the full generality of the system architecture, and not the simplified architecture used for scenarios. In this paper we exploit architectural information in the context of behaviour model synthesis from scenarios. Software architecture descriptions give the necessary contextual information so that component instance behaviour can be generalised to component type behaviour. Furthermore, architecture description languages can be used to describe the complex architectures in which the generalised behaviours need to be instantiated. Thus, architectural information used in conjunction with scenario-based model synthesis can support both model construction and elaboration, where the behaviour derived from simple architecture fragments can be instantiated in more complex ones.},
  Comment                  = {Excellent paper, very accessible. Looks at using scenarios at multiple levels of abstraction to develop an architecture and apply these scenarios to architectures with different abstractions in them. Uses ports in sequence diagram.
2006-01-09},
  ISSN                     = {1-58113-855-5},
  Keywords                 = {SYSTEMS, component, software architecture, architecture description language},
  Owner                    = {amcveigh},
  Refid                    = {70},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=1029903&coll=Portal&dl=GUIDE&CFID=70282723&CFTOKEN=98894328#}
}

@Article{Uchitel2004a,
  Title                    = {Incremental Elaboration of Scenario-Based Specifications and Behavior Models using Implied Scenarios},
  Author                   = {Uchitel, S. and Kramer, J. and Magee, J.},
  Journal                  = {ACM Transactions on Software Engineering and Methodology (TOSEM)},
  Year                     = {2004},
  Number                   = {1},
  Pages                    = {37--85},
  Volume                   = {13},

  Address                  = {New York, NY, USA},
  Doi                      = {http://doi.acm.org/10.1145/1005561.1005563},
  ISSN                     = {1049-331X},
  Publisher                = {ACM Press}
}

@Article{Vanderperren2001,
  Title                    = {Towards a New Component Composition Process},
  Author                   = {Wim Vanderperren and Bart Wydaeghe},
  Journal                  = {Eighth Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (ECBS)},
  Year                     = {2001},
  Pages                    = {0322},
  Volume                   = {0},

  Abstract                 = {Component Based Development is considered to be a promising technology to cure the software crisis. However, until now designing and developing component-based applications turns out to be very hard. Current component based development not only involves a component configuration phase, but also writing a lot of glue-code. Much of the existing glue-code in current systems is written to "hack " components together instead of following a careful design. In this paper we introduce a component composition methodology based on the concept of composition patterns. A composition pattern describes an interaction between a set of roles using an extended sequence chart. It serves as a bridge between the design and the implementation. We further propose a component documentation and a set of algorithms based on finite automata theory to perform an automatic compatibility check and glue-code generation to support this methodology.},
  Address                  = {Los Alamitos, CA, USA},
  Doi                      = {http://doi.ieeecomputersociety.org/10.1109/ECBS.2001.922439},
  ISBN                     = {0-7695-1086-8},
  Publisher                = {IEEE Computer Society},
  Review                   = {related to the other paper by Wydaeghe and Vandperren: general idea is that a sequence of fixed primitives can be used to check the compatibility of a component playing a role in a pattern.

glue lives with the reuse context. again, this paper is limited by the lack of explanation of the choices of the fixed message type primitives for testing compatbility. poor explanations on why these are useful or complete.},
  Timestamp                = {2006.07.24}
}

@Book{Varanasi2014,
  Title                    = {Introducing Maven},
  Author                   = {Varanasi, Balaji and Belida, Sudha},
  Publisher                = {Apress},
  Year                     = {2014},

  Address                  = {Berkely, CA, USA},
  Edition                  = {1st},

  __markedentry            = {[amcveigh:]},
  ISBN                     = {1484208420, 9781484208427},
  Owner                    = {amcveigh},
  Timestamp                = {2015.07.02}
}

@InProceedings{Vax2007,
  Title                    = {Conservative Aspect-Orientated Programming with the e Language},
  Author                   = {Matan Vax},
  Booktitle                = {AOSD '07: Proceedings of the 6th International Conference on Aspect-Oriented Software Development},
  Year                     = {2007},

  Address                  = {New York, NY, USA},
  Pages                    = {149--160},
  Publisher                = {ACM},

  Doi                      = {http://doi.acm.org/10.1145/1218563.1218581},
  ISBN                     = {1-59593-615-7},
  Location                 = {Vancouver, British Columbia, Canada},
  Review                   = {excellent paper describing how the extend feature of e makes it aspect oriented. also, i have the book of this.

another useful contribution is to show that aspect quantifications are essentially only useful when used in a non domain specific way. i.e. they are metamodeling. so, aspects are metamodeling (limited) and oblivious extension (with limited combination power).

other paper referenced shows that aspects are quantification and obliviousness. very interesting. shows that inheritance (resemblance) offers a level of simple quantification.}
}

@Book{Vlissides1998,
  Title                    = {Pattern Hatching: Design Patterns Applied},
  Author                   = {Vlissides, John.},
  Publisher                = {Addison Wesley Professional},
  Year                     = {1998},

  Owner                    = {andrew},
  Timestamp                = {2006.10.04}
}

@PhdThesis{Vlissides1990,
  Title                    = {Generalized Graphical Object Editing},
  Author                   = {Vlissides,, John M.},
  School                   = {Stanford University},
  Year                     = {1990},

  Address                  = {Stanford, CA, USA},
  Note                     = {Adviser-Linton,, Mark A.},

  Order_no                 = {AAI9102367},
  Owner                    = {andrew},
  Publisher                = {Stanford University},
  Timestamp                = {2009.03.19}
}

@InProceedings{Vlissides1989,
  Title                    = {Unidraw: a Framework for Building Domain-Specific Graphical Editors},
  Author                   = {Vlissides,, J. M. and Linton,, M. A.},
  Booktitle                = {UIST '89: Proceedings of the 2nd annual ACM SIGGRAPH Symposium on User Interface Software and Technology},
  Year                     = {1989},

  Address                  = {New York, NY, USA},
  Pages                    = {158--167},
  Publisher                = {ACM},

  Abstract                 = {Unidraw is a framework for creating object-oriented graphical editors in domains such as technical and artistic drawing, music composition, and CAD. The Unidraw architecture simplifies the construction of these editors by providing programming abstractions that are common across domains. Unidraw defines four basic abstractions: components encapsulate the appearance and behavior of objects, tools support direct manipulation of components, commands define operations on components, and external representations define the mapping between components and a file or database. Unidraw also supports multiple views, graphical connectivity, and dataflow between components. This paper presents Unidraw and three prototype domain-specific editors we have developed with it: a schematic capture system, a user interface builder, and a drawing editor. Experience indicates a substantial reduction in implementation time and effort compared with existing tools.},
  Doi                      = {http://doi.acm.org/10.1145/73660.73680},
  ISBN                     = {0-89791-335-3},
  Location                 = {Williamsburg, Virginia, United States},
  Owner                    = {andrew},
  Review                   = {great early graphical editor: tools, subjects and views.},
  Timestamp                = {2009.03.19}
}

@InProceedings{Volter1999,
  Title                    = {Pluggable Component - A Pattern for Interactive System Configuration},
  Author                   = {Makus Volter},
  Booktitle                = {The Fourth European Conference of Pattern Languages of Programming and Computing, EuroPLoP '99},
  Year                     = {1999},

  Address                  = {Bad Irsee, Germany},

  Owner                    = {andrew},
  Review                   = {referenced in the lightweight plug-in paper of Mayer. Seems to deal more with runtime change.},
  Timestamp                = {2008.03.13}
}

@InProceedings{Wermelinger1998,
  Title                    = {A Simple Description Language for Dynamic Architectures},
  Author                   = {Wermelinger, M.},
  Booktitle                = {Proceedings of the Third International Workshop on Software Architecture},
  Year                     = {1998},

  Address                  = {Orlando, Florida, United States},
  Pages                    = {159--162},
  Publisher                = {ACM Press},

  Abstract                 = {The Chemical Abstract Machine (CHAM) is a very elegant and simple computational model that has been used for the specification of both static and dynamic architectures. However, so far those descriptions are ad-hoc and monolithic, thus making it difficult to perceive the elements and form of an architecture. In this paper we present some syntactic constructs and a methodology to specify an architecture in a principled, explicit, and modular way, thus proposing a very simple and compact Architecture Description Language (ADL) which is especially suited for dynamic architectures.},
  Comment                  = {Describes the CHAM, and its relevance as a potential ADL. Mentions that it isn't an ADL.
2005-10-23},
  ISSN                     = {1-58113-081-3},
  Keywords                 = {software architecture, SPECIFICATION, architecture description language},
  Owner                    = {amcveigh},
  Refid                    = {32},
  Timestamp                = {2006.03.14},
  Url                      = {http://doi.acm.org/10.1145/288408.288449}
}

@Misc{Wheeler,
  Title                    = {{SLOCCount: A set of tools for counting physical source lines of code}},

  Author                   = {David A. Wheeler},
  HowPublished             = {http://www.dwheeler.com/sloccount/},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.07.24},
  Url                      = {http://www.dwheeler.com/sloccount/}
}

@InProceedings{Wijnstra2000,
  Title                    = {Supporting Diversity with Component Frameworks as Architectural Elements},
  Author                   = {Jan Gerben Wijnstra},
  Booktitle                = {ICSE '00: Proceedings of the 22nd International Conference on Software Engineering},
  Year                     = {2000},

  Address                  = {New York, NY, USA},
  Pages                    = {51--60},
  Publisher                = {ACM Press},

  Abstract                 = {In this paper, we describe our experience with component frameworks within a family architecture for a medical imaging product family. The component frameworks are handled as an integral part of the architectural approach and are an important means to support diversity in the functionality provided by the individual family members.This paper focuses on a particular kind of component framework that has been applied throughout the medical imaging product family. This kind of framework is useful when the various family members are based on the same concepts and the diversity is formed by the differences in the specific instances of these concepts that are present in the family members. These component frameworks have a number of similarities, allowing a standardised approach to their development. They support the division of the system into a generic architectural skeleton, which can be extended with plug-ins to realise specific family members, each with their own set of features.},
  Doi                      = {http://doi.acm.org/10.1145/337180.337188},
  ISBN                     = {1-58113-206-9},
  Location                 = {Limerick, Ireland},
  Review                   = {ok for some ideas, but fairly basic. need to look more at white box versus black box reuse.},
  Timestamp                = {2005.11.23}
}

@Misc{Wordpress,
  Title                    = {{Wordpress Plugins}},

  Author                   = {Wordpress},
  HowPublished             = {http://wordpress.org/extend/plugins/},
  Year                     = {last accessed August 2009},

  Owner                    = {andrew},
  Timestamp                = {2009.08.03},
  Url                      = {http://wordpress.org/extend/plugins/}
}

@InProceedings{Wydaeghe2001,
  Title                    = {Visual Component Composition Using Composition Patterns},
  Author                   = {Bart Wydaeghe and Wim Vanderperren},
  Booktitle                = {TOOLS '01: Proceedings of the 39th International Conference and Exhibition on Technology of Object-Oriented Languages and Systems (TOOLS39)},
  Year                     = {2001},

  Address                  = {Washington, DC, USA},
  Pages                    = {120},
  Publisher                = {IEEE Computer Society},

  Abstract                 = {We improve current visual component composition environments by introducing composition patterns as first class objects that can be defined, stored and reused independently of the components. We document both components and composition patterns using an extended sequence diagram notation. For a component, typical usage protocols are specified while a composition pattern specifies how a set of roles interact. From this documentation, we check whether a component can work as described by a composition pattern using finite state automata theory and we generate glue-code for the composition. In this paper we present our approach, explain the checking algorithms and glue code generation and discuss the tool support we developed.},
  Review                   = {started reading but lost interest quickly.

general idea is that a sequence of fixed primitives can be used to check the compatibility of a component playing a role in a pattern.

how can they possibly verify that the primitives are sufficient for describing all compability problems? most likely this works for a small subset of issues.},
  Timestamp                = {2006.06.24}
}

@InProceedings{Xiong2000,
  Title                    = {An Extensible Type System for Component-Based Design},
  Author                   = {Xiong, Y. and Lee, E.A.},
  Booktitle                = {Proceedings of the 6th International Conference on Tools and Algorithms for Construction and Analysis of Systems},
  Year                     = {2000},
  Pages                    = {20--37},
  Publisher                = {Springer-Verlag},

  Abstract                 = {Component-based design has been established as an important approach to designing complex embedded systems, which often have many concurrent computational activities and mix widely differing operations. A good type system is particularly important for component-based design. A type system can improve the safety and flexibility of the design environment, promote component reuse, and help simplify component development and optimization. Although type systems have been studied extensively in the programming language community, its research in component-based design is not enough.},
  Comment                  = {Not read fully yet. Deals with component types by allowing for port typing constraints. Further follows connectors to parts to transmit the typing information to the embedded components. Could solve typing issues with deeply nested components and the issues that come from exposing new extension points.},
  ISSN                     = {3-540-67282-6},
  Keywords                 = {SYSTEMS, component, definition},
  Owner                    = {amcveigh},
  Refid                    = {47},
  Timestamp                = {2006.03.14},
  Url                      = {http://portal.acm.org/citation.cfm?id=759191#}
}

@Misc{Yegge2004,
  Title                    = {When Poymorphism Fails},

  Author                   = {Yegge, S.},
  HowPublished             = {http://steve.yegge.googlepages.com/when-polymorphism-fails},
  Year                     = {last accessed August 2009},

  Journal                  = {Steve Yegge's internal Amazon blog, 2004-2005},
  Owner                    = {amcveigh},
  Review                   = {some greate quotes regarding extensibility.},
  Timestamp                = {2006.05.15},
  Url                      = {http://steve.yegge.googlepages.com/when-polymorphism-fails}
}

@TechReport{Zenger2004,
  Title                    = {Independently Extensible Solutions to the Expression Problem},
  Author                   = {Zenger, M. and Odersky, M.},
  Institution              = {Ecole Polytehnique Federale de Lausanne},
  Year                     = {2004},

  Owner                    = {amcveigh},
  Timestamp                = {2006.05.30}
}

@Article{Zito2006,
  Title                    = {Package Merge in UML 2: Practice vs. Theory?},
  Author                   = {Zito A, Diskin Z, Dingel J},
  Journal                  = {Model Driven Engineering Languages and Systems},
  Year                     = {2006},
  Pages                    = {185--199},
  Volume                   = {9},

  Owner                    = {amcveigh},
  Timestamp                = {2007.07.09}
}

@Book{Jacko2003,
  Title                    = {The Human-Computer Interaction Handbook: Fundamentals, Evolving Technologies and Emerging Applications},
  Editor                   = {Jacko, Julie A. and Sears, Andrew},
  Publisher                = {L. Erlbaum Associates Inc.},
  Year                     = {2003},

  Address                  = {Hillsdale, NJ, USA},

  ISBN                     = {0-8058-3838-4},
  Owner                    = {andrew},
  Timestamp                = {2009.06.29}
}

@Electronic{,
  Owner                    = {amcveigh},
  Timestamp                = {2015.07.02}
}

@Article{,
  Owner                    = {amcveigh},
  Timestamp                = {2015.07.02}
}

@Other{,
  Owner                    = {amcveigh},
  Timestamp                = {2015.07.02}
}

@Misc{,
  Owner                    = {amcveigh},
  Timestamp                = {2015.07.02}
}

