#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass IEEEtran
\begin_preamble
\parindent 10pt

\markboth{IEEE TRANSACTIONS ON SOFTWARE ENGINEERING}{MCVEIGH ET AL.: INTRINSIC DEFINITION IN SOFTWARE ARCHITECTURE EVOLUTION}

\IEEEpubid{0000--0000/00\$00.00 \copyright 2007 IEEE}

\pagenumbering{gobble}
\end_preamble
\options compsoc
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans helvet
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing other 1.1000000000000001
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
IEEEcompsoctitleabstractindextext{
\backslash
small
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Abstract
\series default
---Incremental change is intrinsic to both the initial development and subsequen
t evolution of large complex software systems.
 We present an approach that captures this incremental change in the definition
 of software architecture.
 The predominant advantage in making the definition of evolution intrinsic
 to architecture description is in permitting a principled and manageable
 way of dealing with unplanned change and extension.
 We show how intrinsic definition also facilitates decentralized evolution
 in which software is extended and evolved by multiple independent developers.
 Further, we show how unplanned extensions can be deployed to end users
 with the same facility that plugins extensions are currently added to systems
 with planned extension points.
 The approach is model-driven in that architecture definition is used to
 directly construct both initial implementations and extensions to these
 implementations.
 We have implemented intrinsic evolution definition in Backbone - an architectur
al description language (ADL), which has both a textual and a UML2, based
 graphical representation.
 The paper uses Backbone to illustrate basic concepts through simple examples
 and reports our experience in applying it and its associated tool support
 to a larger example.
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{IEEEkeywords}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Software Architectures, Design Tools and Techniques
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{IEEEkeywords}}
\backslash
author{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Andrew McVeigh, Jeff Kramer and Jeff Magee
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
IEEEcompsocitemizethanks{
\backslash
IEEEcompsocthanksitem{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A.
 McVeigh, J.
 Kramer and J.
 Magee are with Imperial College London.
\end_layout

\begin_layout Standard
E-mail: {a.mcveigh, j.kramer, j.magee}@imperial.ac.uk
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}}
\backslash
thanks{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Manuscript received (insert date of submission if desired).
 Please note that all acknowledgments should be places at the end of the
 paper, before the bibliography.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}}
\end_layout

\end_inset


\end_layout

\begin_layout Title
Intrinsic Definition in
\begin_inset Newline newline
\end_inset

Software Architecture Evolution
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
IEEEPARstart{I}{NITIALLY}
\end_layout

\end_inset

 recognized by Boehm in his spiral model of software development [] and
 more recently in agile development methods [], iterative and incremental
 software development is fundamental to the delivery of complex software
 intensive systems.
 As early as 1976, Belady and Lehman[] recognized that to retain their usefulnes
s, complex software systems are subject to continuous incremental change
 throughout their lifetime.
 In 1991, Lehman[] refined this observation and noted that systems are subject
 to incremental growth due to the need to add functionality to maintain
 user satisfaction.
 In summary, incremental change and extension can be regarded as intrinsic
 to both the initial development and subsequent evolution of complex software
 systems.
\end_layout

\begin_layout Standard
To deal with the increasing complexity of software systems, the Software
 Engineering community has focused on dealing with systems at a level of
 abstraction, known as software architecture [].
 The software architecture of a system deals with multiple views of a system
 including both its functional and non-functional aspects.
 The central view is the structural one in which a system is viewed as a
 set of components that interact via connectors.
 Control of complexity is achieved by hierarchical structure in which a
 component can be composed from subcomponents with the leaf components of
 the hierarchy representing code modules.
 A number of Architectural Description Languages (ADL) have been proposed
 by the research community [], and some of these have found their way into
 commercial practice [].
 While software architecture is seen as an appropriate level for system
 redesign and restructuring to permit change [], the proposed ADLs do not
 deal directly with evolution, considering it to be an extrinsic concern
 dealt with by tools and processes external to those concerned with architecture
 definition.
\end_layout

\begin_layout Standard
In this paper, we explore the alternative in which we regard evolution as
 a concern that is intrinsic to architecture definition such that the structural
 constructs we propose to capture change and extension can be used during
 both initial development and subsequent evolution.
 This intrinsic definition brings with it the requirement to deal with unplanned
 extension, for it is impossible, whichever development process is adopted,
 to foresee all possible future requirements for change and evolution of
 a system.
\end_layout

\begin_layout Standard
Dealing with unplanned extension introduces a difficult dilemma in designing
 constructs to support intrinsic definition.
 We would prefer to have constructs that constrain change in such a way
 that their application always results in structurally well formed and type
 correct systems.
 However, such an approach inevitably means that only a subclass of all
 possible valid change to a system is permitted.
 This is clearly incompatible with dealing with unplanned extension since
 we cannot predict the change that will be necessary.
 As a result, we have chosen constructs that do permit changes that result
 in invalid systems; however, we have ensured that these constructs are
 used in an environment that comprehensively detects structural and type
 errors.
 In other words, we combine the freedom to perform incorrect changes with
 the ability to detect these errors so that we have sufficient expressiveness
 to deal with unplanned changes.
 We permit change to be destructive – deleting elements of an architecture
 – in addition to being constructive – adding elements to an architecture.
\end_layout

\begin_layout Standard
In exploring intrinsic definition, we have considered the requirements of
 distributed design and evolution in which development and extension is
 carried out by different organizations.
 In particular, we are motivated by the following situation which current
 approaches find problematic.
 A development organization produces a software framework product that is
 used by other organizations to build applications.
 In meeting their local development requirements, these organizations may
 need to modify and extend the framework to support their applications.
 The original framework will evolve over time and the organizations that
 use it need to apply their local changes to the framework before using
 the evolved framework for their applications.
 In addition, a third party may wish to use applications from more than
 one extenders of the framework and thus need to merge changes from both
 these organizations and the original framework provider.
 In the sequel, we examine the impact of intrinsic definition on distributed
 evolution of this form.
\end_layout

\begin_layout Standard
If software architecture description is regarded only as design documentation,
 a major problem arises in keeping this documentation in step with the software
 implementation as a system evolves.
 We adopt a model driven engineering approach in that architecture definition
 is not just a documentation artifact but is a precise model used to directly
 construct both initial implementations and extensions to these implementations.
\end_layout

\begin_layout Standard
In the following: Section 2 describes the key concepts for the intrinsic
 definition of evolution in software architecture and explains their use
 by mean of a simple example, Section 3 provides a more rigorous definition
 of the these concepts and shows how they are computed over a dependency
 graph of extensions, Section 4 recounts our experience in using our prototype
 tool Evolve applied to a large case study and evaluates the approach against
 the requirements for distributed evolution, Section 5 discusses related
 work and finally Section 6 presents some conclusions and directions for
 future work that build on the approach.
\end_layout

\begin_layout Section
Defining Change
\end_layout

\begin_layout Standard
We first describe and motivate the key concepts we use to define change
 in software architecture.
 Specifically, these constructs provide the facility to remake a composition
 hierarchy.
 We demonstrate this in a simple example described using our description
 language Backbone in which the constructs have been implemented.
 It has both a graphical form based on UML2 component diagrams and a textual
 form.
 The textual form is simply a printed version of an XML representation used
 to store and exchange Backbone definitions.
\end_layout

\begin_layout Subsection
Key Concepts
\end_layout

\begin_layout Standard

\emph on
Resemblance
\end_layout

\begin_layout Standard
Resemblance defines a new component as the difference in structure from
 one or more existing components.
 It is the delta, consisting of the set of additions, deletions and replacements
 of the elements of these components, that is applied to arrive at the new
 definition.
 For a component, these elements are: parts – instances of subcomponents,
 ports – instances of interfaces, connectors – bindings between ports, and
 attributes – component parameters.
 Resemblance may also be applied to interfaces in which case the modified
 elements are operations.
 If a resemblance delta consists only of additions then when applied to
 an interface, it defines a proper subtype.
 The type inference and checking algorithm we have implemented in our prototype
 tool Evolve takes full cognizance of this.
\end_layout

\begin_layout Standard
Resemblance is a many to one relation to permit the merging of multiple
 component definitions that may have arisen due to, for example, distributed
 development.
 It might be of concern that if a sufficiently radical delta is applied
 to a component then the new definition will bear little or no resemblance,
 in the general sense, to the component definitions from which it is derived.
 However, this is of more philosophical than practical import as the primary
 intent of resemblance to record change or evolution and we can find many
 examples in both engineering and nature where things evolve dramatically
 from their original form.
\end_layout

\begin_layout Standard

\emph on
Replacement
\end_layout

\begin_layout Standard
Replacement globally substitutes the definition of one component for another
 while preserving the identity of the original definition such that any
 use relations that a larger system has with this definition are preserved.
 When combined with resemblance, replacement permits the incremental evolution
 of a component definition without necessarily having to change the composite
 component definitions that use this component.
\end_layout

\begin_layout Standard
Components and interfaces in the Backbone ADL are given globally unique
 identifiers to permit the correct unambiguous application of replacement.
 Replacement is the key to managing change in composite hierarchical definitions
 since it permits substitution of component definitions at one level of
 the composition hierarchy without necessarily affecting higher layers.
\end_layout

\begin_layout Standard

\emph on
Stratum
\end_layout

\begin_layout Standard
A stratum is a package or module that holds the definitions relating to
 an initial software architecture expressed as a composite component or
 definitions relating to an evolution of that architecture.
 Each stratum records the strata that it depends on such that to assemble
 a system, the builder uses the current stratum and the transitive closure
 of all strata that this stratum depends on.
 The computation of resemblance in the context of the stratum dependency
 graph is addressed in the next section.
\end_layout

\begin_layout Standard
In addition to extension, the stratum is the unit of sharing and ownership.
 Each stratum is owned by a single party that has modification rights to
 it.
 We can therefore use strata to model the ownership structure of an architecture
 and map this onto a community of base and extension developers.
 Our development tool Evolve and the Backbone runtime environment support
 the import and export of strata for distributing extensions and subsets
 of an architecture.
\end_layout

\begin_layout Standard
A stratum is also a unit of deployment in that its compiled version together
 with associated component code can be sent to an end user to extend their
 system in a similar fashion to Eclipse Plugins.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
It should be noted that although resemblance allows elements to be deleted
 in forming a new definition from existing defintions, this is not destructive
 editing in the usual sense since the existing definition is preserved and
 the deletion simply recorded in a delta.
 Our approach preserves definitions and at no point overwrites old definitions
 with new definitions.
 When replacing a definition from a base stratum with a new definition using
 resemblance in an extension stratum, we do not remove the base definition
 simply record the delta definition in the extension stratum.
 Indeed, if we do not want a component definition to be available for use
 in an extension, we simply replace it with a resemblance delta that sets
 its retirement status to true.
\end_layout

\begin_layout Subsection
Example
\end_layout

\begin_layout Standard
To illustrate the use of these three concepts we use the Singlelane Bridge
 example from [].
 This concurrent system models the access of cars to a single lane bridge.
 Its component architecture can be modeled in Backbone as shown in Figure
 1.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Figure 1 – SingleLaneBridge Components The textual architecture description
 that corresponds to this component diagram is listed below:
\end_layout

\begin_layout Plain Layout
stratum SingleLaneBridge depends-on backbone { interface I_access implementation
-class bridge.I_access { operations: enter; leave; }
\end_layout

\begin_layout Plain Layout
interface I_move implementation-class bridge.I_move {operations: move; }
\end_layout

\begin_layout Plain Layout
component Controller implementation-class bridge.Controller { ports: red
 provides I_access; blue provides I_access; }
\end_layout

\begin_layout Plain Layout
component Car implementation-class bridge.Car { attributes: carNo: int =
 0; ports: move requires I_move; bridge requires I_access; }
\end_layout

\begin_layout Plain Layout
component Display implementation-class bridge.Display { attributes: maxCar:
 int = 1; ports: redmove provides I_move; § bluemove provides I_move; run
 provides IRun; }
\end_layout

\begin_layout Plain Layout
component SLB { ports: run provides IRun; parts: b0: Car; c: Controller;
 r0: Car; d: Display; connectors: bb joins blue@c to bridge@b0; br joins
 bridge@r0 to red@c; vr joins move@r0 to redmove@d; vb joins move@b0 to
 bluemove@d; r delegates-from run to run@d; } }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This architecture represents a system with one red car and one blue car,
 moving in opposite directions, competing for access to the bridge.
 Access control is implemented by the Controller component, which provides
 two I_access interfaces.
 A Car calls enter to gain access to the bridge and calls leave on exit.
 Cars display their movement using the Display component.
 Note that all of the definitions are contained in the SingleLaneBridge
 stratum that appears in Figure 3.
 Car, Controller and Display are leaf components with an implementaion defined
 by Java classes.
 SLB is a composite component that contains parts made from these components
 interconnected by connectors to form the system.
\end_layout

\begin_layout Subsubsection*
Using Resemblance
\end_layout

\begin_layout Standard
Now suppose that another developer wishes to evolve this system to accommodate
 multiple red and blue cars moving in opposite directions.
 This developer creates the stratum with the components shown in Figure
 2.
 The developer defines three new components: CarFactory dynamically creates
 a Car component when it receives an invocation on its creator port, CarCreator
 is a leaf component that calls its create port maxCar times, and finally,
 the composite component MultiCar creates nCars Car components.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Figure 2 – MultiCarBridge components
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The MULTSLB composite component is defined as a resemblance of the SLB component
 from the SingleLaneBridge stratum.
 Graphically, resemblance is depicted as a solid arrow pointing to an icon
 representing the component from which the resemblance is derived.
 Although graphically MULTSLB is depicted with all its component parts and
 connectors, in fact as shown in the Backbone listing below, it is defined
 by a delta that simply adds the nCar attribute and replaces the parts of
 type Car with parts of type MultiCar.
 In addition, it replaces the instance of Display with an instance of the
 same component type but with a different attribute value.
 The new definition is formed graphically by editing the previous definition
 that the Evolve tool displays when the resemblance relation is established.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
stratum MultiCarBridge depends-on SingleLaneBridge {
\end_layout

\begin_layout Plain Layout
component CarFactory is-factory resembles FactoryBase { attributes: carId:
 int; ports: bridge; move; parts: c: Car carNo (carId); connectors: b delegates-
from bridge to bridge@c; m delegates-from move to move@c; }
\end_layout

\begin_layout Plain Layout
component CarCreator implementation-class bridge.CarCreator { attributes:
 maxCar: int; ports: create requires ICreate; }
\end_layout

\begin_layout Plain Layout
component MultiCar { attributes: nCars: int; ports: bridge; move; parts:
 cc: CarCreator maxCar (nCars); cf: CarFactory carId = 0; connectors: c
 joins create@cc to creator@cf; b delegates-from bridge to bridge@cf; m
 delegates-from move to move@cf; }
\end_layout

\begin_layout Plain Layout
component MULTISLB resembles SLB { attributes: nCar: int = 4; replace-parts:
 r0 becomes red: MultiCar nCars (nCar); b0 becomes blue: MultiCar nCars
 (nCar); d becomes d: Display maxCar (nCar); } }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To produce this extension permitting multiple cars, some new program source
 code must be written to implement the CarCreator component, however, there
 is no requirement to access or modify any of the source code relating to
 the base SingleLaneBridge stratum.
 Access to the architecture description is sufficient to permit extension.
 Note that resemblance is also used to define CarFactory, which extends
 FactoryBase provided by the underlying backbone stratum.
 The stratum dependency graph for the extension is shown in Figure 3.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Figure 3 – MultiCarBridge Strata Dependency Graph
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Using Replacement
\end_layout

\begin_layout Standard
The single lane bridge Controller component works well until the number
 of cars increases to the point that a stream of cars, either red of blue,
 continuously occupies the bridge denying access to cars moving in the other
 direction.
 In other words, the Controller component is safe but not fair.
 Figure 4 shows how a revised Controller that does implement fairness is
 introduced.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
stratum FairBridge depends-on SingleLaneBridge {
\end_layout

\begin_layout Plain Layout
component Controller` implementation-class bridge.FairController resembles
 Controller replaces Controller {} }
\end_layout

\begin_layout Plain Layout
Figure 4 – FairBridge components
\end_layout

\end_inset

Replacement is so often combined with resemblance that we use a single graphical
 symbol (combined solid and fishbone arrow) to indicate this combination
 as shown in Figure 4.
 The diagram and text show that we are replacing Controller with a component
 that resembles it exactly with the exception of the implementation class
 that we have changed.
 We can now combine this fair bridge controller with the MultiCarBridge
 stratum as shown in Figure 5.
 The stratum FairMultiCarBridge represents a system that permits multiple
 cars and has a fair controller.
 The stratum contains no definitions of components or deltas; it simply
 indicates its dependences as shown in the Backbone text below Figure 5.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
stratum FairMultiLaneBridge depends-on FairBridge, MultiCarBridge { }
\end_layout

\begin_layout Plain Layout
Figure 5 – FairMultiLaneBridge Strata Dependency Graph
\end_layout

\end_inset

Figure 5 illustrates how strata are merged.
 This can of course lead to conflicts in definitions, which we discuss in
 the next section.
 In the case of the example, a more plausible scenario would be for the
 original base developer, or a third party, to export this new stratum to
 the multi-car developer who could import it as shown in Figure 6.
 If we were to write out the Backbone text again, it would now show a dependency
 on FairBridge rather than SingleLaneBridge for MultiCarBridge.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Figure 6 – Alternative Dependency Graph 3 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Intrinsic Definition in Practice
\end_layout

\begin_layout Standard
Proposers of a new approach to software architecture description have the
 responsibility to demonstrate that it can be put into industrial practice.
 In this section, we discuss three significant barriers to doing so and
 outline how they are addressed.
 They are: tool support, compatibility with existing libraries and toolkits,
 and application to existing legacy software.
\end_layout

\begin_layout Subsection
Tool Support
\end_layout

\begin_layout Standard
The Backbone ADL is supported by a graphical modeling tool Evolve and a
 runtime environment which instantiates and interconnects components from
 a Backbone description.
 Figure 7 is an overview of the elements that make up the modeling tool
 and runtime environment.
 The DeltaEngine layer implements the resemblance algorithm described in
 the previous section and is used in the modeling tool to build graphical
 representations of composite components from delta definitions and in the
 runtime environment to instantiate components from these same delta definitions.
 In addition to this interpreted runtime the modeling tool can optionally
 compile a “flat” description of the model as a builder class.
 In this case, no runtime environment is required.
 It should be noted that even the interpreted runtime environment incurs
 no overhead during execution of a system; it is only active at startup
 time when it directs instantiation and interconnection.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Figure 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
