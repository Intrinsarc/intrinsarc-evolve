#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass IEEEtran
\begin_preamble
\parindent 10pt

\markboth{IEEE TRANSACTIONS ON SOFTWARE ENGINEERING}{MCVEIGH ET AL.: SOFTWARE ARCHITECTURE EVOLUTION}

\IEEEpubid{0000--0000/00\$00.00 \copyright 2007 IEEE}

\pagenumbering{gobble}

 \hyphenation{Java-Bean Java-Beans}
\end_preamble
\options compsoc
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans helvet
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing other 1.1000000000000001
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
IEEEcompsoctitleabstractindextext{
\backslash
small
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Abstract
\series default
---Incremental change is intrinsic to both the initial development and subsequen
t evolution of large, complex software systems.
 We present an approach that captures incremental change in the definition
 of software architecture.
 This provides a rigorous, principled and manageable way of dealing with
 unplanned change and extension.
 Furthermore, it facilitates decentralized evolution in which software is
 extended and evolved by multiple independent developers.
 The approach is model-driven in that the architecture description is used
 to directly construct both initial implementations and extensions to these
 implementations.
 We have implemented this approach in a software tool, Evolve, using Backbone
 - an architectural description language (ADL) which has both a textual
 and a UML2 based graphical representation.
 The paper uses Backbone to illustrate basic concepts through simple examples
 and reports our experience in applying it and the associated Evolve tool
 support to legacy code and a larger example.
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{IEEEkeywords}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Software Architectures, Design Tools and Techniques
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{IEEEkeywords}}
\backslash
author{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Andrew McVeigh, Jeff Kramer and Jeff Magee
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
IEEEcompsocitemizethanks{
\backslash
IEEEcompsocthanksitem{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A.
 McVeigh, J.
 Kramer and J.
 Magee are with Imperial College London.
\end_layout

\begin_layout Standard
E-mail: {a.mcveigh, j.kramer, j.magee}@imperial.ac.uk
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}}
\backslash
thanks{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Manuscript received (insert date of submission if desired).
 Please note that all acknowledgments should be places at the end of the
 paper, before the bibliography.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}}
\end_layout

\end_inset


\end_layout

\begin_layout Title
Software Architecture Evolution
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
IEEEPARstart{I}{NITIALLY}
\end_layout

\end_inset

 recognized by Boehm in his spiral model of software development [] and
 more recently in agile development methods [], iterative and incremental
 software development is fundamental to the delivery of complex software
 intensive systems.
 As early as 1976, Belady and Lehman[] recognized that to retain their usefulnes
s, complex software systems are subject to continuous incremental change
 throughout their lifetime.
 In 1991, Lehman[] refined this observation and noted that systems are subject
 to incremental growth due to the need to add functionality to maintain
 user satisfaction.
 In summary, incremental change and extension can be regarded as intrinsic
 to both the initial development and subsequent evolution of complex software
 systems.
\end_layout

\begin_layout Standard
To deal with the increasing complexity of software systems, the Software
 Engineering community has focused on dealing with systems at a level of
 abstraction, known as software architecture [].
 The software architecture of a system deals with multiple views of a system
 including both its functional and non-functional aspects.
 The central view is the structural one in which a system is viewed as a
 set of components that interact via connectors.
 Control of complexity is achieved by hierarchical structure in which a
 component can be composed from subcomponents with the leaf components of
 the hierarchy representing code modules.
 A number of Architectural Description Languages (ADL) have been proposed
 by the research community [], and some of these have found their way into
 commercial practice [].
 While software architecture is seen as an appropriate level for system
 redesign and restructuring to permit change [], the proposed ADLs do not
 deal directly with evolution, considering it to be an extrinsic concern
 dealt with by tools and processes external to those concerned with architecture
 definition.
\end_layout

\begin_layout Standard
In this paper, we explore the alternative in which we regard evolution as
 a concern that is intrinsic to architecture definition such that the structural
 constructs we propose to capture change and extension can be used during
 both initial development and subsequent evolution.
 This intrinsic definition brings with it the requirement to deal with unplanned
 extension, for it is impossible, whichever development process is adopted,
 to foresee all possible future requirements for change and evolution of
 a system.
\end_layout

\begin_layout Standard
Dealing with unplanned extension introduces a difficult dilemma in designing
 constructs to support intrinsic definition.
 We would prefer to have constructs that constrain change in such a way
 that their application always results in structurally well formed and type
 correct systems.
 However, such an approach inevitably means that only a subclass of all
 possible valid change to a system is permitted.
 This is clearly incompatible with dealing with unplanned extension since
 we cannot predict the change that will be necessary.
 As a result, we have chosen constructs that do permit changes that result
 in invalid systems; however, we have ensured that these constructs are
 used in an environment that comprehensively detects structural and type
 errors.
 In other words, we combine the freedom to perform incorrect changes with
 the ability to detect these errors so that we have sufficient expressiveness
 to deal with unplanned changes.
 We permit change to be destructive – deleting elements of an architecture
 – in addition to being constructive – adding elements to an architecture.
\end_layout

\begin_layout Standard
In exploring intrinsic definition, we have considered the requirements of
 distributed design and evolution in which development and extension is
 carried out by different organizations.
 In particular, we are motivated by the following situation which current
 approaches find problematic.
 A development organization produces a software framework product that is
 used by other organizations to build applications.
 In meeting their local development requirements, these organizations may
 need to modify and extend the framework to support their applications.
 The original framework will evolve over time and the organizations that
 use it need to apply their local changes to the framework before using
 the evolved framework for their applications.
 In addition, a third party may wish to use applications from more than
 one extenders of the framework and thus need to merge changes from both
 these organizations and the original framework provider.
 In the sequel, we examine the impact of intrinsic definition on distributed
 evolution of this form.
\end_layout

\begin_layout Standard
If software architecture description is regarded only as design documentation,
 a major problem arises in keeping this documentation in step with the software
 implementation as a system evolves.
 We adopt a model driven engineering approach in that architecture definition
 is not just a documentation artifact but is a precise model used to directly
 construct both initial implementations and extensions to these implementations.
\end_layout

\begin_layout Standard
In the following: Section 2 describes the key concepts for the intrinsic
 definition of evolution in software architecture and explains their use
 by mean of a simple example, Section 3 provides a more rigorous definition
 of the these concepts and shows how they are computed over a dependency
 graph of extensions, Section 4 recounts our experience in using our prototype
 tool Evolve applied to a large case study and evaluates the approach against
 the requirements for distributed evolution, Section 5 discusses related
 work and finally Section 6 presents some conclusions and directions for
 future work that build on the approach.
\end_layout

\begin_layout Section
Defining Change
\end_layout

\begin_layout Standard
We first describe and motivate the key concepts we use to define change
 in software architecture.
 Specifically, these constructs provide the facility to remake a composition
 hierarchy.
 We demonstrate this in a simple example described using our description
 language Backbone in which the constructs have been implemented.
 It has both a graphical form based on UML2 component diagrams and a textual
 form.
 The textual form is simply a printed version of an XML representation used
 to store and exchange Backbone definitions.
\end_layout

\begin_layout Subsection
Key Concepts
\end_layout

\begin_layout Subsubsection*
Resemblance
\end_layout

\begin_layout Standard
Resemblance defines a new component as the difference in structure from
 one or more existing components.
 It is the delta, consisting of the set of additions, deletions and replacements
 of the elements of these components, that is applied to arrive at the new
 definition.
 For a component, these elements are: parts – instances of subcomponents,
 ports – instances of interfaces, connectors – bindings between ports, and
 attributes – component parameters.
 Resemblance may also be applied to interfaces in which case the modified
 elements are operations.
 If a resemblance delta consists only of additions then when applied to
 an interface, it defines a proper subtype.
 The type inference and checking algorithm we have implemented in our prototype
 tool Evolve takes full cognizance of this.
\end_layout

\begin_layout Standard
Resemblance is a many to one relation to permit the merging of multiple
 component definitions that may have arisen due to, for example, distributed
 development.
 It might be of concern that if a sufficiently radical delta is applied
 to a component then the new definition will bear little or no resemblance,
 in the general sense, to the component definitions from which it is derived.
 However, this is of more philosophical than practical import as the primary
 intent of resemblance to record change or evolution and we can find many
 examples in both engineering and nature where things evolve dramatically
 from their original form.
\end_layout

\begin_layout Subsubsection*
Replacement
\end_layout

\begin_layout Standard
Replacement globally substitutes the definition of one component for another
 while preserving the identity of the original definition such that any
 use relations that a larger system has with this definition are preserved.
 When combined with resemblance, replacement permits the incremental evolution
 of a component definition without necessarily having to change the composite
 component definitions that use this component.
\end_layout

\begin_layout Standard
Components and interfaces in the Backbone ADL are given globally unique
 identifiers to permit the correct unambiguous application of replacement.
 Replacement is the key to managing change in composite hierarchical definitions
 since it permits substitution of component definitions at one level of
 the composition hierarchy without necessarily affecting higher layers.
\end_layout

\begin_layout Subsubsection*
Stratum
\end_layout

\begin_layout Standard
A stratum is a package or module that holds the definitions relating to
 an initial software architecture expressed as a composite component or
 definitions relating to an evolution of that architecture.
 Each stratum records the strata that it depends on such that to assemble
 a system, the builder uses the current stratum and the transitive closure
 of all strata that this stratum depends on.
 The computation of resemblance in the context of the stratum dependency
 graph is addressed in the next section.
\end_layout

\begin_layout Standard
In addition to extension, the stratum is the unit of sharing and ownership.
 Each stratum is owned by a single party that has modification rights to
 it.
 We can therefore use strata to model the ownership structure of an architecture
 and map this onto a community of base and extension developers.
 Our development tool Evolve and the Backbone runtime environment support
 the import and export of strata for distributing extensions and subsets
 of an architecture.
\end_layout

\begin_layout Standard
A stratum is also a unit of deployment in that its compiled version together
 with associated component code can be sent to an end user to extend their
 system in a similar fashion to Eclipse Plugins.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
It should be noted that although resemblance allows elements to be deleted
 in forming a new definition from existing defintions, this is not destructive
 editing in the usual sense since the existing definition is preserved and
 the deletion simply recorded in a delta.
 Our approach preserves definitions and at no point overwrites old definitions
 with new definitions.
 When replacing a definition from a base stratum with a new definition using
 resemblance in an extension stratum, we do not remove the base definition
 simply record the delta definition in the extension stratum.
 Indeed, if we do not want a component definition to be available for use
 in an extension, we simply replace it with a resemblance delta that sets
 its retirement status to true.
\end_layout

\begin_layout Subsection
Example
\end_layout

\begin_layout Standard
To illustrate the use of these three concepts we use the Singlelane Bridge
 example from [].
 This concurrent system models the access of cars to a single lane bridge.
 Its component architecture can be modeled in Backbone as shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SingleLaneBridge-components"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/slb-components.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:SingleLaneBridge-components"

\end_inset

SingleLaneBridge components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The textual architecture description that corresponds to this component
 diagram is listed below:
\end_layout

\begin_layout LyX-Code

\series bold
\size small
stratum
\series default
 Single_Lane_Bridge
\end_layout

\begin_layout LyX-Code

\size small
  
\series bold
depends-on
\series default
 backbone
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
interface
\series default
 I_access
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
implementation-class
\series default
 bridge.I_access
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
operations:
\end_layout

\begin_layout LyX-Code

\size small
        enter; leave;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
interface
\series default
 I_move
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
implementation-class
\series default
 bridge.I_move
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
operations:
\end_layout

\begin_layout LyX-Code

\size small
        move;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 Controller
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
implementation-class
\series default
 bridge.Controller
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
ports:
\end_layout

\begin_layout LyX-Code

\size small
        red 
\series bold
provides
\series default
 I_access,
\end_layout

\begin_layout LyX-Code

\size small
        blue 
\series bold
provides
\series default
 I_access;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 Car
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
implementation-class
\series default
 bridge.Car
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
attributes:
\end_layout

\begin_layout LyX-Code

\size small
        carNo: int = 0;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
ports:
\end_layout

\begin_layout LyX-Code

\size small
        move 
\series bold
requires
\series default
 I_move,
\end_layout

\begin_layout LyX-Code

\size small
        bridge 
\series bold
requires
\series default
 I_access;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 Display
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
implementation-class
\series default
 bridge.Display
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
attributes:
\end_layout

\begin_layout LyX-Code

\size small
        maxCar: int = 1;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
ports:
\end_layout

\begin_layout LyX-Code

\size small
        redmove 
\series bold
provides
\series default
 I_move,
\end_layout

\begin_layout LyX-Code

\size small
        bluemove 
\series bold
provides
\series default
 I_move,
\end_layout

\begin_layout LyX-Code

\size small
        run 
\series bold
provides
\series default
 IRun;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 SLB
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
ports:
\end_layout

\begin_layout LyX-Code

\size small
        run 
\series bold
provides
\series default
 IRun;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
parts:
\end_layout

\begin_layout LyX-Code

\size small
        b0: Car,
\end_layout

\begin_layout LyX-Code

\size small
        c: Controller,
\end_layout

\begin_layout LyX-Code

\size small
        r0: Car,
\end_layout

\begin_layout LyX-Code

\size small
        d: Display;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
connectors:
\end_layout

\begin_layout LyX-Code

\size small
        bb 
\series bold
joins
\series default
 blue@c 
\series bold
to
\series default
 bridge@b0,
\end_layout

\begin_layout LyX-Code

\size small
        br 
\series bold
joins
\series default
 bridge@r0 
\series bold
to
\series default
 red@c,
\end_layout

\begin_layout LyX-Code

\size small
        vr 
\series bold
joins
\series default
 move@r0 
\series bold
to
\series default
 redmove@d,
\end_layout

\begin_layout LyX-Code

\size small
        vb 
\series bold
joins
\series default
 move@b0 
\series bold
to
\series default
 bluemove@d,
\end_layout

\begin_layout LyX-Code

\size small
        r 
\series bold
delegates-from
\series default
 run 
\series bold
to
\series default
 run@d;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
This architecture represents a system with one red car and one blue car,
 moving in opposite directions, competing for access to the bridge.
 Access control is implemented by the Controller component, which provides
 two I_access interfaces.
 A Car calls enter to gain access to the bridge and calls leave on exit.
 Cars display their movement using the Display component.
 Note that all of the definitions are contained in the SingleLaneBridge
 stratum that appears in Figure 3.
 Car, Controller and Display are leaf components with an implementaion defined
 by Java classes.
 SLB is a composite component that contains parts made from these components
 interconnected by connectors to form the system.
\end_layout

\begin_layout Subsubsection*
Using Resemblance
\end_layout

\begin_layout Standard
Now suppose that another developer wishes to evolve this system to accommodate
 multiple red and blue cars moving in opposite directions.
 This developer creates the stratum with the components shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MultiCarBridge-components"

\end_inset

.
 The developer defines three new components: CarFactory dynamically creates
 a Car component when it receives an invocation on its creator port, CarCreator
 is a leaf component that calls its create port maxCar times, and finally,
 the composite component MultiCar creates nCars Car components.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/mlb-components.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:MultiCarBridge-components"

\end_inset

MultiCarBridge components
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Figure 2 – MultiCarBridge components
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The MULTSLB composite component is defined as a resemblance of the SLB component
 from the SingleLaneBridge stratum.
 Graphically, resemblance is depicted as a solid arrow pointing to an icon
 representing the component from which the resemblance is derived.
 Although graphically MULTSLB is depicted with all its component parts and
 connectors, in fact as shown in the Backbone listing below, it is defined
 by a delta that simply adds the nCar attribute and replaces the parts of
 type Car with parts of type MultiCar.
 In addition, it replaces the instance of Display with an instance of the
 same component type but with a different attribute value.
 The new definition is formed graphically by editing the previous definition
 that the Evolve tool displays when the resemblance relation is established.
\end_layout

\begin_layout LyX-Code

\series bold
\size small
stratum
\series default
 Multi_Car_Bridge
\end_layout

\begin_layout LyX-Code

\size small
  
\series bold
depends-on
\series default
 Single_Lane_Bridge
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 CarFactory is-factory
\end_layout

\begin_layout LyX-Code

\size small
       
\series bold
resembles
\series default
 FactoryBase
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
attributes:
\end_layout

\begin_layout LyX-Code

\size small
          carId: int;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
ports:
\end_layout

\begin_layout LyX-Code

\size small
          bridge,
\end_layout

\begin_layout LyX-Code

\size small
          move;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
parts:
\end_layout

\begin_layout LyX-Code

\size small
          c: Single_Lane_Bridge::Car
\end_layout

\begin_layout LyX-Code

\size small
               
\series bold
slots:
\end_layout

\begin_layout LyX-Code

\size small
                 carNo = carId;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
connectors:
\end_layout

\begin_layout LyX-Code

\size small
          b 
\series bold
delegates-from
\series default
 move 
\series bold
to
\series default
 move@c,
\end_layout

\begin_layout LyX-Code

\size small
          m 
\series bold
delegates-from
\series default
 bridge 
\series bold
to
\series default
 bridge@c;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 CarCreator
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
implementation-class
\series default
 bridge.CarCreator
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
attributes:
\end_layout

\begin_layout LyX-Code

\size small
        maxCar: int;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
ports:
\end_layout

\begin_layout LyX-Code

\size small
        create requires ICreate;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 MultiCar
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
attributes:
\end_layout

\begin_layout LyX-Code

\size small
        nCars: int;
\end_layout

\begin_layout LyX-Code

\size small
     
\series bold
 ports:
\end_layout

\begin_layout LyX-Code

\size small
        bridge,
\end_layout

\begin_layout LyX-Code

\size small
        move;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
parts:
\end_layout

\begin_layout LyX-Code

\size small
        cc: CarCreator
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
slots:
\end_layout

\begin_layout LyX-Code

\size small
            maxCar = nCars,
\end_layout

\begin_layout LyX-Code

\size small
        cf: CarFactory
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
slots:
\end_layout

\begin_layout LyX-Code

\size small
            carId = 0;
\end_layout

\begin_layout LyX-Code

\size small
     
\series bold
 connectors:
\end_layout

\begin_layout LyX-Code

\size small
        c 
\series bold
joins
\series default
 create@cc 
\series bold
to
\series default
 creator@cf,
\end_layout

\begin_layout LyX-Code

\size small
        b 
\series bold
delegates-from
\series default
 bridge 
\series bold
to
\series default
 bridge@cf,
\end_layout

\begin_layout LyX-Code

\size small
        m 
\series bold
delegates-from
\series default
 move 
\series bold
to
\series default
 move@cf;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 MULTISLB
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
resembles
\series default
 Single_Lane_Bridge::SLB
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
attributes:
\end_layout

\begin_layout LyX-Code

\size small
        nCar: int = 4;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
replace-parts:
\end_layout

\begin_layout LyX-Code

\size small
        r0 
\series bold
becomes
\series default
 red: MultiCar
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
slots:
\end_layout

\begin_layout LyX-Code

\size small
            nCars = nCar
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
port-remaps:
\end_layout

\begin_layout LyX-Code

\size small
            move 
\series bold
maps-onto
\series default
 xxx
\end_layout

\begin_layout LyX-Code

\size small
            bridge 
\series bold
maps-onto
\series default
 xxx,
\end_layout

\begin_layout LyX-Code

\size small
        b0 
\series bold
becomes
\series default
 blue: MultiCar
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
slots:
\end_layout

\begin_layout LyX-Code

\size small
            nCars = nCar
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
port-remaps:
\end_layout

\begin_layout LyX-Code

\size small
            move 
\series bold
maps-onto
\series default
 xxx
\end_layout

\begin_layout LyX-Code

\size small
            bridge 
\series bold
maps-onto
\series default
 xxx,
\end_layout

\begin_layout LyX-Code

\size small
        d 
\series bold
becomes
\series default
 d: Single_Lane_Bridge::Display
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
slots:
\end_layout

\begin_layout LyX-Code

\size small
            maxCar = nCar;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
To produce this extension permitting multiple cars, some new program source
 code must be written to implement the CarCreator component, however, there
 is no requirement to access or modify any of the source code relating to
 the base SingleLaneBridge stratum.
 Access to the architecture description is sufficient to permit extension.
 Note that resemblance is also used to define CarFactory, which extends
 FactoryBase provided by the underlying backbone stratum.
 The stratum dependency graph for the extension is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MultiCarBridge-strata-dependency"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/multicar-stratum.eps
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:MultiCarBridge-strata-dependency"

\end_inset

MultiCarBridge strata dependency graph
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Using Replacement
\end_layout

\begin_layout Standard
The single lane bridge Controller component works well until the number
 of cars increases to the point that a stream of cars, either red of blue,
 continuously occupies the bridge denying access to cars moving in the other
 direction.
 In other words, the Controller component is safe but not fair.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:FairBridge-replacement-controlle"

\end_inset

 shows how a revised Controller that does implement fairness is introduced.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/fair-controller.eps
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:FairBridge-replacement-controlle"

\end_inset

FairBridge replacement controller
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The listing below shows the Backbone textual represenation of the evolved
 controller.
\end_layout

\begin_layout Standard

\size small
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code

\series bold
\size small
stratum
\series default
 Fair_Bridge
\end_layout

\begin_layout LyX-Code

\size small
 
\series bold
depends-on
\series default
 Single_Lane_Bridge
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
 
\series bold
component 
\series default
Controller
\end_layout

\begin_layout LyX-Code

\size small
  
\series bold
implementation-class
\end_layout

\begin_layout LyX-Code

\size small
    bridge.FairController
\end_layout

\begin_layout LyX-Code

\size small
  
\series bold
resembles
\end_layout

\begin_layout LyX-Code

\size small
    Single_Lane_Bridge::Controller
\end_layout

\begin_layout LyX-Code

\size small
 
\series bold
 replaces
\end_layout

\begin_layout LyX-Code

\size small
    Single_Lane_Bridge::Controller
\end_layout

\begin_layout LyX-Code

\size small
  {
\end_layout

\begin_layout LyX-Code

\size small
  }
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Replacement is so often combined with resemblance that we use a single graphical
 symbol (combined solid and fishbone arrow) to indicate this combination
 as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:FairBridge-replacement-controlle"

\end_inset

.
 The diagram and text show that we are replacing Controller with a component
 that resembles it exactly with the exception of the implementation class
 that we have changed.
 We can now combine this fair bridge controller with the MultiCarBridge
 stratum as shown in Figure 5.
 The stratum FairMultiCarBridge represents a system that permits multiple
 cars and has a fair controller.
 The stratum contains no definitions of components or deltas; it simply
 indicates its dependences as shown in the Backbone text below Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:FairMultiLaneBridge-strata-depen"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/all-strata.eps
	width 87col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:FairMultiLaneBridge-strata-depen"

\end_inset

FairMultiLaneBridge strata dependency graph
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
\size small
stratum
\series default
 Fair_Multi_Lane_Bridge
\end_layout

\begin_layout LyX-Code

\size small
  
\series bold
depends-on 
\series default
Multi_Car_Bridge, Fair_Bridge
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:FairMultiLaneBridge-strata-depen"

\end_inset

 illustrates how strata are merged.
 This can of course lead to conflicts in definitions, which we discuss in
 the next section.
 In the case of the example, a more plausible scenario would be for the
 original base developer, or a third party, to export this new stratum to
 the multi-car developer who could import it as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Alternative-dependency-graph"

\end_inset

.
 If we were to write out the Backbone text again, it would now show a dependency
 on FairBridge rather than SingleLaneBridge for MultiCarBridge.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/alternative-graph.eps
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Alternative-dependency-graph"

\end_inset

Alternative dependency graph
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "backbone-formal.lyx"

\end_inset


\end_layout

\begin_layout Standard
[TBD...]
\end_layout

\begin_layout Section
Intrinsic Definition in Practice
\end_layout

\begin_layout Standard
Proposers of a new approach to software architecture description have the
 responsibility to demonstrate that it can be put into industrial practice.
 In this section, we discuss three significant barriers to doing so and
 outline how they are addressed.
 They are: tool support, compatibility with existing libraries and toolkits,
 and application to existing legacy software.
 The first two issues are addressed in this section, and the applicability
 to legacy and mature software is addressed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Applicability-to-Mature"

\end_inset

.
\end_layout

\begin_layout Subsection
Tool Support
\end_layout

\begin_layout Standard
The Backbone ADL is supported by a graphical modeling tool Evolve, and a
 runtime environment which instantiates and interconnects components from
 a Backbone description.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-DeltaEngine-is"

\end_inset

 is an overview of the elements that make up the modeling tool and runtime
 environment.
 The DeltaEngine layer implements the algorithm described in the previous
 section and is used in both the modeling tool to build graphical representation
s of composite components from delta definitions and also in the runtime
 environment to instantiate components from these same definitions.
 In addition to this interpreted runtime the modeling tool can optionally
 compile a “flat” description of the model as a builder class.
 In this case, no runtime environment is required.
 It should be noted that even the interpreted runtime environment incurs
 no overhead during execution of a system; it is only active at startup
 time when it directs instantiation and interconnection.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename drawings/stack.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-DeltaEngine-is"

\end_inset

Common layers between environments
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The DeltaEngine and Structural Rules Layers
\end_layout

\begin_layout Standard
The DeltaEngine layer is a library which implements the extended resemblance
 algorithm described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:A-Formal-Description"

\end_inset

 allowing deltas to be applied in the correct order to fully realise each
 component.
 Once the deltas are applied, the Structural rules layer can be used to
 determine if the system is structurally well-formed using 100+ rules [phd].
 Any errors are catalogued against the elements responsible.
\end_layout

\begin_layout Subsubsection
Evolve Graphical Modeling Environment
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide true
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename drawings/deltas.png
	width 80page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Evolve-showing-deltas"

\end_inset

Evolve showing deltas
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Evolve uses standard UML2 component diagrams.
 We do however apply both restrictions and extensions to this notation in
 order to better match up to our component model.
 We implement the restrictions as rules and the extensions as stereotypes
 as per the UML2 philosophy.
 As an example consider that UML2 allows part multiplicity.
 Evolve does not allow this feature, instead requiring the use of factory
 components for multiple instantiation: this requires restriction preventing
 the use of multiplicity and an extension to allow factory components to
 be denoted by a stereotype.
 In total, however, the number of mismatches between the two component models
 is quite small reflecting the historical lineage of both Backbone and the
 UML2 component model in the models that have preceded them [acme, objectime,
 darwin].
\end_layout

\begin_layout Standard
It has been noted that a design tool must support both top-down and bottom-up
 approaches in order to match up with the creative design processes involved
 [].
 Evolve naturally supports bottom-up composition by virtue of the compositional
 model chosen.
 To better support top-down design we incorporate placeholder components
 [] which are components which are not yet fully elaborated, allowing the
 designer to terminate top-down decomposition at an arbitrary point rather
 than just at leaf components.
 Placeholders may have all the features of a normal component, but may not
 be instantiated directly.
 Any component can be marked as a placeholder.
\end_layout

\begin_layout Standard
Because resemblance and replacement can be used to substitute placeholder
 components and parts, placeholders can participate fully in the design
 process.
 For instance it is common in Evolve to have a placeholder at the base of
 a resemblance hierarchy, effectively acting as a template for the more
 refined components that derive from it.
\end_layout

\begin_layout Standard
Although Backbone requires that components are described in terms of deltas,
 Evolve always shows the full structure even as it records deltas for any
 changes.
 As shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Evolve-showing-deltas"

\end_inset

 Evolve can overlay the deltas graphically on the expanded structures.
\end_layout

\begin_layout Subsubsection
Runtime
\end_layout

\begin_layout Standard
The runtime inteprets the textual form emitted from Evolve - it is effectively
 an interpreter for the Backbone structural domain specific language []
 at the heart of the system.
 It shares the DeltaEngine and rules layers with Evolve, guaranteeing consistenc
y between the two environments.
 Instead of using the engine to display graphical forms, the runtime uses
 the engine to apply the deltas to form fully realised components, which
 have links back to the actual implementation class via the implementation-class
 annotations.
 It then flattens the hierarchy and uses reflection to instantiate and connect
 up the instances in conformance to the architecture.
 At that point control can be handed off to the leaf component presenting
 the IRun interface which represents the starting point of the program.
\end_layout

\begin_layout Standard
Alternatively Evolve can emit code for a builder class representing the
 flattened structure of the system - this requires no runtime and has all
 facilities available including factory instantiation.
 This mode is particularly useful in supported but constrained environments
 such as GWT [ref] which do not support full reflection and other advanced
 virtual machine features.
\end_layout

\begin_layout Standard
Although nothing prevents support for other languages, currently the runtime
 is targeted to the Java language and the Java virtual machine.
 Reflection is used extensively in the implementation of the runtime, but
 as noted previously this only adds overhead in the direct construction
 of component instances.
 If a builder class is emitted instead of using the runtime, then there
 is no overhead compared to a conventional Java program.
\end_layout

\begin_layout Subsection
Compatibility with Existing Libraries
\end_layout

\begin_layout Standard
Java has a lightweight component model called JavaBeans [] which uses a
 set of lexical conventions to allow setting and getting of properties on
 classes.
 Evolve allows bean libraries to be imported and translated into full Backbone
 leaf components by considering any implemented interfaces of a bean to
 be provided interfaces on a port called 
\family typewriter
main
\family default
, and any settable properties that are interfaces to be required interfaces.
 In this way existing Java libraries are fully compatible with the Evolve
 approach, and can be connected up into composite components.
 This is in contrast with the conventional JavaBeans wiring approach which
 is oriented explicitly around events and hence required interfaces only.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Imported-Swing-components"

\end_inset

 shows a number of well-known Swing [] components that have been imported
 into Evolve for use in an application.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/swing.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Imported-Swing-components"

\end_inset

Imported Swing components
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Applicability-to-Mature"

\end_inset

Applicability to Mature and Legacy Systems
\end_layout

\begin_layout Standard
To evaluate the applicability of the approach to existing software, we chose
 to introduce our component model into the LTSA system [] which was created
 by two of the authors previously for analysing the properties of concurrent
 programs.
 Our intention was to model the evolution of this mature system and to gain
 insights into the way that evolution and architectural explication interact.
\end_layout

\begin_layout Standard
The original codebase is around 16k physical lines of code from over 200
 classes.
 It consists of a graphical front end along with an automata-based engine
 which can analyze the properties of finite state process expressions using
 model checking [].
\end_layout

\begin_layout Standard
LTSA has evolved into several variants over years, reflecting its relatively
 wide use in academia and industry and the somewhat decentralized nature
 of its development.
 We chose to concentrate on the original system, the AMES evolution, and
 a separate evolution created for the exercise called DualWindow.
 Furthermore, we wished to model the merged AMES and DualWindow systems.
\end_layout

\begin_layout Subsection
An Initial View of the Architecture
\end_layout

\begin_layout Standard
We performed a first pass at forming a shallow and coarse-grained compositional
 structure for the original LTSA application, reflecting that it is not
 feasible to restructure a mature application in one step.
 The intention was to demonstrate that the approach can be applied with
 relatively small effort initially, with benefits accruing as the system
 is incrementally decomposed further into smaller components over time.
\end_layout

\begin_layout Standard
We started by spending some time understanding the LTSA code - for this
 we used the primary author who was not familiar with the existing system.
 After this a strata graph was formed and handful of top-level candidate
 classes were identified for turning into components.
\end_layout

\begin_layout Standard
We refactored these classes into JavaBeans and imported them into Evolve.
 Finally, a top-level composite called LTSA was created which wired these
 together allowing the system to execute inside the Evolve environment.
 This work took two person-days of effort in total.
\end_layout

\begin_layout Standard
The strata graph for the system is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-strata-for"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/ltsa-strata.eps
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-strata-for"

\end_inset

The strata for the LTSA application
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As the architecture was now visible as components, further decomposition
 was straight forward.
 After spending another day of modest refactoring the refined compositional
 hierarchy in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:LTSA-decompositions"

\end_inset

 (B) was produced.
 Note that the original decomposition (A) was a subset of this refinement
 - decomposing involves exposing further parts of the architecture.
 At this point many of the features of the graphical interface were exposed
 as components.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename drawings/ltsa-initial-hierarchy.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:LTSA-decompositions"

\end_inset

LTSA decompositions
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The top level LTSA component and the HPWindow component which managed other
 windows looked as in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Top-level-LTSA"

\end_inset

 at this point.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/top-level.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Top-level-LTSA"

\end_inset

Top level LTSA components
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
A somewhat expected, but key finding was that the best candidate classes
 for turning into components were those which already implemented interfaces
 (provides) and were decoupled from other classes via interfaces also (requires).
 This 
\begin_inset Quotes eld
\end_inset

interface-centric
\begin_inset Quotes erd
\end_inset

 programming technique has become prominent in object-oriented languages
 [].
 Turning LTSA classes into Evolve components simply involved adopting this
 modern style more forcefully.
\end_layout

\begin_layout Subsection
Architectural Views
\end_layout

\begin_layout Standard
As the architectectural exploration continued we realized that compositional
 hierarchy was not enough to control the complexity of the diagrams produced.
 Separate architectural views of the same component shown from different
 
\begin_inset Quotes eld
\end_inset

angles
\begin_inset Quotes erd
\end_inset

 was required and we added this feature to Evolve.
\end_layout

\begin_layout Standard
For instance, figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Top-level-LTSA"

\end_inset

 clearly does not show all of the components at the first level of decomposition.
 It instead shows only the parts which are relevant to window control.
 The dots in the lower right corner of the LTSA component indicate that
 artifacts have been elided.
\end_layout

\begin_layout Standard
Consider another view of the same component in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Parsing-view-of"

\end_inset

, showing how the LTS compose action is constructed.
 Note that these views are all of the same component but eliding and showing
 different parts, attributes and connectors.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/ltsa-compose-ltsa.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Parsing-view-of"

\end_inset

Compose action view of LTSA
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In our architecture description we used twelve views of the LTSA component,
 reflecting the different possible graphical windows, actions and checks.
\end_layout

\begin_layout Subsection
Modeling the Evolutions
\end_layout

\begin_layout Subsubsection*
The Ames
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The Ames variant originated from the NASA Ames Research Centre
\end_layout

\end_inset

 Variant
\end_layout

\begin_layout Standard
This evolution adds extra safety checks to the base system: the first checks
 for safety whilst producting multiple counterexamples, and the second checks
 for safety but ignores deadlock.
 This system was produced by researchers copying and modifying the source
 code of the original LTSA aplication, leading to disparate codebases.
\end_layout

\begin_layout Standard
To express this application as a direct evolution we first compared the
 two codebases using textual comparison tools, eventually reducing the core
 difference in logic down to changes in the Analyser class and several others.
\end_layout

\begin_layout Standard
The changes to the Analyser represented a modest proportion of the class'
 overall implementation.
 To effect the evolved components on top of the original architecture using
 our concepts we had to replace the entire Analyser with the Ames variant
 reflecting the current level of decomposition.
 An alternative would have been to continue decomposing the class into finer-gra
ined components until it reached the granularity required to allow the changes
 at the correct level of abstraction.
\end_layout

\begin_layout Standard
This represents another key insight: a hierarchically decomposed system
 with fine granularity allows component replacement (and hence evolution)
 at the appropriate abstraction level.
 Architectural explication and evolution are aligned as further decomposition
 for understanding and explication presents greater opportunities to align
 any evolution with the size of the changes required.
\end_layout

\begin_layout Standard
We actually chose to take a different approach - instead of direct replacement,
 we instead used a component variant of the decorator pattern [] to add
 the extra checks.
 We evolved the component and wrapped the former version (renamed to ExtendedAna
lyser) as per figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-wrapped-Analyser"

\end_inset

.
 This is an alternative to coarse-level replacement, allowing features to
 be added and existing features masked or intercepted.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/ltsa-ames-analyser.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-wrapped-Analyser"

\end_inset

The wrapped Analyser component
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
The DualWindow Variant
\end_layout

\begin_layout Standard
The intention of this variant was to allow both the alphabet window and
 the transitions window to be present on the screen simultaneously, thereby
 improving the usability of the tool.
 To do this we created the DualWindow stratum with the DualWindowcomposite
 which provided the same interface IWindow as the original screen but combined
 the two.
 We further created a factory component to allow this to be instantiated
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-DualWindow-component"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/ltsa-dual-window.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-DualWindow-component"

\end_inset

The DualWindow component and factory
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inside the DualWindow stratum, we then evolved the LTSA top-level component
 and replaced the AlphabetWindowFactory part with a DualWindowFactory one.
 We also replaced the HPWindow part with an instance of the same type but
 with amended properties.
 This is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Evolving-LTSA-to"

\end_inset

.
 The Backbone text underneath describes the deltas.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/ltsa-dualwindow-evolution.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Evolving-LTSA-to"

\end_inset

Evolving LTSA to support dual windows
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Merging the Evolutions
\end_layout

\begin_layout Standard
To merge the evolved architectures we created another (empty) stratum called
 combined which depends on the two variant strata (figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Combining-the-evolutions"

\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/ltsa-stratum-extensions.eps
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Combining-the-evolutions"

\end_inset

Combining the evolutions using a further stratum
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
According to the rules described earlier this strata arrangement leads to
 a rewriting of the resemblance relations to incorporate the independent
 evolutions in a unified graph.
 The expanded resemblance graph of the LTSA component from the perspective
 of the combined stratum is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-expanded-LTSA"

\end_inset

.
 We can see that the independent evolutions result in independent branches
 of the graph and that the combining stratum joins them back again.
 This happens automatically - if a combining stratum does not declare an
 evolution then the net effect of the rules is as if a default implicit
 evolution is created to ensure a merge.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/expanded.eps
	width 60col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-expanded-LTSA"

\end_inset

The expanded LTSA resemblance graph
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case a full error check revealed there were no conflicts requiring
 resolution, and the two variants were able to be combined and run together
 successfully.
 If conflicts had actually occurred these could have been rectified by explicitl
y evolving the LTSA component in the combined stratum and adjusting or replacing
 the erroneous constituents using deltas.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Compositional-history-of"

\end_inset

 shows the compositional history of the LTSA evolutions.
 The depth and breadth of composition changed over time reflecting the deepening
 explication of the architecture and the evolution of the components in
 each of the variants.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide true
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename drawings/ltsa-compositions.png
	lyxscale 50
	width 75page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Compositional-history-of"

\end_inset

Compositional history of the LTSA evolutions and merge
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Conclusion
\end_layout

\begin_layout Standard
Incorporating the Evolve approach into a mature application involves initially
 decomposing the architecture down to a sufficient level of granularity
 to enable the evolutionary variants to be expressed via component replacements.
 This relies on refactoring the architecture to turn identified candidate
 classes into components with both provided and required interfaces.
 This accords well with best practice object-oriented design which uses
 interfaces heavily for decoupling.
\end_layout

\begin_layout Standard
Decomposing the architecture into finer-grained components and allowing
 evolution to be clearly expressed align neatly - these cooperating forces
 lead to a system with an explicit architecture which can be evolved with
 commensurate effort related to the size of the change required.
\end_layout

\begin_layout Standard
Branching and merging of evolutionary variants can be explicitly represented
 using strata.
 The branches and joins of the resultant expanded resemblance graphs reflect
 the strata dependencies.
 Further, the same constructs allowing evolution allow any merge conflicts
 to be rectified regardless of the level of the conflict in the compositional
 hierarchy.
\end_layout

\begin_layout Section
Developer Workflow in a Distributed Environment
\end_layout

\begin_layout Standard
Our approach is designed to support developers extending and evolving a
 system in a setting where (in the worst case) the parties may have limited
 communication and may not share networks or other resources.
 For instance, the initial system can be created by one party, who can then
 export the definition and implementation to other parties who can evolve
 it and branch it without affecting the original definitions.
 We can later merge these branches back into a single model and rectify
 any structural conflicts using the same constructs available for evolution.
\end_layout

\begin_layout Standard
Consider how development and evolution of the LTSA system (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Applicability-to-Mature"

\end_inset

) might have proceeded.
 Firstly, the original architecture and implementation of the system would
 have been created by developer X.
 At this point, X has only the LTSA stratum present in their system, as
 shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:LTSA-System-as"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename drawings/wf-original.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:LTSA-System-as"

\end_inset

LTSA System as seen by its creator
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Developers Y and Z now wish to separately evolve the system.
 To facilitate this, X exports the LTSA stratum from their environment and
 distributes both the exported stratum (.evolve file) and compiled files
 representing the implementation (jars) to both developers.
\end_layout

\begin_layout Standard
Y and Z each create their own extension strata in their separate environments.
\end_layout

\begin_layout Standard
Consider that Y has decided to implement the dual window extension.
 Y will import the LTSA stratum (as read-only because they do not own this)
 and create the dual window stratum as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-system-as-1"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename drawings/wf-dual.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-system-as"

\end_inset

The system as seen by Y
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Z has decided to implement the Ames evolution.
 Z imports the LTSA stratum (again as read-only) and creates the Ames stratum
 as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-system-as-1"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename drawings/wf-ames.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-system-as-1"

\end_inset

The system as seen by Z
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that Y and Z are free to make any changes to the base architecture
 as long as the evolutions are contained in the stratum that they own.
 They cannot directly edit the LTSA stratum as this is owned by X.
\end_layout

\begin_layout Standard
Now consider that X wishes to accept both extensions from Y and Z and merge
 them into a common architecture.
 To do this, X imports both the dual window and Ames strata (and associated
 implementation jars) into their original environment.
 The two imported strata are marked as read-only, as X does not own these.
 To create the merge, X further creates the combined stratum.
 Any structural conflicts can be rectified in that stratum which X owns.
 This is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Merging-the-two"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename drawings/wf-merged.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Merging-the-two"

\end_inset

Merging the two evolutions
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The general principle in a distributed setting is that the import and export
 of strata allow for sharing and collaboration.
 We export strata that we own, and import strata that are owned by others.
 We only directly edit our own strata, but we can express any changes to
 architectures created by imported strata by creating our own further stratum
 that depends on the imported ones.
\end_layout

\begin_layout Standard
The sharing of artifacts in this disconnected way is made possible by the
 use and allocation of UUIDs for each element.
 This guarantees that accidental conflict due to human readable names being
 the same will not occur.
\end_layout

\begin_layout Section
Analysis and Assessment
\end_layout

\begin_layout Standard
In this section we distil a set of essential properties required of an architect
ural approach to evolution and evaluate Evolve against these.
 We further distinguish additional noteworthy properties of our approach.
 In the next section we use these properties to assess related work against
 the same criteria.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Essential-Properties-of"

\end_inset

Essential Properties of an Architectural Approach to Evolution
\end_layout

\begin_layout Subsubsection*
Property 1: ARCHITECTURAL_ALTER
\end_layout

\begin_layout Standard
An approach should allow the architecture of a system to be altered in (possibly
) unplanned ways to accommodate new features and requirements.
 The unit of change should be architectural (component, interfaces, constituents
) and there should be no arbitrary constraints on what type of features
 can be added or removed.
 It should also be possible to switch between the base system or the evolved
 system as desired - an evolution should not affect or destructively edit
 the base architecture.
\end_layout

\begin_layout Standard
Evolve supports this property via deltas against components and interfaces.
 Components can be evolved by adding, replacing or deleting at the level
 of attribute, connector, part or implementation class mappings.
 Interfaces can be evolved at the level of operation or implementation realizati
on.
 This does not affect the base architecture - the evolution is instead recorded
 as a set of deltas in a stratum which depends on the base stratum, allowing
 the architect to switch between the base and evolved system.
\end_layout

\begin_layout Standard
This level of expressiveness clearly allows invalid systems to be created.
 We supplement this freedom with a comprehensive set of checks which determine
 the structural well-formedness of a system.
 No behavioural checking is currently done - this is considered in future
 work.
\end_layout

\begin_layout Subsubsection*
Property 2: APPROPRIATE_LEVEL
\end_layout

\begin_layout Standard
The architecture should be able to be evolved at the appropriate abstraction
 level.
 Further the level of change required should be commensurate with the actual
 change in functionality.
 Sometimes coarse-grained replacement is required when making large-scale
 changes, at other times fine-grained adjustment is all that is needed.
\end_layout

\begin_layout Standard
A hierarchical component model like the one used by Evolve meets the above
 property nicely.
 It neatly resolves the conflict between coarse and fine-grained components
 by allowing larger components to be built up from instances of smaller
 ones.
 If a hierarchical model is not used, then it can be difficult to evolve
 the architecture at the correct level of abstraction.
\end_layout

\begin_layout Subsubsection*
Property 3: BRANCH
\end_layout

\begin_layout Standard
It should be possible to create independent branches of a system, reflecting
 that work may proceed in parallel even within the same organization.
\end_layout

\begin_layout Standard
Evolve supports this property via the stratum concept which allows a set
 of changes to be grouped, and dependencies to be explicitly indicated.
 Two strata that have no visibility of each other via transitive dependencies,
 but nevertheless share common strata in their dependency graph, are independent
 branches of the same underlying system.
 An example of this is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Branches-and-a"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/branching.eps
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Branches-and-a"

\end_inset

Branches and a merge of a base system
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Property 4: MERGE_DETECT_CORRECT
\end_layout

\begin_layout Standard
It should be possible to merge branches back into a single architecture,
 where any inconsistencies or conflicts are detected and can be corrected
 architecturally at the appropriate level of abstraction.
\end_layout

\begin_layout Standard
We support this via a single stratum which depends on two or more branch
 strata, as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Branches-and-a"

\end_inset

.
 Under the rules of section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:A-Formal-Description"

\end_inset

, separate evolutions of a component in branches will result in an expanded
 resemblance graph which is similarly branched.
 Simple conflicts are detected where the same constituent has been deleted
 or replaced separately in each branch, requiring a further evolution in
 the merge stratum to choose one of the outcomes as preferred.
\end_layout

\begin_layout Standard
More complex structural conflicts are detected by checking the rules against
 the merged architecture.
 Any violation of the rules can be dealt with via another evolution, at
 the desired level in the composition hierarchy.
\end_layout

\begin_layout Subsubsection*
Property 5: EXPANDED
\end_layout

\begin_layout Standard
It should be possible to work with the expanded system at all times regardless
 of any evolutions being specified via deltas.
\end_layout

\begin_layout Standard
Evolve supports this by showing the expanded version of each component,
 and recording deltas in the underlying repository.
 This also reveals a potential limitation of the approach - deltas are recorded
 on deltas as subsequent evolutions accrue.
 We plan to address this in further work via the baselining concept.
\end_layout

\begin_layout Subsection
Further Desirable Properties
\end_layout

\begin_layout Subsubsection*
Property 6: DISTRIBUTED
\end_layout

\begin_layout Standard
A modern trend of configuration management (CM) systems is to allow for
 distributed and disconnected operation, where parties do not have to share
 access to the same underlying repository in order to evolve a system [].
 Each developer holds a full history of the repository, and unique identifiers
 (UUIDs) assigned to changesets ensure guaranteed merge order.
 This is in contrast to centralized CM systems that expect that all parties
 will have access to the single, central repository for any operations.
 An example of the distributed approach for source code control is Mercurial
 [], and an example of the centralized approach is Subversion [].
\end_layout

\begin_layout Standard
Evolve facilitates a distributed mode of working by assigning a UUID to
 each stratum guaranteeing that exporting from one repository into another
 will preserve the dependency structure.
 Furthermore, each component, interface and constituent are also allocated
 a UUID to ensure that textual naming conflicts in branches do not present
 a problem.
 A stratum, its dependencies and its contents can therefore be copied safely
 between repositories in a distributed setting.
\end_layout

\begin_layout Standard
In the related work section we examine the conceptual overlap between our
 approach and that of the Mercurial distributed CM system.
\end_layout

\begin_layout Subsubsection*
Property 7: CM_AGNOSTIC
\end_layout

\begin_layout Standard
It is not feasible to tie industrial developers to a bespoke or niche CM
 system - any approach to architectural evolution must work in sympathy
 with well supported, commonly used CM systems and best practices.
\end_layout

\begin_layout Standard
Evolve places no constraints on the underlying versioning system used -
 architectural configurations may be version controlled in the same manner
 as source code.
 This allows the approach to be used to express different axes of evolution,
 such as product lines, within a single source base that is also versioned
 textually.
\end_layout

\begin_layout Subsubsection*
Property 8: MODELING
\end_layout

\begin_layout Standard
The features allowing evolution should be more than a change control adjunct
 to the architectural modeling facilities offered.
 The concepts rather should be completely integral to the architectural
 approach, allowing these to be used when designing and modeling a system
 also.
\end_layout

\begin_layout Standard
In Evolve the evolution constructs are tightly integrate into the architectural
 definition language itself with resemblance / inheritance (normally a design
 concept) closely related to evolution (normally a CM concept).
\end_layout

\begin_layout Subsubsection*
Property 9: LIVE_BASE
\end_layout

\begin_layout Standard
In conventional CM systems a base architecture is rendered immutable once
 a branch or evolution has been created from it.
 The base is in essence frozen in time.
\end_layout

\begin_layout Standard
In contrast, a base architecture in Evolve can be modified and changes will
 flow automatically through to any evolutions.
 This is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Adding-an-attribute"

\end_inset

(a) where initially the base component X has no attributes and therefore
 evolved component E has none also.
 In (b) we adjust the base component and note that the change automatically
 propagates.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/live-base.eps
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Adding-an-attribute"

\end_inset

Adding an attribute to a base component
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This approach is particularly useful when decomposing an existing base architect
ure to reveal finer grained structure without violating existing component
 boundaries.
 The evolved systems will automatically pick up the enhanced structure.
 Any introduced errors will be detected via the structural rules.
\end_layout

\begin_layout Subsubsection*
Property 10: IMPLEMENTATION_MAPPINGS
\end_layout

\begin_layout Standard
As the architecture evolves we also may wish to adjust and create mappings
 to implementation constructs.
 Any approach should therefore also handle these mappings.
\end_layout

\begin_layout Standard
The mapping from Evolve component to implementation class is a standard
 constituent of each leaf component and hence can be evolved as part of
 the same approach.
 This allows the mappings to be controlled and evolved in a consistent way
 with the rest of the architecture.
\end_layout

\begin_layout Subsubsection*
Property 11: NO_SOURCE
\end_layout

\begin_layout Standard
Following on from this, the source code of a system should not necessarily
 be required to evolve that system - in many situations adjusting the implementa
tion mappings instead will suffice.
 This approach offers several benefits.
 In the first instance, this allows a level of evolution without being exposed
 to the complexity of the full source code (as per plugin systems).
 Also, the code may not be available for commercial or other reasons.
\end_layout

\begin_layout Standard
In Evolve, if the architectural description of a system is available then
 adjusting the architectural definitions and implementation mappings is
 sufficient to achieve any required evolution.
 The work required to achieve this may vary depending on the granularity
 of the components being replaced.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
We discuss related work from a number of separate directions.
 Firstly, we observe that Evolve overlaps with other architectural approaches
 to CM.
 This neatly leads to a comparison of our approach with textual, distributed
 CM systems.
\end_layout

\begin_layout Standard
We then compare Evolve to extensible systems which provide a limited form
 of evolution in order to allow new features to be added to a base platform
 without destroying the original architecture.
 Finally we compare and contrast our approach to an aspect-oriented architectura
l view.
\end_layout

\begin_layout Subsection
Architecture Description Languages
\end_layout

\begin_layout Standard
It has long been recognised that components form a convenient and powerful
 unit of software design, composition and reuse [].
 ADLs build on this foundation to describe the structure of a system as
 a connected set of components.
 An important advance was the composite component concept whereby a wiring
 up of component instances itself forms a new component, thereby enabling
 a hierarchical approach to system construction [darwin].
\end_layout

\begin_layout Standard
Some ADLs permit structural inheritance where a new component is defined
 in terms of structural changes to a parent [room, patent guy].
 This is related to the concept of object-oriented inheritance in that it
 allows changes from a set of parent component to be used to create a new
 entity.
 This increases reusability by allowing us to define a new set of components
 in terms of structural addition or deletion from parents - effectively
 a limited form of evolution.
\end_layout

\begin_layout Standard
However, this only allows us to define new components in terms of older
 ones - existing components cannot be altered.
 This poses a dilemma - as we build up our architecture as a set of composite
 components, which themselves are made up of instances of other composite
 components and so on, we form a potentially deep compositional hierarchy.
 Structural inheritance only allows us to adjust the topmost level of any
 hierarchy as we create a new component.
 As this hierarchy gets deeper, we are effectively 
\begin_inset Quotes eld
\end_inset

burying
\begin_inset Quotes erd
\end_inset

 architecture under compositional layers, making evolution of the lower
 layers difficult to achieve.
\end_layout

\begin_layout Standard
As such, ADLs with structural inheritance do not fully support ARCHITECTURAL_ALT
ER.
 Depending on whether multiple inheritance and conflict resolution is allowed
 BRANCH and MERGE_DETECT_CORRECT may not be supported.
 There is no support for distributed development concepts such as DISTRIBUTED,
 although CM_AGNOSTIC and MODELING are well catered for.
\end_layout

\begin_layout Standard
Evolve's key contribution is to supplement structural inheritance with replaceme
nt, and to precisely define the way that the two constructs interact.
 Replacement allows us to globally substitute the definition of a component,
 and combined with resemblance (structural inheritance) this allows the
 incremental evolution of any component.
 Using this we can deeply alter existing compositional hierarchies at any
 level and resolve any conflicts that occur when branches of the same architectu
re are merged.
\end_layout

\begin_layout Subsection
Architecturally Aware Configuration Management Systems
\end_layout

\begin_layout Standard
MAE [] is a centralized CM system that works with architectural deltas rather
 than textual deltas.
 This permits the explicit evolution and merging of architectural configurations
 at the level of architectural concepts, thereby satisfying the essential
 properties outlined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Essential-Properties-of"

\end_inset

.
\end_layout

\begin_layout Standard
However, as MAE is a version control system it cannot easily be used with
 conventional CM systems - it does not satisfy CM_AGNOSTIC.
 Further, although it has been suggested that the MAE repository can be
 decentralised using a technique known as interfile branching [], this little-kn
own technique has not to the best of our knowledge been applied to the approach
 or evaluated.
 As such, we can for all practical purposes assume that MAE does not support
 the DISTRIBUTED property.
\end_layout

\begin_layout Standard
Further, as CM is a separate activity from development, MAE does not integrate
 evolution into the core design and development workflows.
 Rather it is a way of holding and tracking architectural evolution rather
 than an approach which lends itself to a unified methodology between design
 and evolution (MODELING).
\end_layout

\begin_layout Standard
The above reveals a fundamental weakness - by coupling architectural evolution
 to an implementation of an underlying CM approach we lose the ability to
 pick the best of breed source code control systems, and to integrate more
 closely with development concepts.
\end_layout

\begin_layout Standard
MAE does not support the LIVE_BASE, IMPLEMENTATION_MAPPINGS or NO_SOURCE
 properties.
\end_layout

\begin_layout Subsection
Distributed Configuration Management Systems
\end_layout

\begin_layout Standard
Distributed textual CM systems allow each developer to have a full or partial
 copy of the repository on their machine, allowing for operation even if
 not connected to a designated 
\begin_inset Quotes eld
\end_inset

central
\begin_inset Quotes erd
\end_inset

 repository.
 A commit is represented as an atomic change set, which has zero, one or
 two possible parents.
 A newly created changeset starting from scratch has no parent, a linear
 evolution of a base has one change set, and a merge has two change sets.
 Mercurial is a well known example of this approach [].
\end_layout

\begin_layout Standard
Each changeset is identified by a UUID and the parent/child dependency relations
hip is represented by UUID pairs.
 This allows changesets to be exported from one repository into another,
 guaranteeing that dependency order will be preserved.
\end_layout

\begin_layout Standard
Evolve shares a number of concepts with these systems.
 A stratum is conceptually related to a changeset, though the deltas are
 architectural rather than textual.
 Also, a stratum may have many parents reflecting that it is a design as
 well as a change construct.
 UUIDs are used for identification allowing the export and import between
 repositories.
 Unlike changesets, however, strata are not constrained by rule to be immutable
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
By convention an imported stratum is marked as read-only, as it is generally
 not owned by the importer.
\end_layout

\end_inset

, and if changes are made to a base stratum they propagate to dependent
 strata as per LIVE_BASE.
 As such, Mercurial does not support this property.
\end_layout

\begin_layout Standard
Textual CM systems also violate many other of the required and desired propertie
s for an architectural approach because they work with text deltas rather
 than architectural deltas.
\end_layout

\begin_layout Subsection
Extensibility Architectures
\end_layout

\begin_layout Standard
Eclipse uses a plugin-based architecture to allow the system to be extended
 for additional features [].
 Each plugin has a version number where the minor digits are used to represent
 evolution which does not break existing interfaces, and the major digits
 represent breaking change.
 Plugins also declare dependencies on other plugins.
 Through introducing new versions of plugins, an evolved system can be produced
 with any extensions required.
 In this way, plugins act like change sets in a CM system or strata in Evolve,
 and are similar to modules.
\end_layout

\begin_layout Standard
However, plugins are not hierarchical meaning that if the source code is
 not available and the plugin must be replaced for evolution then even a
 small required change can result in significant work.
 This highlights an architectural limitation of the approach - plugins form
 both the unit of grouping and the unit of change.
 In effect, plugins form the replaceable components.
 This violates parts of the ARCHITECTURAL_ALTER and APPROPRIATE_LEVEL properties.
 It also makes evolution difficult without source code, violating NO_SOURCE.
\end_layout

\begin_layout Standard
Furthermore, although the model ensures that much structural conflict is
 avoided, it is not possible to detect conflicts between conflicts in any
 way without executing and testing the various combinations.
 This violates MERGE_DETECT_CORRECT.
\end_layout

\begin_layout Subsection
Product Lines
\end_layout

\begin_layout Standard
Easel [] is a product-line architectural approach that builds on the ArchStudio
 toolset [].
 Although it is not a CM system per se, it is related in that it allows
 change sets to be applied against an architecture expressed as components
 and connectors.
 Change sets can be associated to features, and these can be combined to
 form variants in the product line.
 UUIDs are used to identify change sets and individual architectural entities.
\end_layout

\begin_layout Standard
As such, Easel is conceptually similar to the Evolve approach with a number
 of similar features.
 It supports many of the required and desired properties.
 It differs, however, from our approach in that it does not unify modeling
 concepts (structural inheritance) with evolution, leading to a simplistic
 merging approach (MERGE_DETECT_CORRECT).
 Easel change sets are not hierarchical, unlike Evolve strata, leading to
 a tension between modules and the granularity of expressed change.
 The delta primitives are ADD and DELETE and not REPLACE, causing unnecessary
 loss of identity when replacement is required and leading to extraneous
 merge issues.
\end_layout

\begin_layout Standard
Further, implementation mappings are not explicitly handled via the approach.
 As such, Easel does not support IMPLEMENTATION_MAPPINGS or NO_SOURCE.
\end_layout

\begin_layout Standard
AHEAD is a compositional approach to product lines [].
 It introduces constants, which are analogous to a baseline architecture,
 and functions which refine constants and can be concatenated to form an
 equation.
 The order of concatenation is important as some forms of refinement involve
 overriding parts of other artifacts.
 
\end_layout

\begin_layout Standard
Mapped onto Java, a constant is a set of class definitions, and a function
 contains both class definitions and refinements of classes consisting of
 field and method additions and method overrides.
\end_layout

\begin_layout Standard
Although AHEAD deals with classes typically rather than architectural constructs
, it can be applied to components via the adoption of conventions.
 It is possible, however, to introduce functions that when combined cause
 conflict with no possible resolution other than revisiting the functions
 and rewriting the equation.
 As such, the technique does not fully support the MERGE_DETECT_CORRECT
 property.
\end_layout

\begin_layout Subsection
Difference-Based Modules
\end_layout

\begin_layout Standard
MixJuice adds a module system to Java, where modules describe the difference
 between the base and evolved application [].
 Modules can override classes in the base, allowing unplanned changes to
 be catered for.
 In this sense they are similar to Mercurial change sets or Evolve strata.
\end_layout

\begin_layout Standard
Because it utilises the Java class model rather than component structures,
 MixJuice is not fully compliant with a hierarchical architectural approach.
 Some changes cannot be expressed, and merge conflicts which cannot be corrected
 via method override can not be resolved.
 As such the approach violates the MERGE_DETECT_CORRECT and APPROPRIATE_LEVEL
 properties.
\end_layout

\begin_layout Subsection
Architectural Aspects
\end_layout

\begin_layout Standard
Aspects have been proposed as a way to evolve an architecture.
 TranSAT allows architectural concerns to be specified as aspects [].
 These aspects are 
\begin_inset Quotes eld
\end_inset

woven
\begin_inset Quotes erd
\end_inset

 into a base architecture to evolve it allowing additional, possibly cross-cutti
ng features to be added in a modular way.
\end_layout

\begin_layout Standard
Each aspect can modify the underlying architectural structure of the base
 using a small language where join points are specified declaratively as
 a set of structural and behavioral matches.
 The set of remaking instructions are similar to those specified in [MK96],
 and via removal an aspect can remove as well as add functionality.
\end_layout

\begin_layout Standard
Like other aspect approaches, this system suffers from a relatively weaker
 secondary axis (aspects) that is separate from the primary axis (base architect
ure).
 Further, aspects do not always combine well and resultant conflicts cannot
 always be rectified [].
 As such, it violates the ARCHITECTURAL_ALTER, MERGE_DETECT_CORRECT and
 other properties.
\end_layout

\begin_layout Standard
Evolution in Evolve can be used in place of aspects in most situations.
 A stratum can weave additional concerns into a base architecture by placing
 parts between existing connected parts in base components.
 We must, however, explicitly quantify the join points, as opposed to using
 the lexical quantification mechanisms of conventional aspect-orientation
 [].
 As described in the e language, which uses related evolution primitives
 to allow verification scripts to be evolved, this forms a perfectly workable
 aspect substitute [].
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Conclusions-and-Further"

\end_inset

Conclusions and Further Work
\end_layout

\begin_layout Standard
The evolution of any software system is inevitable as it is adjusted over
 time to deal with improvements and changes in functionality and requirements.
 These changes are currently typically captured at the level of textual
 differences between releases at a granular and non-architectural level
 in configuration management systems.
 This leads to a set of challenges and limitations in tying back these changes
 to an architectural description, particularly in a distributed development
 setting.
 We have captured these issues as a set of essential and desirable properties
 for any architectural approach to the problem.
\end_layout

\begin_layout Standard
The desirable properties cover the ability to make any changes at an architectur
al level (ARCHITECTURAL_ALTER, APPROPRIATE_LEVEL) and later combine these
 changes if the architectures have diverged between independent branches
 (BRANCH, MERGE_DETECT_CORRECT, EXPANDED).
 The further desired properties cover the link between architecture and
 implementation (IMPLEMENTATION_MAPPINGS, NO_SOURCE), the relationship between
 system modeling and evolution (MODELING, LIVE_BASE) and how we capture
 change relative to other approaches in a distributed development setting
 (DISTRIBUTED, CM_AGNOSTIC).
\end_layout

\begin_layout Standard
Our approach is to supplement a hierarchical ADL with three additional concepts.
 The first is resemblance, which allows a new component to be defined in
 terms of structural change to existing components.
 This leads naturally to the idea of combining related sets of definitions
 into module structures called stratum, which express dependencies on other
 strata, allowing us to layer a system and express development ownership
 of parts of that system.
 Stratum form the natural unit of sharing in a distributed setting.
\end_layout

\begin_layout Standard
Finally, we add the replacement concept to allow global substitution of
 a component, 
\emph on
within
\emph default
 the scope of the stratum that the replacement is owned by.
 Combined with resemblance, this gives us the ability to incrementally evolve
 any part of the architecture, such that the view of the architecture from
 existing stratum is not affected.
 We can therefore capture the gradual evolution of a system in a set of
 stratum, which themselves can be shared in a distributed development setting.
 Conflict resolution between merged architectures is handled by the same
 constructs.
 In essence, we allow evolution of a system to be packaged up in a stratum
 which depends on the original system stratum.
 Evolution and the description of change to a system is packaged up as an
 additional module.
\end_layout

\begin_layout Standard
In applying our approach to a mature system (c.f.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Applicability-to-Mature"

\end_inset

) we found that we could gradually decompose an existing code base into
 architectural components over time, allowing the evolution to drive the
 granular decomposition of the architecture.
 In other words, as the system was evolved the architecture became more
 explicit and fine-grained leading to a symbiotic relationship between change
 and architectural explication.
\end_layout

\begin_layout Standard
The analysis of existing extensibility approaches showed that extensibility
 is effectively a limited and constrained form of evolution, which occurs
 in a distributed development setting of many parties.
 Therefore, the same concepts which we use to allow architectural evolution
 can also be applied, leading to an advanced approach to extensible systems.
 This gives far more flexibility to make changes (ARCHITECTURAL_ALTER) and
 later combine and rectify any divergence (BRANCH, MERGE_DETECT_CORRECT)
 than existing approaches such as plugin architectures.
\end_layout

\begin_layout Standard
In applying the approach we have found a number of characteristics and limitatio
ns.
 In particular, the effort required to evolve a system depends on how finely
 grained the architectural decomposition is already.
 If we need to replace a component to adjust a small part of its functionality,
 and the component is large and monolithic then the architectural change
 will not be proportionate to the change in functionality required.
 This is tempered by the previously mentioned positive relationship between
 evolution and gradual architectural decomposition we found when evolving
 a mature system.
\end_layout

\begin_layout Standard
Further, our approach so far has been purely limited to structural concerns.
 Clearly, behavioral conflict is still possible in a structurally well-formed
 system that has been merged from a number of branches.
 We plan to address this in further work by allowing a behavioral description
 [fsp] to be attached to the structural definition of each (possibly evolved)
 component.
 We will then check the system against a number of goals to ensure that
 the changes have not affected the behavioral integrity of the system.
\end_layout

\begin_layout Standard
We have built a mature toolset around our approach, including a modeling
 tool Evolve which supports the Backbone ADL.
 This toolset supports all aspects of the approach allowing the architecture
 and deltas to be viewed graphically or textually [intrinsarc].
 A key issue is that components and constituents are identitied by globally
 unique identifers allowing us to remove the ambiguity involved when trying
 to reconcile diverged branches with human readable names only.
 As we have shown, a graphical approach is able to hide the UUIDs, presenting
 the human readable names for presentation thereby delivering the benefits
 of both.
\end_layout

\end_body
\end_document
