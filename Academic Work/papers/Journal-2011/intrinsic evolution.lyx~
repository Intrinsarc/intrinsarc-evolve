#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass IEEEtran
\begin_preamble
\parindent 10pt

\markboth{IEEE TRANSACTIONS ON SOFTWARE ENGINEERING}{MCVEIGH ET AL.: INTRINSIC DEFINITION IN SOFTWARE ARCHITECTURE EVOLUTION}

\IEEEpubid{0000--0000/00\$00.00 \copyright 2007 IEEE}

\pagenumbering{gobble}

 \hyphenation{Java-Bean Java-Beans}
\end_preamble
\options compsoc
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans helvet
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing other 1.1000000000000001
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
IEEEcompsoctitleabstractindextext{
\backslash
small
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Abstract
\series default
---Incremental change is intrinsic to both the initial development and subsequen
t evolution of large complex software systems.
 We present an approach that captures this incremental change in the definition
 of software architecture.
 The predominant advantage in making the definition of evolution intrinsic
 to architecture description is in permitting a principled and manageable
 way of dealing with unplanned change and extension.
 We show how intrinsic definition also facilitates decentralized evolution
 in which software is extended and evolved by multiple independent developers.
 Further, we show how unplanned extensions can be deployed to end users
 with the same facility that plugins extensions are currently added to systems
 with planned extension points.
 The approach is model-driven in that architecture definition is used to
 directly construct both initial implementations and extensions to these
 implementations.
 We have implemented intrinsic evolution definition in Backbone - an architectur
al description language (ADL), which has both a textual and a UML2, based
 graphical representation.
 The paper uses Backbone to illustrate basic concepts through simple examples
 and reports our experience in applying it and its associated tool support
 to a larger example.
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{IEEEkeywords}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Software Architectures, Design Tools and Techniques
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{IEEEkeywords}}
\backslash
author{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Andrew McVeigh, Jeff Kramer and Jeff Magee
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
IEEEcompsocitemizethanks{
\backslash
IEEEcompsocthanksitem{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A.
 McVeigh, J.
 Kramer and J.
 Magee are with Imperial College London.
\end_layout

\begin_layout Standard
E-mail: {a.mcveigh, j.kramer, j.magee}@imperial.ac.uk
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}}
\backslash
thanks{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Manuscript received (insert date of submission if desired).
 Please note that all acknowledgments should be places at the end of the
 paper, before the bibliography.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}}
\end_layout

\end_inset


\end_layout

\begin_layout Title
Intrinsic Definition in
\begin_inset Newline newline
\end_inset

Software Architecture Evolution
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
IEEEPARstart{I}{NITIALLY}
\end_layout

\end_inset

 recognized by Boehm in his spiral model of software development [] and
 more recently in agile development methods [], iterative and incremental
 software development is fundamental to the delivery of complex software
 intensive systems.
 As early as 1976, Belady and Lehman[] recognized that to retain their usefulnes
s, complex software systems are subject to continuous incremental change
 throughout their lifetime.
 In 1991, Lehman[] refined this observation and noted that systems are subject
 to incremental growth due to the need to add functionality to maintain
 user satisfaction.
 In summary, incremental change and extension can be regarded as intrinsic
 to both the initial development and subsequent evolution of complex software
 systems.
\end_layout

\begin_layout Standard
To deal with the increasing complexity of software systems, the Software
 Engineering community has focused on dealing with systems at a level of
 abstraction, known as software architecture [].
 The software architecture of a system deals with multiple views of a system
 including both its functional and non-functional aspects.
 The central view is the structural one in which a system is viewed as a
 set of components that interact via connectors.
 Control of complexity is achieved by hierarchical structure in which a
 component can be composed from subcomponents with the leaf components of
 the hierarchy representing code modules.
 A number of Architectural Description Languages (ADL) have been proposed
 by the research community [], and some of these have found their way into
 commercial practice [].
 While software architecture is seen as an appropriate level for system
 redesign and restructuring to permit change [], the proposed ADLs do not
 deal directly with evolution, considering it to be an extrinsic concern
 dealt with by tools and processes external to those concerned with architecture
 definition.
\end_layout

\begin_layout Standard
In this paper, we explore the alternative in which we regard evolution as
 a concern that is intrinsic to architecture definition such that the structural
 constructs we propose to capture change and extension can be used during
 both initial development and subsequent evolution.
 This intrinsic definition brings with it the requirement to deal with unplanned
 extension, for it is impossible, whichever development process is adopted,
 to foresee all possible future requirements for change and evolution of
 a system.
\end_layout

\begin_layout Standard
Dealing with unplanned extension introduces a difficult dilemma in designing
 constructs to support intrinsic definition.
 We would prefer to have constructs that constrain change in such a way
 that their application always results in structurally well formed and type
 correct systems.
 However, such an approach inevitably means that only a subclass of all
 possible valid change to a system is permitted.
 This is clearly incompatible with dealing with unplanned extension since
 we cannot predict the change that will be necessary.
 As a result, we have chosen constructs that do permit changes that result
 in invalid systems; however, we have ensured that these constructs are
 used in an environment that comprehensively detects structural and type
 errors.
 In other words, we combine the freedom to perform incorrect changes with
 the ability to detect these errors so that we have sufficient expressiveness
 to deal with unplanned changes.
 We permit change to be destructive – deleting elements of an architecture
 – in addition to being constructive – adding elements to an architecture.
\end_layout

\begin_layout Standard
In exploring intrinsic definition, we have considered the requirements of
 distributed design and evolution in which development and extension is
 carried out by different organizations.
 In particular, we are motivated by the following situation which current
 approaches find problematic.
 A development organization produces a software framework product that is
 used by other organizations to build applications.
 In meeting their local development requirements, these organizations may
 need to modify and extend the framework to support their applications.
 The original framework will evolve over time and the organizations that
 use it need to apply their local changes to the framework before using
 the evolved framework for their applications.
 In addition, a third party may wish to use applications from more than
 one extenders of the framework and thus need to merge changes from both
 these organizations and the original framework provider.
 In the sequel, we examine the impact of intrinsic definition on distributed
 evolution of this form.
\end_layout

\begin_layout Standard
If software architecture description is regarded only as design documentation,
 a major problem arises in keeping this documentation in step with the software
 implementation as a system evolves.
 We adopt a model driven engineering approach in that architecture definition
 is not just a documentation artifact but is a precise model used to directly
 construct both initial implementations and extensions to these implementations.
\end_layout

\begin_layout Standard
In the following: Section 2 describes the key concepts for the intrinsic
 definition of evolution in software architecture and explains their use
 by mean of a simple example, Section 3 provides a more rigorous definition
 of the these concepts and shows how they are computed over a dependency
 graph of extensions, Section 4 recounts our experience in using our prototype
 tool Evolve applied to a large case study and evaluates the approach against
 the requirements for distributed evolution, Section 5 discusses related
 work and finally Section 6 presents some conclusions and directions for
 future work that build on the approach.
\end_layout

\begin_layout Section
Defining Change
\end_layout

\begin_layout Standard
We first describe and motivate the key concepts we use to define change
 in software architecture.
 Specifically, these constructs provide the facility to remake a composition
 hierarchy.
 We demonstrate this in a simple example described using our description
 language Backbone in which the constructs have been implemented.
 It has both a graphical form based on UML2 component diagrams and a textual
 form.
 The textual form is simply a printed version of an XML representation used
 to store and exchange Backbone definitions.
\end_layout

\begin_layout Subsection
Key Concepts
\end_layout

\begin_layout Subsubsection*

\series medium
\size normal
Resemblance
\end_layout

\begin_layout Standard
Resemblance defines a new component as the difference in structure from
 one or more existing components.
 It is the delta, consisting of the set of additions, deletions and replacements
 of the elements of these components, that is applied to arrive at the new
 definition.
 For a component, these elements are: parts – instances of subcomponents,
 ports – instances of interfaces, connectors – bindings between ports, and
 attributes – component parameters.
 Resemblance may also be applied to interfaces in which case the modified
 elements are operations.
 If a resemblance delta consists only of additions then when applied to
 an interface, it defines a proper subtype.
 The type inference and checking algorithm we have implemented in our prototype
 tool Evolve takes full cognizance of this.
\end_layout

\begin_layout Standard
Resemblance is a many to one relation to permit the merging of multiple
 component definitions that may have arisen due to, for example, distributed
 development.
 It might be of concern that if a sufficiently radical delta is applied
 to a component then the new definition will bear little or no resemblance,
 in the general sense, to the component definitions from which it is derived.
 However, this is of more philosophical than practical import as the primary
 intent of resemblance to record change or evolution and we can find many
 examples in both engineering and nature where things evolve dramatically
 from their original form.
\end_layout

\begin_layout Subsubsection*

\series medium
Replacement
\end_layout

\begin_layout Standard
Replacement globally substitutes the definition of one component for another
 while preserving the identity of the original definition such that any
 use relations that a larger system has with this definition are preserved.
 When combined with resemblance, replacement permits the incremental evolution
 of a component definition without necessarily having to change the composite
 component definitions that use this component.
\end_layout

\begin_layout Standard
Components and interfaces in the Backbone ADL are given globally unique
 identifiers to permit the correct unambiguous application of replacement.
 Replacement is the key to managing change in composite hierarchical definitions
 since it permits substitution of component definitions at one level of
 the composition hierarchy without necessarily affecting higher layers.
\end_layout

\begin_layout Subsubsection*

\series medium
Stratum
\end_layout

\begin_layout Standard
A stratum is a package or module that holds the definitions relating to
 an initial software architecture expressed as a composite component or
 definitions relating to an evolution of that architecture.
 Each stratum records the strata that it depends on such that to assemble
 a system, the builder uses the current stratum and the transitive closure
 of all strata that this stratum depends on.
 The computation of resemblance in the context of the stratum dependency
 graph is addressed in the next section.
\end_layout

\begin_layout Standard
In addition to extension, the stratum is the unit of sharing and ownership.
 Each stratum is owned by a single party that has modification rights to
 it.
 We can therefore use strata to model the ownership structure of an architecture
 and map this onto a community of base and extension developers.
 Our development tool Evolve and the Backbone runtime environment support
 the import and export of strata for distributing extensions and subsets
 of an architecture.
\end_layout

\begin_layout Standard
A stratum is also a unit of deployment in that its compiled version together
 with associated component code can be sent to an end user to extend their
 system in a similar fashion to Eclipse Plugins.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
It should be noted that although resemblance allows elements to be deleted
 in forming a new definition from existing defintions, this is not destructive
 editing in the usual sense since the existing definition is preserved and
 the deletion simply recorded in a delta.
 Our approach preserves definitions and at no point overwrites old definitions
 with new definitions.
 When replacing a definition from a base stratum with a new definition using
 resemblance in an extension stratum, we do not remove the base definition
 simply record the delta definition in the extension stratum.
 Indeed, if we do not want a component definition to be available for use
 in an extension, we simply replace it with a resemblance delta that sets
 its retirement status to true.
\end_layout

\begin_layout Subsection
Example
\end_layout

\begin_layout Standard
To illustrate the use of these three concepts we use the Singlelane Bridge
 example from [].
 This concurrent system models the access of cars to a single lane bridge.
 Its component architecture can be modeled in Backbone as shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SingleLaneBridge-components"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/slb-components.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:SingleLaneBridge-components"

\end_inset

SingleLaneBridge components
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The textual architecture description that corresponds to this component
 diagram is listed below:
\end_layout

\begin_layout LyX-Code

\series bold
\size small
stratum
\series default
 Single_Lane_Bridge
\end_layout

\begin_layout LyX-Code

\size small
  
\series bold
depends-on
\series default
 backbone
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
interface
\series default
 I_access
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
implementation-class
\series default
 bridge.I_access
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
operations:
\end_layout

\begin_layout LyX-Code

\size small
        enter; leave;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
interface
\series default
 I_move
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
implementation-class
\series default
 bridge.I_move
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
operations:
\end_layout

\begin_layout LyX-Code

\size small
        move;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 Controller
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
implementation-class
\series default
 bridge.Controller
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
ports:
\end_layout

\begin_layout LyX-Code

\size small
        red 
\series bold
provides
\series default
 I_access,
\end_layout

\begin_layout LyX-Code

\size small
        blue 
\series bold
provides
\series default
 I_access;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 Car
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
implementation-class
\series default
 bridge.Car
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
attributes:
\end_layout

\begin_layout LyX-Code

\size small
        carNo: int = 0;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
ports:
\end_layout

\begin_layout LyX-Code

\size small
        move 
\series bold
requires
\series default
 I_move,
\end_layout

\begin_layout LyX-Code

\size small
        bridge 
\series bold
requires
\series default
 I_access;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 Display
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
implementation-class
\series default
 bridge.Display
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
attributes:
\end_layout

\begin_layout LyX-Code

\size small
        maxCar: int = 1;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
ports:
\end_layout

\begin_layout LyX-Code

\size small
        redmove 
\series bold
provides
\series default
 I_move,
\end_layout

\begin_layout LyX-Code

\size small
        bluemove 
\series bold
provides
\series default
 I_move,
\end_layout

\begin_layout LyX-Code

\size small
        run 
\series bold
provides
\series default
 IRun;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 SLB
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
ports:
\end_layout

\begin_layout LyX-Code

\size small
        run 
\series bold
provides
\series default
 IRun;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
parts:
\end_layout

\begin_layout LyX-Code

\size small
        b0: Car,
\end_layout

\begin_layout LyX-Code

\size small
        c: Controller,
\end_layout

\begin_layout LyX-Code

\size small
        r0: Car,
\end_layout

\begin_layout LyX-Code

\size small
        d: Display;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
connectors:
\end_layout

\begin_layout LyX-Code

\size small
        bb 
\series bold
joins
\series default
 blue@c 
\series bold
to
\series default
 bridge@b0,
\end_layout

\begin_layout LyX-Code

\size small
        br 
\series bold
joins
\series default
 bridge@r0 
\series bold
to
\series default
 red@c,
\end_layout

\begin_layout LyX-Code

\size small
        vr 
\series bold
joins
\series default
 move@r0 
\series bold
to
\series default
 redmove@d,
\end_layout

\begin_layout LyX-Code

\size small
        vb 
\series bold
joins
\series default
 move@b0 
\series bold
to
\series default
 bluemove@d,
\end_layout

\begin_layout LyX-Code

\size small
        r 
\series bold
delegates-from
\series default
 run 
\series bold
to
\series default
 run@d;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
This architecture represents a system with one red car and one blue car,
 moving in opposite directions, competing for access to the bridge.
 Access control is implemented by the Controller component, which provides
 two I_access interfaces.
 A Car calls enter to gain access to the bridge and calls leave on exit.
 Cars display their movement using the Display component.
 Note that all of the definitions are contained in the SingleLaneBridge
 stratum that appears in Figure 3.
 Car, Controller and Display are leaf components with an implementaion defined
 by Java classes.
 SLB is a composite component that contains parts made from these components
 interconnected by connectors to form the system.
\end_layout

\begin_layout Subsubsection*

\series medium
Using Resemblance
\end_layout

\begin_layout Standard
Now suppose that another developer wishes to evolve this system to accommodate
 multiple red and blue cars moving in opposite directions.
 This developer creates the stratum with the components shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MultiCarBridge-components"

\end_inset

.
 The developer defines three new components: CarFactory dynamically creates
 a Car component when it receives an invocation on its creator port, CarCreator
 is a leaf component that calls its create port maxCar times, and finally,
 the composite component MultiCar creates nCars Car components.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/mlb-components.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:MultiCarBridge-components"

\end_inset

MultiCarBridge components
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Figure 2 – MultiCarBridge components
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The MULTSLB composite component is defined as a resemblance of the SLB component
 from the SingleLaneBridge stratum.
 Graphically, resemblance is depicted as a solid arrow pointing to an icon
 representing the component from which the resemblance is derived.
 Although graphically MULTSLB is depicted with all its component parts and
 connectors, in fact as shown in the Backbone listing below, it is defined
 by a delta that simply adds the nCar attribute and replaces the parts of
 type Car with parts of type MultiCar.
 In addition, it replaces the instance of Display with an instance of the
 same component type but with a different attribute value.
 The new definition is formed graphically by editing the previous definition
 that the Evolve tool displays when the resemblance relation is established.
\end_layout

\begin_layout LyX-Code

\series bold
\size small
stratum
\series default
 Multi_Car_Bridge
\end_layout

\begin_layout LyX-Code

\size small
  
\series bold
depends-on
\series default
 Single_Lane_Bridge
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 CarFactory is-factory
\end_layout

\begin_layout LyX-Code

\size small
       
\series bold
resembles
\series default
 FactoryBase
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
attributes:
\end_layout

\begin_layout LyX-Code

\size small
          carId: int;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
ports:
\end_layout

\begin_layout LyX-Code

\size small
          bridge,
\end_layout

\begin_layout LyX-Code

\size small
          move;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
parts:
\end_layout

\begin_layout LyX-Code

\size small
          c: Single_Lane_Bridge::Car
\end_layout

\begin_layout LyX-Code

\size small
               
\series bold
slots:
\end_layout

\begin_layout LyX-Code

\size small
                 carNo = carId;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
connectors:
\end_layout

\begin_layout LyX-Code

\size small
          b 
\series bold
delegates-from
\series default
 move 
\series bold
to
\series default
 move@c,
\end_layout

\begin_layout LyX-Code

\size small
          m 
\series bold
delegates-from
\series default
 bridge 
\series bold
to
\series default
 bridge@c;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 CarCreator
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
implementation-class
\series default
 bridge.CarCreator
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
attributes:
\end_layout

\begin_layout LyX-Code

\size small
        maxCar: int;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
ports:
\end_layout

\begin_layout LyX-Code

\size small
        create requires ICreate;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 MultiCar
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
attributes:
\end_layout

\begin_layout LyX-Code

\size small
        nCars: int;
\end_layout

\begin_layout LyX-Code

\size small
     
\series bold
 ports:
\end_layout

\begin_layout LyX-Code

\size small
        bridge,
\end_layout

\begin_layout LyX-Code

\size small
        move;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
parts:
\end_layout

\begin_layout LyX-Code

\size small
        cc: CarCreator
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
slots:
\end_layout

\begin_layout LyX-Code

\size small
            maxCar = nCars,
\end_layout

\begin_layout LyX-Code

\size small
        cf: CarFactory
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
slots:
\end_layout

\begin_layout LyX-Code

\size small
            carId = 0;
\end_layout

\begin_layout LyX-Code

\size small
     
\series bold
 connectors:
\end_layout

\begin_layout LyX-Code

\size small
        c 
\series bold
joins
\series default
 create@cc 
\series bold
to
\series default
 creator@cf,
\end_layout

\begin_layout LyX-Code

\size small
        b 
\series bold
delegates-from
\series default
 bridge 
\series bold
to
\series default
 bridge@cf,
\end_layout

\begin_layout LyX-Code

\size small
        m 
\series bold
delegates-from
\series default
 move 
\series bold
to
\series default
 move@cf;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
    
\series bold
component
\series default
 MULTISLB
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
resembles
\series default
 Single_Lane_Bridge::SLB
\end_layout

\begin_layout LyX-Code

\size small
    {
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
attributes:
\end_layout

\begin_layout LyX-Code

\size small
        nCar: int = 4;
\end_layout

\begin_layout LyX-Code

\size small
      
\series bold
replace-parts:
\end_layout

\begin_layout LyX-Code

\size small
        r0 
\series bold
becomes
\series default
 red: MultiCar
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
slots:
\end_layout

\begin_layout LyX-Code

\size small
            nCars = nCar
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
port-remaps:
\end_layout

\begin_layout LyX-Code

\size small
            move 
\series bold
maps-onto
\series default
 xxx
\end_layout

\begin_layout LyX-Code

\size small
            bridge 
\series bold
maps-onto
\series default
 xxx,
\end_layout

\begin_layout LyX-Code

\size small
        b0 
\series bold
becomes
\series default
 blue: MultiCar
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
slots:
\end_layout

\begin_layout LyX-Code

\size small
            nCars = nCar
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
port-remaps:
\end_layout

\begin_layout LyX-Code

\size small
            move 
\series bold
maps-onto
\series default
 xxx
\end_layout

\begin_layout LyX-Code

\size small
            bridge 
\series bold
maps-onto
\series default
 xxx,
\end_layout

\begin_layout LyX-Code

\size small
        d 
\series bold
becomes
\series default
 d: Single_Lane_Bridge::Display
\end_layout

\begin_layout LyX-Code

\size small
          
\series bold
slots:
\end_layout

\begin_layout LyX-Code

\size small
            maxCar = nCar;
\end_layout

\begin_layout LyX-Code

\size small
    }
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
To produce this extension permitting multiple cars, some new program source
 code must be written to implement the CarCreator component, however, there
 is no requirement to access or modify any of the source code relating to
 the base SingleLaneBridge stratum.
 Access to the architecture description is sufficient to permit extension.
 Note that resemblance is also used to define CarFactory, which extends
 FactoryBase provided by the underlying backbone stratum.
 The stratum dependency graph for the extension is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MultiCarBridge-strata-dependency"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/multicar-stratum.eps
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:MultiCarBridge-strata-dependency"

\end_inset

MultiCarBridge strata dependency graph
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Using Replacement
\end_layout

\begin_layout Standard
The single lane bridge Controller component works well until the number
 of cars increases to the point that a stream of cars, either red of blue,
 continuously occupies the bridge denying access to cars moving in the other
 direction.
 In other words, the Controller component is safe but not fair.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:FairBridge-replacement-controlle"

\end_inset

 shows how a revised Controller that does implement fairness is introduced.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/fair-controller.eps
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:FairBridge-replacement-controlle"

\end_inset

FairBridge replacement controller
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The listing below shows the Backbone textual represenation of the evolved
 controller.
\end_layout

\begin_layout Standard

\size small
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code

\series bold
\size small
stratum
\series default
 Fair_Bridge
\end_layout

\begin_layout LyX-Code

\size small
 
\series bold
depends-on
\series default
 Single_Lane_Bridge
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
 
\series bold
component 
\series default
Controller
\end_layout

\begin_layout LyX-Code

\size small
  
\series bold
implementation-class
\end_layout

\begin_layout LyX-Code

\size small
    bridge.FairController
\end_layout

\begin_layout LyX-Code

\size small
  
\series bold
resembles
\end_layout

\begin_layout LyX-Code

\size small
    Single_Lane_Bridge::Controller
\end_layout

\begin_layout LyX-Code

\size small
 
\series bold
 replaces
\end_layout

\begin_layout LyX-Code

\size small
    Single_Lane_Bridge::Controller
\end_layout

\begin_layout LyX-Code

\size small
  {
\end_layout

\begin_layout LyX-Code

\size small
  }
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Replacement is so often combined with resemblance that we use a single graphical
 symbol (combined solid and fishbone arrow) to indicate this combination
 as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:FairBridge-replacement-controlle"

\end_inset

.
 The diagram and text show that we are replacing Controller with a component
 that resembles it exactly with the exception of the implementation class
 that we have changed.
 We can now combine this fair bridge controller with the MultiCarBridge
 stratum as shown in Figure 5.
 The stratum FairMultiCarBridge represents a system that permits multiple
 cars and has a fair controller.
 The stratum contains no definitions of components or deltas; it simply
 indicates its dependences as shown in the Backbone text below Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:FairMultiLaneBridge-strata-depen"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/all-strata.eps
	width 87col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:FairMultiLaneBridge-strata-depen"

\end_inset

FairMultiLaneBridge strata dependency graph
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
\size small
stratum
\series default
 Fair_Multi_Lane_Bridge
\end_layout

\begin_layout LyX-Code

\size small
  
\series bold
depends-on 
\series default
Multi_Car_Bridge, Fair_Bridge
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:FairMultiLaneBridge-strata-depen"

\end_inset

 illustrates how strata are merged.
 This can of course lead to conflicts in definitions, which we discuss in
 the next section.
 In the case of the example, a more plausible scenario would be for the
 original base developer, or a third party, to export this new stratum to
 the multi-car developer who could import it as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Alternative-dependency-graph"

\end_inset

.
 If we were to write out the Backbone text again, it would now show a dependency
 on FairBridge rather than SingleLaneBridge for MultiCarBridge.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/alternative-graph.eps
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Alternative-dependency-graph"

\end_inset

Alternative dependency graph
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "backbone-formal.lyx"

\end_inset


\end_layout

\begin_layout Section
Intrinsic Definition in Practice
\end_layout

\begin_layout Standard
Proposers of a new approach to software architecture description have the
 responsibility to demonstrate that it can be put into industrial practice.
 In this section, we discuss three significant barriers to doing so and
 outline how they are addressed.
 They are: tool support, compatibility with existing libraries and toolkits,
 and application to existing legacy software.
\end_layout

\begin_layout Subsection
Tool Support
\end_layout

\begin_layout Standard
The Backbone ADL is supported by a graphical modeling tool Evolve, and a
 runtime environment which instantiates and interconnects components from
 a Backbone description.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-DeltaEngine-is"

\end_inset

 is an overview of the elements that make up the modeling tool and runtime
 environment.
 The DeltaEngine layer implements the algorithm described in the previous
 section and is used in both the modeling tool to build graphical representation
s of composite components from delta definitions and also in the runtime
 environment to instantiate components from these same definitions.
 In addition to this interpreted runtime the modeling tool can optionally
 compile a “flat” description of the model as a builder class.
 In this case, no runtime environment is required.
 It should be noted that even the interpreted runtime environment incurs
 no overhead during execution of a system; it is only active at startup
 time when it directs instantiation and interconnection.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename drawings/stack.svg
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-DeltaEngine-is"

\end_inset

Common layers between environments
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The DeltaEngine and Structural Rules Layers
\end_layout

\begin_layout Standard
The DeltaEngine layer is a library which implements the extended resemblance
 algorithm described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:A-Formal-Description"

\end_inset

 allowing deltas to be applied in the correct order to form a fully realised
 form of each component.
 Once the deltas are applied, the Structural rules layer can be applied
 to determine if the system is structurally well-formed using 100+ rules
 [phd].
 Any errors are catalogued against the element responsible.
\end_layout

\begin_layout Subsubsection
Evolve Graphical Modeling Environment
\end_layout

\begin_layout Standard
Evolve uses standard UML2 component diagrams.
 We do however apply both restrictions and extensions to this notation in
 order to better match up to our component model.
 We implement the restrictions as rules and the extensions as stereotypes
 as per the UML2 philosophy.
 As an example consider that UML2 allows part multiplicity.
 Evolve does not allow this feature, instead requiring the use of factory
 components for multiple instantiation: this requires restriction preventing
 the use of multiplicity and the extension to allow factory components to
 be denoted by a stereotype.
 In total, however, the number of mismatches between the two component models
 is quite small reflecting the historical lineage of both Backbone and the
 UML2 component model in the models that have preceded them [acme, objectime,
 darwin].
\end_layout

\begin_layout Standard
It has been noted that a design tool must support both top-down and bottom-up
 approaches in order to match up with the creative design processes involved
 [].
 Evolve naturally supports bottom-up composition by virtue of the compositional
 model chosen.
 To better support top-down design we incorporate placeholder components
 [] which are components which are not yet fully elaborated, allowing the
 designer to terminate top-down decomposition at an arbitrary point rather
 than just at leaf components.
 Placeholders may have all the features of a normal component, but may not
 be instantiated directly.
 Any component can be marked as a placeholder.
\end_layout

\begin_layout Standard
Because resemblance and replacement can be used to substitute placeholder
 components and parts, placeholders can participate fully in the design
 process.
 For instance it is common in Evolve to have a placeholder at the base of
 a resemblance hierarchy, effectively acting as a template for the more
 refined components that derive from it.
\end_layout

\begin_layout Standard
Although Backbone requires that components are described in terms of deltas,
 Evolve always shows the full structure even as it records deltas for any
 changes.
 As shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Evolve-showing-deltas"

\end_inset

 Evolve can overlay the deltas graphically on the expanded structures.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide true
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename drawings/deltas.png
	width 80page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Evolve-showing-deltas"

\end_inset

Evolve showing deltas
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Runtime
\end_layout

\begin_layout Standard
The runtime inteprets the Backbone textual form emitted from Evolve - it
 is effectively an interpreter for the structural domain specific language
 [] at the heart of the system.
 It shares the DeltaEngine and rules layers with Evolve, guaranteeing consistenc
y between the two environments.
 Instead of using the engine to display graphical forms, the runtime uses
 the engine to apply the deltas to form fully realised components, which
 have links back to the actual implementation class via the implementation-class
 annotations.
 It then flattens the hierarchy and uses reflection to instantiate and connect
 up the instances in conformance to the architecture.
 At that point control can be handed off to the leaf component presenting
 the IRun interface which represents the starting point of the program.
\end_layout

\begin_layout Standard
Alternatively Evolve can emit code for a builder class representing the
 flattened structure of the system - this requires no runtime and has all
 facilities available including factory instantiation.
 This mode is particularly useful in supported but constrained environments
 such as GWT [ref] which do not have the facilities to support a full runtime
 model.
\end_layout

\begin_layout Standard
Although nothing prevents support for other languages, currently the runtime
 is targeted to the Java language and the Java virtual machine.
 Java reflection is used extensively in the implementation of the runtime,
 but as noted previously this only adds overhead in the direct construction
 of component instances.
 If a builder class is emitted instead of using the runtime, then there
 is no overhead compared to a conventional Java program.
\end_layout

\begin_layout Subsection
Compatibility with Existing Libraries
\end_layout

\begin_layout Standard
Java has a lightweight component model called JavaBeans [] which uses a
 set of lexical conventions to allow setting and getting of properties on
 classes.
 Evolve allows bean libraries to be imported and translated into full Backbone
 leaf components by considering any implemented interfaces of a bean to
 be provided interfaces on a port called 
\family typewriter
main
\family default
, and any settable properties that are interfaces to be required interfaces.
 In this way existing Java libraries are fully compatible with the Evolve
 approach, and can be connected up into composite components.
 This is in contrast with the conventional JavaBeans wiring approach which
 is oriented explicitly around events and hence required interfaces only.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Imported-Swing-components"

\end_inset

 shows a number of well-known Swing [] components that have been imported
 into Evolve for use in an application.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/swing.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Imported-Swing-components"

\end_inset

Imported Swing components
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Applicability to Mature and Legacy Systems
\end_layout

\begin_layout Standard
To evaluate the applicability of the approach to existing software, we chose
 to introduce our component model into the LTSA system [] which was created
 by two of the authors previously for analysing the properties of concurrent
 programs.
 Our intention was to model the evolution of this mature system.
\end_layout

\begin_layout Standard
The original codebase is around 16k physical lines of code from over 200
 classes.
 It consists of a graphical front end along with an automata-based engine
 which can analyze the properties of finite state process expressions using
 model checking [].
\end_layout

\begin_layout Standard
LTSA has evolved into several variants over years, reflecting its relatively
 wide use in academia and industry and the somewhat decentralized nature
 of its development.
 We chose to concentrate on the original system, the AMES evolution, and
 a separate evolution created for the exercise called DualWindow.
 Furthermore, we wished to model the merged AMES and DualWindow systems.
\end_layout

\begin_layout Subsubsection
An Initial View of the Architecture
\end_layout

\begin_layout Standard
We performed a first pass at forming a shallow and coarse-grained compositional
 structure for the original LTSA application, reflecting that it is generally
 not feasible to restructure an entire application in one step.
 The intention was to demonstrate that the approach can be applied with
 relatively small effort initially, with benefits accruing as the system
 is incrementally decomposed further into smaller components over time.
\end_layout

\begin_layout Standard
We started by spending some time understanding the architecture - for this
 we used an author who was not familiar with the existing code.
 After this a strata graph was formed and handful of top-level candidate
 classes were identified for turning into components.
 The best con
\end_layout

\begin_layout Standard
We refactored these classes into JavaBeans and imported them into Evolve.
 Finally, a top-level composite called LTSA was created which wired these
 together allowing the system to run in the Evolve environment.
 The compositional hierarchy at that point is shown in figure X.
 This work took two person-days of effort in total.
\end_layout

\begin_layout Standard
[figure]
\end_layout

\begin_layout Standard
The strata graph for the system is shown in figure X.
\end_layout

\begin_layout Standard
[figure]
\end_layout

\begin_layout Standard
The top-level LTSA component is shown in figure X.
\end_layout

\begin_layout Standard
[figure]
\end_layout

\begin_layout Standard
As the architecture was now visible as components, further decomposition
 was straight forward.
 After spending another day of modest refactoring the refined compositional
 hierarchy in figure X was produced.
 At this point many of the features of the graphical interface were exposed
 as components.
\end_layout

\begin_layout Standard
Note that the original decomposition remains a subset of this refinement.
\end_layout

\begin_layout Standard
[figure]
\end_layout

\begin_layout Subsubsection
Modeling and Merging Evolutions
\end_layout

\begin_layout Standard
The intention of this extension was to allow both the alphabet window and
 the transitions window to be present on the screen simultaneously, thereby
 improving the usability of the tool.
 To do this we created the DualWindow stratum with the DualWindowcomposite
 which provides the same interface IWindow as the original screen but combines
 the two screens.
 We further created a factory component to allow this to be instantiated
 in figure X.
\end_layout

\begin_layout Standard
[figure]Evolution
\end_layout

\begin_layout Standard
Inside the DualWindow stratum, we then evolved the LTSA top-level component
 and replaced the AlphabetWindowFactory part with a DualWindowFactory one.
 We also replaced the HPWindow part with an instance of the same type but
 with amended properties.
\end_layout

\begin_layout Subsubsection
Conclusion
\end_layout

\begin_layout Section
Properties and Analysis
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Subsection
Architecturally Aware Version Control Systems
\end_layout

\begin_layout Subsection
Extensibility Architectures
\end_layout

\begin_layout Subsection
Distributed Version Control Systems
\end_layout

\begin_layout Section
Conclusions
\end_layout

\end_body
\end_document
