#LyX 1.5.1 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{latex8}
\usepackage{times}
%\documentclass[times,9pt,twocolumn]{article}


% \bibliographystyle{latex8}

\date{}

%\usepackage{type1cm}
%\renewcommand\normalsize{%
%   \@setfontsize\normalsize{9pt}{12pt}
%   \abovedisplayskip 10\p@ \@plus2\p@ %\@minus5\p@
%   \abovedisplayshortskip \z@ \@plus3\p@
%   \belowdisplayshortskip 6\p@ \@plus3\p@ %\@minus3\p@
%   \belowdisplayskip \abovedisplayskip
%   \let\@listi\@listI}
%\normalsize  

\sloppy

  \let\oldthebibliography=\thebibliography
 \let\endoldthebibliography=\endthebibliography
  \renewenvironment{thebibliography}[1]{%
    \begin{oldthebibliography}{#1}%
      \setlength{\parskip}{0ex}%
      \setlength{\itemsep}{0ex}%
  }%
  {%
    \end{oldthebibliography}%
  }

\geometry{a4paper,tmargin=26mm,bmargin=40.9mm,lmargin=15.5mm, rmargin=15.5mm}
\end_preamble
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 8mm
\topmargin 28.3mm
\bottommargin 43.3mm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Extensible Systems: Plugin versus Component Substitution Architectures
\end_layout

\begin_layout Author
Andrew McVeigh, Jeff Kramer and Jeff Magee
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
vspace{4pt}
\end_layout

\end_inset


\newline
Department of Computing
\newline
Imperial College
\newline
London SW7 2BZ, United Kingdom
\newline
{amcveigh,
 jk, jnm}@doc.ic.ac.uk
\end_layout

\begin_layout Abstract

\shape italic
Many extensible systems are delivered in the form of a base application
 with a plugin architecture.
 Plugins can be added to the application to extend its functionality, allowing
 it to be tailored for different needs.
\end_layout

\begin_layout Abstract

\shape italic
We introduce component substitution architectures as an alternative to this
 style, providing a more flexible and granular extension model.
 This approach is also shown to cope well with unplanned extension.
 We demonstrate how substitution, combined with a structural form of component
 inheritance called resemblance, can be used to effectively model and extend
 a system.
\end_layout

\begin_layout Abstract

\shape italic
To evaluate both styles, we examine part of the architecture of the Eclipse
 development tool and indicate how each approach would handle the same extension
 requirement.
 Component substitution is shown to more naturally model the situation,
 with the further advantage that the cost of introducing the extension is
 closely aligned to the size of the change required to the architecture.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
One way to structure an extensible system is to provide a base application
 with predefined extension points where the application can be extended.
 Developers create plugins, which 
\begin_inset Quotes eld
\end_inset

plug into
\begin_inset Quotes erd
\end_inset

 the extension points, and these plugins can then be selectively added to
 an installation of the application to customize it.
 The base application acts as a platform, providing a substrate for a family
 of applications.
\end_layout

\begin_layout Standard
This approach is referred to as a plugin architecture and the basic concepts
 can be succinctly described using a simple design pattern 
\begin_inset LatexCommand cite
key "Mayer2003"

\end_inset

.
 Advanced plugin architectures, such as Eclipse 
\begin_inset LatexCommand cite
key "Object2001"

\end_inset

, allow plugins to offer extension points also, which can then be further
 extended by other plugins.
 The model in 
\begin_inset LatexCommand cite
key "Chatley2003"

\end_inset

 also supports this feature, but calls extension points 
\begin_inset Quotes eld
\end_inset

holes
\begin_inset Quotes erd
\end_inset

 and the elements that extend them 
\begin_inset Quotes eld
\end_inset

pegs
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
One of the benefits of this architectural style is that plugins can be created
 by developers who are not affiliated with the developers of the original
 application.
 The original developers are then free to concentrate on the base platform
 without having to continually expand the system to cater for every requirement.
\end_layout

\begin_layout Standard
Examples of successful applications using this approach are the Eclipse
 Integrated Development Environment (IDE) 
\begin_inset LatexCommand cite
key "Object2001a"

\end_inset

 and Firefox 
\begin_inset LatexCommand cite
key "Firefoxplugins2008"

\end_inset

.
 The COM 
\begin_inset LatexCommand cite
key "Microsoft2006"

\end_inset

 add-in model of the Microsoft Office suite could also be regarded as another
 example of this style.
\end_layout

\begin_layout Standard
The ability to add plugins to a system primarily facilitates additive change
 to a system, according to the extension points defined already in the base.
 Extending and customizing a system can involve more than just addition,
 however.
 We use the term 
\emph on
extension
\emph default
 to refer to a unit (analogous to a plugin) that can add, replace or delete
 functionality.
 The plugin concept is a therefore a subset of the extension concept.
\end_layout

\begin_layout Standard
The component substitution model is offered as an alternative to the plugin
 approach.
 The foundation of this approach is to allow an extension to substitute
 any other application component with one of its own.
 Combined with resemblance, which allows a component to structurally inherit
 from others, an extension can incrementally modify any part of a system
 providing great flexibility to reshape the architecture to meet new requirement
s.
\end_layout

\begin_layout Standard
Backbone is an architecture description language (ADL) developed as part
 of this work to demonstrate the component substitution concepts.
 This features a hierarchical component model at its core along with extensibili
ty constructs to complement this.
 The aim is to make extension as natural an engineering process as initial
 creation, and to cope with unplanned change by allowing any part of a system
 to effectively become an extension point.
 This lifts the burden off developers to factor in predictive extension
 points.
\end_layout

\begin_layout Standard
To evaluate the two approaches, we consider an extension to the Eclipse
 IDE.
 This is modeled with the Eclipse plugin approach, and also in Backbone
 allowing direct comparison of the two styles.
\end_layout

\begin_layout Standard
The rest of the paper is structured as follows.
 Section 
\begin_inset LatexCommand ref
reference "sec:Extending-a-Plug-In"

\end_inset

 examines the characteristics of plugin architectures, focusing specifically
 on the Eclipse model.
 Section 
\begin_inset LatexCommand ref
reference "sec:Backbone-and-Component"

\end_inset

 introduces the component substitution approach and the Backbone ADL.
 Section 
\begin_inset LatexCommand ref
reference "sec:A-Formal-Model"

\end_inset

 presents the outline of a formal model for Backbone, summarizing various
 properties that result.
 Related work is reviewed in section 
\begin_inset LatexCommand ref
reference "sec:Related-Work"

\end_inset

 and section 
\begin_inset LatexCommand ref
reference "sec:Conclusions-and-Future"

\end_inset

 presents conclusions and discusses further work.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Extending-a-Plug-In"

\end_inset

Plugin Architectures
\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "fig:A-UML-class"

\end_inset

 expands on the basic plugin design pattern of 
\begin_inset LatexCommand cite
key "Mayer2003"

\end_inset

 to present a UML class diagram of a more general model.
 This describes the Eclipse approach where plugins can also have extension
 points.
 The distinction between plugins and the base application is therefore blurred,
 as the base is a relative concept which can be thought of as a system loader
 and a given collection of plugins.
 This is certainly the case in Eclipse, where even the fundamental run-time
 and editing concepts reside in plugins.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename images/plug-in-model.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:A-UML-class"

\end_inset

The plugin model
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
SystemLoader is the class which bootstraps the initial system, discovers
 any Plugins and registers them with the PluginRegistry.
 The registry knows about all Plugins, and can be used to query for a specific
 Plugin via the 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

version
\begin_inset Quotes erd
\end_inset

 attributes.
\end_layout

\begin_layout Standard
A Plugin is a versioned collection of packages, classes and interfaces.
 A Plugin may depend on other Plugins, for both extension points and library
 classes.
 The VersionBundle association class shows that this dependency can be expressed
 as a reference to a specific Plugin version, a bounded set of versions,
 or no particular version (
\begin_inset Quotes eld
\end_inset

don'tCare
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
A Plugin may provide a set of PluginExtensions
\begin_inset Foot
status collapsed

\begin_layout Standard
In Eclipse, the actual terminology for a PluginExtension is 
\begin_inset Quotes eld
\end_inset

extension
\begin_inset Quotes erd
\end_inset

.
 We have used PluginExtension to differentiate this concept from our notion
 of an extension as being analogous to a plugin that can add, remove and
 replace functionality.
\end_layout

\end_inset

 which 
\begin_inset Quotes eld
\end_inset

plug into
\begin_inset Quotes erd
\end_inset

 the ExtensionPoints of other Plugins.
 A PluginExtension uniquely identifies the relevant ExtensionPoint by its
 identifier (
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

).
 A Plugin may further define its own set of ExtensionPoints, each of which
 declares which parameters must be supplied (conforming to 
\begin_inset Quotes eld
\end_inset

schema
\begin_inset Quotes erd
\end_inset

) by a PluginExtension.
 The model allows an ExtensionPoint to accept multiple PluginExtensions,
 although each PluginExtension can only plug into one ExtensionPoint.
 The motivation is that if an ExtensionPoint could only accommodate a single
 PluginExtension, then multiple Plugins could all try to fill the point,
 and conflict structurally.
\end_layout

\begin_layout Standard
At run-time, the Plugins are discovered and registered, and the PluginExtensions
 matched up to ExtensionPoints.
 Control is then passed to a distinguished Plugin for bootstrapping.
 Each Plugin is able to query the PluginExtensions which extend its points,
 and the parameters passed can include class names (for object instantiation)
 and values.
\end_layout

\begin_layout Standard
The extensibility of the approach comes from Plugins not knowing (or needing
 to know) what PluginExtensions will be provided for their extension points
 until run-time.
 The actual PluginExtensions for a Plugin's extension points is a function
 of how many extending Plugins are discovered in the environment.
\end_layout

\begin_layout Standard
An ExtensionPoint is equivalent to a number of optionally required interfaces
 (to handle the multiplicity), and a PluginExtension is equivalent to a
 provided interface.
 Rather than model these concepts directly using interfaces, however, the
 Eclipse model expresses the data required and provided via metadata (XML
 files).
 Some of this data can refer directly to class names, and a Plugin can choose
 to instantiate an object based on a class name passed to its extension
 point.
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:Extending-Eclipse:-Adding"

\end_inset

Extending Eclipse: Adding a Column to the Task View
\end_layout

\begin_layout Standard
As a case study, we chose to enhance a small aspect of the Eclipse (version
 3.3) task view.
 As shown in figure 
\begin_inset LatexCommand ref
reference "fig:The-task-view"

\end_inset

, this shows a list of tasks along with certain columns.
 We wish to
\emph on
 add
\emph default
 a further column 
\begin_inset Quotes eld
\end_inset

assigned to
\begin_inset Quotes erd
\end_inset

 in order to show which person has been allocated the task.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename original-images/tasks.jpg
	lyxscale 60
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:The-task-view"

\end_inset

The Eclipse task view
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first step in making the addition is to find the plugin responsible
 for viewing tasks.
 This proved to be straight forward: a class called TaskView exists in the
\emph on
 org.eclipse.ui.ide
\emph default
 plugin.
 However, there is a problem.
 Looking at the source code for this class shows that the set of columns
 is hard-coded.
\end_layout

\begin_layout LyX-Code

\size scriptsize
public class TaskView extends MarkerView {
\end_layout

\begin_layout LyX-Code

\size scriptsize
    ...
\end_layout

\begin_layout LyX-Code

\size scriptsize
    private final IField[] VISIBLE_FIELDS =
\end_layout

\begin_layout LyX-Code

\size scriptsize
       { new FieldDone(), new FieldPriority(),
\end_layout

\begin_layout LyX-Code

\size scriptsize
         new FieldMessage(), new FieldResource(),
\end_layout

\begin_layout LyX-Code

\size scriptsize
         new FieldFolder(), new FieldLineNumber() };
\end_layout

\begin_layout LyX-Code

\size scriptsize
    ...
\end_layout

\begin_layout Standard
The developers clearly did not anticipate this scenario.
 We must look for an alternative approach to using an extension point.
\end_layout

\begin_layout Standard
In an ideal world, it would be possible to simply create a new plugin, with
 a new EnhancedTaskView class and substitute this class for the existing
 TaskView class.
 This is the intent of the substitution facilities in component substitution
 architectures.
 However, since the plugin model primarily facilitates addition, this type
 of effect is not possible through the adding of a new plugin.
\end_layout

\begin_layout Standard
Examining the metadata (plugin.xml file) for this plugin shows how the task
 view is instantiated.
 The PluginExtension declaration references the TaskView class and plugs
 into the appropriate extension point, as shown below.
 (Note that the following is a declaration of a PluginExtension, rather
 than an extension point, which has a tag of extension-point)
\end_layout

\begin_layout LyX-Code

\size scriptsize
<extension point="org.eclipse.ui.preferencePages">
\end_layout

\begin_layout LyX-Code

\size scriptsize
  <view name="%Views.Task"
\end_layout

\begin_layout LyX-Code

\size scriptsize
    icon="$nl$/icons/full/eview16/tasks_tsk.gif"
\end_layout

\begin_layout LyX-Code

\size scriptsize
    category="org.eclipse.ui"
\end_layout

\begin_layout LyX-Code

\size scriptsize
    class=
\end_layout

\begin_layout LyX-Code

\size scriptsize
     "org.eclipse.ui.views.markers.internal.TaskView"
\end_layout

\begin_layout LyX-Code

\size scriptsize
    id="org.eclipse.ui.views.TaskList">
\end_layout

\begin_layout LyX-Code

\size scriptsize
  </view>
\end_layout

\begin_layout LyX-Code

\size scriptsize
</extension>
\end_layout

\begin_layout Standard
If we could change this file we could substitute our EnhancedTaskView class
 as the parameter and our new view would be used instead of the previous
 one.
 However, the plugin.xml file lives in the org.eclipse.ui.ide plugin itself,
 and to replace the lines, we must create a new version of the plugin.
\end_layout

\begin_layout Standard
Creating a new version is not a perfect solution, however, due to other
 characteristics of the model.
 Firstly, the plugin consists of around 300 Java classes.
 The effort required in forking this plugin to create a new version is heavily
 out of proportion to the small architectural addition required.
\end_layout

\begin_layout Standard
Introducing a new version will also cause a problem if any plugins explicitly
 declare a dependency on the old version.
 We will end up in that case with two referenced versions of the plugin
 (old and new), and concurrent versions of the same plugin are not allowed
 in Eclipse for anything that contributes to extension points.
 Even if this were allowed, having two concurrent versions of a plugin holding
 shared state would not be a desirable outcome.
\end_layout

\begin_layout Standard
To prevent the situation where two different versions of the same plugin
 are required, Eclipse plugin versions follow a convention.
 All dependencies on plugins are expressed as a bounded version range from
 3.0.0 up to (but not including) 4.0.0.
 The leftmost digit of the versioning scheme indicates API-breaking changes.
 Without this approach, we would not be able to easily introduce even a
 minor, non-breaking change as explicit dependencies on the old plugin version
 would mean having both old and new present.
\end_layout

\begin_layout Standard
It is also not possible to introduce a breaking change without also creating
 a new version of all plugins (incrementing the leftmost digit) which depend
 on this plugin, and so on in cascade fashion.
 This certainly constrains the type of change we can introduce, even if
 we are willing to update any upstream artifacts which have issues with
 the change.
 We will end up having to update most of the plugins in the system.
\end_layout

\begin_layout Standard
Even creating a new non-breaking version is likely to be a short term solution.
 It is known that Eclipse 3.4 is introducing a new version of this plugin,
 with an enhanced task view that colors tasks according to priority.
 As it is not possible to run two versions concurrently, we will have to
 accept the fact that we must merge our source changes into each new release
 of the plugin.
 Regardless of how important we view our change, it is unlikely that the
 maintainer (the Eclipse Foundation) will incorporate our (and everyone
 else's) changes into the plugin that they own and maintain.
 Our version will be superseded by any new ones from the maintainer, and
 our changes will be replaced.
\end_layout

\begin_layout Subsection
Coarse-Grained Plugins
\end_layout

\begin_layout Standard
A key problem in the above scenario is the coarseness of plugins.
 If the plugins could somehow be made more fine-grained then the problem
 would be easier to solve, as we would be creating a new version of a smaller
 artifact.
\end_layout

\begin_layout Standard
A tension exists, however, between making the architecture fine-grained
 and making it manageable and understandable.
 If we make plugins too small, we will end up with literally many thousands.
 As shown by figure 
\begin_inset LatexCommand ref
reference "fig:Part-of-the"

\end_inset

, the plugin structure for Eclipse is already complex.
 The figure shows around 80 plugins: a typical environment contains around
 200, and an enterprise product based on Eclipse is known to contain over
 500 
\begin_inset LatexCommand cite
key "Gamma2003"

\end_inset

.
 Having more plugins implies a less manageable system.
 Some form of nesting or composition would address this, providing a way
 to view the system at multiple levels of abstraction
\begin_inset Foot
status collapsed

\begin_layout Standard
Eclipse plugins have names conforming to Java-like conventions.
 However, like Java packages, the name is just a convention and does not
 indicate any precise nesting.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename original-images/tangle.jpg
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Part-of-the"

\end_inset

A partial plugin dependency graph
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:Characteristics-of-the"

\end_inset

Characteristics of the Plug-In Model
\end_layout

\begin_layout Standard
The plugin model is essentially additive, as it allows a plugin to add to
 existing extension points.
 Any extension beyond addition requires that a new version of an existing
 plugin be created.
 As shown, even minor changes can lead to this situation.
\end_layout

\begin_layout Standard
Our small extension required a new version of a plugin.
 This presented several problems.
 Firstly, the plugin is a sizable artifact due to the lack of composition,
 and creating a new version is a change that is out of proportion to the
 size of the architectural change (addition) required.
 Next, introducing a new version can lead to a situation where multiple
 concurrent versions of a plugin are implied, which is prohibited according
 to the rules of the platform.
 Finally, creating a new version leads to its own problems in that we are
 not the main developers of this plugin and will therefore have to acquiesce
 to performing a source level merge of our changes whenever a new version
 is published by the Eclipse Foundation.
\end_layout

\begin_layout Standard
As it turns out, our small change was not planned for -- the creators of
 the plugin did not anticipate or cater for this type of change via addition.
 This is an interesting characteristic in that unplanned changes, even those
 notionally adding a feature, must be characterized as replacement.
 If the requirement had been foreseen, an extension point could have been
 provided to allow the registration of extra columns for the task view.
 Clearly, however, anticipating all future changes is a costly and largely
 unrewarding exercise.
 The architecture will become polluted with extension points, creating a
 lot of extra development work, which in turn may not in fact capture all
 possible future requirements.
\end_layout

\begin_layout Standard
The issues found in this example relate closely to our work on component
 reuse 
\begin_inset LatexCommand cite
key "McVeigh2006"

\end_inset

, where we elaborated a set of requirements for effective component reuse
 and extension.
 As Eclipse structures itself as a set of components, we can assess its
 approach against these requirements.
 In this case, the system fails to provide sufficient flexibility because
 we are unable to make changes without copying and modifying the source
 code for the plugin (ALTER, NOSOURCE).
 We are also unable to seamlessly accept a new version without having to
 perform a source level merge (UPGRADE).
 The requirement that changes have no impact (NO IMPACT) on existing consumers
 of the plugin is met, as there is no need to force the upgrade on those
 who do not wish to see the new version.
\end_layout

\begin_layout Standard
As it is, the Eclipse plugin model contains practical and undesirable limitation
s on how easily a system can be extended, understood and managed.
 The next section introduces component substitution architectures, which
 provide constructs which remove or ameliorate the limitations so far discussed.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Backbone-and-Component"

\end_inset

Component Substitution Architectures
\end_layout

\begin_layout Standard
The foundation of the substitution approach is an extension, which is a
 packaged collection of interfaces and components.
 An extension is loosely analogous to a plugin.
\end_layout

\begin_layout Standard
Unlike a plugin, however, an extension can choose to substitute any component
 (in the system being extended) with one of its own.
 This gives an extension the ability to re-make the underlying architecture
 in order to effect any required changes.
 A further construct, called resemblance, allows a component to inherit
 and incrementally modify (add, delete, replace) the structure of other
 components.
 Used together, substitution and resemblance allow an extension to make
 an incremental modification to an existing component in a system.
 This is termed incremental substitution.
\end_layout

\begin_layout Standard
In the Eclipse example, a new extension could simply incrementally substitute
 TaskView to add the new column.
 Although this approach would work even when using a class-based model 
\begin_inset LatexCommand cite
key "Ichisugi2002"

\end_inset

, there are limitations related to inheritance.
 Class-based inheritance allows method and attribute addition and a level
 of method replacement, which limits the type of extension possible.
 This was the motivation behind the introduction of a full component model,
 along with the resemblance construct.
 The relationship between components and classes will be described in this
 section.
\end_layout

\begin_layout Standard
An important element of the substitution approach is a hierarchical component
 model, where composite components are made up of instances of other components.
 This allows the architecture of a system to be structure hierarchically.
 A system can be manageably structured as a component which decomposes into
 other components and so on until we reach fine-grained leaf components.
 This gives the ability to finely decompose a system, permitting any substitutio
n to take place at the appropriate level of abstraction.
\end_layout

\begin_layout Standard
These concepts address the major issues found in the plugin example.
 The model can be finely structured without becoming difficult to manage,
 and incremental substitution makes any constituent of an existing component
 into a potential extension point.
\end_layout

\begin_layout Subsection
Modeling the Task View in Backbone
\end_layout

\begin_layout Standard
This section explains the Backbone ADL through the task view extension example.
\end_layout

\begin_layout Standard
The Backbone language has been developed as part of this work, in order
 to evaluate the substitution model.
 Backbone features the substitution and resemblance constructs, and a hierarchic
al component model where each leaf component (leaves are not further decomposabl
e) describes a Java class.
 A Backbone interpreter has been created, which can assemble the system
 from an architectural description combined with Java classes for the leaves.
 More details on the motivation behind the constructs is described in 
\begin_inset LatexCommand cite
key "McVeigh2006"

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Standard
The referenced paper refers to substitution as 
\begin_inset Quotes eld
\end_inset

redefinition
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Going back to the task view example of 
\begin_inset LatexCommand ref
reference "sub:Extending-Eclipse:-Adding"

\end_inset

, consider modeling the concept of a view column (e.g.
 
\begin_inset Quotes eld
\end_inset

Description
\begin_inset Quotes erd
\end_inset

) in Backbone.
 Figure 
\begin_inset LatexCommand ref
reference "fig:A-component-definition"

\end_inset

 shows GridColumn as a leaf component.
 It has a single attribute 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 and provides the IGridColumn interface.
 We will later use instances of this component to configure the task view's
 visible columns.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename images/column.eps
	width 40col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:A-component-definition"

\end_inset

A column component
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As this is a leaf (note the 
\begin_inset Quotes eld
\end_inset

L
\begin_inset Quotes erd
\end_inset

 in the top right corner), it also describes a Java class.
 The component definition is represented graphically (or textually) in Backbone.
 The implementation is associated with a Java class, as shown below
\begin_inset Foot
status collapsed

\begin_layout Standard
The Java source code is not required for this example.
 It is simply shown to demonstrate the link between components and implementatio
n classes.
\end_layout

\end_inset

.
\end_layout

\begin_layout LyX-Code

\size scriptsize
public class GridColumn {
\end_layout

\begin_layout LyX-Code

\size scriptsize
  private IGridColumn
\end_layout

\begin_layout LyX-Code

\size scriptsize
    g_IGridColumnProvided =
\end_layout

\begin_layout LyX-Code

\size scriptsize
        new IGridProvidedImpl();
\end_layout

\begin_layout LyX-Code

\size scriptsize
  private String name;
\end_layout

\begin_layout LyX-Code

\size scriptsize
  
\end_layout

\begin_layout LyX-Code

\size scriptsize
  private class IGridProvidedImpl
\end_layout

\begin_layout LyX-Code

\size scriptsize
        implements IGridColumn {
\end_layout

\begin_layout LyX-Code

\size scriptsize
    ...
\end_layout

\begin_layout LyX-Code

\size scriptsize
  }}
\end_layout

\begin_layout Standard
The grid user interface widget (figure 
\begin_inset LatexCommand ref
reference "fig:A-grid-widget"

\end_inset

) displays a set of columns and their associated data on the screen.
 It is the user interface widget for displaying a task view, providing IGrid,
 and requiring IGridColumn.
 The small box named 
\begin_inset Quotes eld
\end_inset

r
\begin_inset Quotes erd
\end_inset

 indicates a port, which allows a multiplicity to be added for interfaces
 provided or required.
 The [0..*] therefore indicates that zero to many provisions are required,
 thus giving the same effect as an extension point which can accommodate
 many PluginExtensions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename images/widget.eps
	width 35col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:A-grid-widget"

\end_inset

A grid widget component
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Required interfaces are analogous to extension points in Eclipse.
 Provided interfaces are analogous to PluginExtensions, which provide data
 to extension points.
 Interfaces are more expressive however, as object references can be passed
 in addition to data and class references.
\end_layout

\begin_layout Standard
A composite component is constructed out of instances of other components.
 These instances, in the terminology of UML2, are known as parts 
\begin_inset LatexCommand cite
key "OMGUML"

\end_inset

.
 A composite is effectively shorthand for instructions for wiring up a set
 of other parts.
 As such, all components can be 
\begin_inset Quotes eld
\end_inset

flattened
\begin_inset Quotes erd
\end_inset

 into a connected set of leaf component instances.
\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "fig:The-task-viewer"

\end_inset

 shows the task view as a composite component.
 The inner boxes are instances of other components (parts).
 In this case, there are two columns (
\begin_inset Quotes eld
\end_inset

Description
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Location
\begin_inset Quotes erd
\end_inset

) configured up to the GridWidget part.
 Note also that TaskView resembles MarkerView (fully shown).
 The instances of MarkerViewController and GridWidget are structurally inherited
 from MarkerView, which defines a generic viewer of marker information.
 TaskView has added the two GridColumn parts.
\end_layout

\begin_layout Standard
Note that TaskView is not a leaf, and therefore does not have a Java representat
ion.
 Instances of this component must be constructed from Backbone, which will
 flatten the component hierarchy and connect together leaf object instances.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename images/taskviewer.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:The-task-viewer"

\end_inset

The task view component
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, all the components and interfaces are bundled up into a module-like
 construct known as a stratum (figure 
\begin_inset LatexCommand ref
reference "fig:The-taskview-and"

\end_inset

).
 A stratum constitutes a unit of extension that can be applied to an application.
 The taskview stratum packages up TaskView, and the entire unit is dependent
 upon (and can legally refer to) the definitions in the markerview stratum.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename images/base-stratum.eps
	width 70col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:The-taskview-and"

\end_inset

The taskview and markerview strata
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Technically, a stratum is a stereotyped UML2 package.
 It uses different rules for package visibility, nesting and export to be
 more compatible with extensible systems.
 These rules aim to avoid the modularity limitations on the package construct,
 summarized in 
\begin_inset LatexCommand cite
key "Schurr1998"

\end_inset

.
 The strata rules are not further explained in this paper.
 
\end_layout

\begin_layout Subsection
Extension via Substitution
\end_layout

\begin_layout Standard
The TaskView component and associated elements model the existing Eclipse
 task view, before our requirement to add the 
\begin_inset Quotes eld
\end_inset

assigned to
\begin_inset Quotes erd
\end_inset

 column.
 Our extension will need to add the extra column.
 To also present an example of replacement, we hypothetically suppose that
 the MarkerViewController instance also needs to be replaced to display
 the new column.
\end_layout

\begin_layout Standard
To achieve the above effect, we create a further stratum, called enhancedtaskvie
w, which contains an incremental substitution of TaskView.
 The substitution, shown as TaskView` is shown in figure 
\begin_inset LatexCommand ref
reference "fig:The-component-that"

\end_inset

.
 The dual headed arrow between TaskView` and TaskView denotes incremental
 substitution (resemblance and substitution together).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename images/enhanced-taskview.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:The-component-that"

\end_inset

Incrementally substituting TaskView
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The TaskView` component has replaced the MarkerViewController part with
 an instance of EnhancedMarkerViewController and added a GridColumn part
 for our new column.
 All other parts are inherited from the original TaskView.
\end_layout

\begin_layout Standard
The component is packaged into a stratum as shown in figure 
\begin_inset LatexCommand ref
reference "fig:Packaging-up-the"

\end_inset

.
 We can create a system that includes this stratum, thereby applying the
 substitution and getting the additional column, or we can exclude it and
 recreate the original task view.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename images/extension.eps
	width 70col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Packaging-up-the"

\end_inset

Packaging up the extension
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Resemblance as Deltas
\end_layout

\begin_layout Standard
It is vital to note that any resembling component is held as a set of deltas.
 For instance, the textual Backbone description of the substituting component
 (omitting the extra connector) is as follows:
\end_layout

\begin_layout LyX-Code

\size scriptsize
{component-name: TaskView`
\end_layout

\begin_layout LyX-Code

\size scriptsize
 substitutes: taskview::TaskView
\end_layout

\begin_layout LyX-Code

\size scriptsize
 resembles: taskview::TaskView
\end_layout

\begin_layout LyX-Code

\size scriptsize
 parts: { type: taskview::GridColumn,
\end_layout

\begin_layout LyX-Code

\size scriptsize
 slots: { attributes:
\end_layout

\begin_layout LyX-Code

\size scriptsize
    { name: name, type: String,
\end_layout

\begin_layout LyX-Code

\size scriptsize
      value: "Assigned to" }}}
\end_layout

\begin_layout LyX-Code

\size scriptsize
 replaceParts: {
\end_layout

\begin_layout LyX-Code

\size scriptsize
   original: taskview::TaskView.c,
\end_layout

\begin_layout LyX-Code

\size scriptsize
   part:{
\end_layout

\begin_layout LyX-Code

\size scriptsize
   type:
\end_layout

\begin_layout LyX-Code

\size scriptsize
     enhancedtaskview::EnhancedMarkerViewController}}
\end_layout

\begin_layout LyX-Code

\size scriptsize
  ...}
\end_layout

\begin_layout Standard
The substituting component has replaced the part 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

 with an EnhancedMarkerViewController part and added a GridColumn part.
 All other parts (figure 
\begin_inset LatexCommand ref
reference "fig:The-component-that"

\end_inset

) are inherited via resemblance from the original TaskView definition.
 Resemblance allows for constituent (part, port, attribute, connector) addition,
 replacement and deletion.
\end_layout

\begin_layout Standard
The use of deltas is important, as it allows the base component to be changed
 at a later point, and these changes will automatically flow through to
 any resembling components.
 A change to the base may happen through simple editing, or a further substituti
on when an upgrade occurs or another extension is applied.
\end_layout

\begin_layout Standard
In this approach, an evolution of a system can also be packaged as an extension.
 As such, Backbone merges the concept of an extension mechanism and a configurat
ion management (CM) system.
 The deltas in the substitution above and the deltas from an evolution stratum
 can both be applied, satisfying the UPGRADE requirement outlined in 
\begin_inset LatexCommand cite
key "McVeigh2006"

\end_inset

.
 This gives us the freedom to make modifications to components of which
 we are not the primary maintainer, which is problematic in the plugin model.
 The model will simply combine our changes with those of the upgrade, using
 strata dependencies to order the application of the deltas.
 In cases where only a partial strata order is present (e.g.
 the diamond-shaped dependencies in section 
\begin_inset LatexCommand ref
reference "sec:A-Formal-Model"

\end_inset

) then multiple resemblance is used.
\end_layout

\begin_layout Subsection
Substitution Model Characteristics
\end_layout

\begin_layout Standard
The component model is hierarchical, allowing components to be decomposed
 to a fine-grained level.
 This in turn allows any substitution to be more targeted than in the plugin
 model.
 Changes can be made at the appropriate level of abstraction.
 Large architectures can be represented and managed using hierarchy, as
 it is a scalable concept.
\end_layout

\begin_layout Standard
Further, any element of the model (component, part, attribute, connector
 etc) is a natural extension point, as it can be replaced via an incremental
 substitution.
 Unlike the plugin model which requires advance planning even for addition,
 the ability to extend is a seamless part of creating a system in the substituti
on model and extension point possibilities become more numerous as the model
 is elaborated.
\end_layout

\begin_layout Standard
Using a component model rather than a class model allows the internal structure
 of each artifact to be fully displayed graphically.
 As all component creation is controlled via Backbone, and is present in
 the graphical model as parts (or as factories for dynamic instantiation),
 the architecture is more explicit than a class-based model that hides object
 instantiation implicitly in code.
 Furthermore, resemblance is more powerful than inheritance, allowing deletion
 and replacement as well as addition.
 The tie between the Backbone model and the Java implementation is expressed
 at the leaf component level
\begin_inset Foot
status collapsed

\begin_layout Standard
The substitution model is applicable to other implementation languages also.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Resemblance keeps any changes, from the components being resembled, as deltas.
 This allows us to avoid copying errors when the base changes, and also
 allows us to combine substitutions from separate extensions.
 The graphical modeling approach always displays the expanded component
 (showing all constituents inherited via resemblance) even though deltas
 are recorded.
 This makes extension as straightforward as initial component creation.
\end_layout

\begin_layout Standard
An important point is that only the Backbone model and the compiled interface
 definitions are required to construct any extension to an application.
 This is equivalent to the the use of the plugin.xml metadata in the Eclipse
 case.
 Unlike the plugin model, however, in the substitution approach the implementati
on (Java) source is not required for replacement.
 Because component instantiation is completely specified within Backbone,
 by adjusting the configuration through the substitution construct we can
 replace or evolve a component.
\end_layout

\begin_layout Standard
By moving to a substitution model, more power is given to extension developers
 and less prediction of future extension points is required by the original
 application developers.
 However, as a model which allows deletion and replacement as well as additive
 change, there is the potential for structural interference between independentl
y developed extensions.
 These may structurally overlap due to conflicting changes to the base applicati
on.
 The model is expressive enough to allow these types of conflicts to be
 resolved via substitution in a further stratum, an interesting property
 revealed by the formal model in the next section.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:A-Formal-Model"

\end_inset

A Formal Model of Backbone
\end_layout

\begin_layout Standard
We modeled Backbone using Alloy 
\begin_inset LatexCommand cite
key "Jackson2002"

\end_inset

, a relational logic coupled with a model finder.
 The model is presented in some detail in 
\begin_inset LatexCommand cite
key "McVeigh2007a"

\end_inset

.
 This section summarizes how substitution and resemblance allow incremental
 changes to existing components, and how multiple substitutions are combined.
\end_layout

\begin_layout Standard
Both components and interfaces are types of elements, and can participate
 in resemblance and substitution relationships.
 (Parts of the definition not relevant to this discussion are omitted using
 ellipsis)
\end_layout

\begin_layout LyX-Code

\size scriptsize
abstract sig Element {
\end_layout

\begin_layout LyX-Code

\size scriptsize
  home: Stratum,
\end_layout

\begin_layout LyX-Code

\size scriptsize
  substitutes: lone Element,
\end_layout

\begin_layout LyX-Code

\size scriptsize
  resembles: set Element,
\end_layout

\begin_layout LyX-Code

\size scriptsize
  resembles_e: Element -> Stratum,
\end_layout

\begin_layout LyX-Code

\size scriptsize
  ...
 }
\end_layout

\begin_layout Standard
Each element is owned by its home stratum.
 It can optionally substitute (
\begin_inset Quotes eld
\end_inset

substitutes
\begin_inset Quotes erd
\end_inset

) for another single element of the same type, in another stratum.
 It can also resemble (
\begin_inset Quotes eld
\end_inset

resembles
\begin_inset Quotes erd
\end_inset

) one or more elements of the same type, in the home or any other stratum
 that the home can transitively see via dependencies.
\end_layout

\begin_layout Standard
Each element has a set of constituents, which are held as deltas.
 For a component, the constituents are attribute, port, part and connector.
\end_layout

\begin_layout LyX-Code

\size scriptsize
sig Component extends Element {
\end_layout

\begin_layout LyX-Code

\size scriptsize
  myParts: lone Parts/Deltas,
\end_layout

\begin_layout LyX-Code

\size scriptsize
  myPorts: lone Ports/Deltas,
\end_layout

\begin_layout LyX-Code

\size scriptsize
  myConnectors: lone Connectors/Deltas,
\end_layout

\begin_layout LyX-Code

\size scriptsize
  myAttributes: lone Attributes/Deltas,
\end_layout

\begin_layout LyX-Code

\size scriptsize
  ...
 }
\end_layout

\begin_layout Standard
A stratum owns its elements, and must explicitly express its dependencies
 on other strata.
 Via predicates, the dependency graph is guaranteed to be acyclic.
\end_layout

\begin_layout LyX-Code

\size scriptsize
sig Stratum {
\end_layout

\begin_layout LyX-Code

\size scriptsize
  parent: Stratum, 
\end_layout

\begin_layout LyX-Code

\size scriptsize
  dependsOn: set Stratum,
\end_layout

\begin_layout LyX-Code

\size scriptsize
  ownedElements: set Element,
\end_layout

\begin_layout LyX-Code

\size scriptsize
  ...
 }
\end_layout

\begin_layout Standard
Consider a small example system with four strata arranged in a diamond dependenc
y structure (figure 
\begin_inset LatexCommand ref
reference "fig:A-diamond-dependency"

\end_inset

).
 The Base component lives in stratum A, and it is incrementally substituted
 by Base' in stratum B.
 ExtendedBase in stratum C resembles base.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard

\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename images/diamond.eps
	width 70col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:A-diamond-dependency"

\end_inset

A diamond dependency structure
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resemblance graph is reordered by taking substitution into account,
 from the perspective of each stratum.
 This information is stored in the Element's resembles_e field.
 For instance, from the perspective of C, ExtendedBase resembles Base.
 From the perspective of B, Base' also resembles Base.
 From the perspective of D, however, ExtendedBase resembles Base' which
 then resembles Base.
 This reflects both the fact that Base' has been substituted for Base and
 that Base' resembles Base.
\end_layout

\begin_layout LyX-Code

\size scriptsize
all e: Element {
\end_layout

\begin_layout LyX-Code

\size scriptsize
  all s: Stratum {
\end_layout

\begin_layout LyX-Code

\size scriptsize
    e.resembles_e.s = 
\end_layout

\begin_layout LyX-Code

\size scriptsize
      topmostOfSubstituted + topmostOfResemblance
\end_layout

\begin_layout LyX-Code

\size scriptsize
    ...
 }
\end_layout

\begin_layout Standard
In the above Alloy snippet, we set the resembles_e relation for each element
 to be the (potentially substituted) definition of the element it redefines
 or resembles.
 
\begin_inset Quotes eld
\end_inset

Topmost
\begin_inset Quotes erd
\end_inset

 refers to the way that substitution is taken into account to take the highest
 substitution available.
 For redefinition it is the topmost substituted element in the immediately
 depended-upon strata (to avoid a graph cycle).
 For resemblance, even the current stratum's substitutions can be used.
\end_layout

\begin_layout Standard
Hence, the resembles_e values for ExtendedBase become ((Base, C), (Base',
 D)).
 This rewriting of the resemblance graph using the partial strata dependency
 order can result in multiple resemblance.
 Consider if another incremental substitution took place in stratum C (Base_C').
 Then, the resembles_e values for ExtendedBase would be ((Base_C', C), (Base_C',
 D), (Base', D)).
 From the perspective of D, ExtendedBase resembles both Base_C' and Base'.
\end_layout

\begin_layout Standard
Once substitution has been factored into the resembles_e relation, the deltas
 are applied.
 In a purely linear resembles_e graph, we could just apply the deltas (add,
 delete, replace) in order from bottom to top.
 Some issues may occur even in this situation: for instance, in the system
 of figure 
\begin_inset LatexCommand ref
reference "fig:A-diamond-dependency"

\end_inset

, ExtendedBase can try to replace a part which existed from the perspective
 of C, but is deleted by Base' in the perspective of B and D.
 A small number of rules are defined to deal with such situations and they
 are generally in accordance with intuition.
\end_layout

\begin_layout Standard
With multiple resemblance, however, we may get legitimate conflicts.
 For instance, Base' and Base_C' may try to replace the same part.
 In this case, both parts are present from the D perspective, and both are
 associated with the same part identifier
\begin_inset Foot
status collapsed

\begin_layout Standard
Backbone uses unique identifiers (UUIDs) to preserve logical identity, rather
 than names.
 The CASE tool hides this, showing names instead.
\end_layout

\end_inset

.
 This flags up the Base component (the component we are substituting) and
 ExtendedBase as being in error from this perspective.
 A further incremental substitution (Base_D') in D will result in the following
 resembles_e graph (figure 
\begin_inset LatexCommand ref
reference "fig:How-Base_D'-rewrites"

\end_inset

).
 As such, Base_D' is able to make any corrections to handle the conflict.
 Base_D' can either replace the part definitively with one of its own, or
 delete it entirely to leave the system error-free in D.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename images/conflict.eps
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:How-Base_D'-rewrites"

\end_inset

How Base_D' rewrites the resembles_e graph to allow conflicts correction
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This type of conflict usually occurs when we try to combine independently
 developed extensions into the same application, as it is possible that
 each extension will make overlapping and incompatible changes to the base
 application.
 The conflicts cannot be resolved automatically, as they represent different
 views of how the underlying structure should look, at the same level of
 abstraction.
 This situation is to be expected in a model which offers the flexibility
 to alter the base application, and it can be resolved using the same constructs
 that led to the conflict: resemblance and substitution.
\end_layout

\begin_layout Standard
Observe that the situation in figure 
\begin_inset LatexCommand ref
reference "fig:How-Base_D'-rewrites"

\end_inset

 can be applied to the TaskView example in figure 
\begin_inset LatexCommand ref
reference "fig:The-component-that"

\end_inset

.
 TaskView acts as Base, and TaskView` acts as Base`.
 Base_C` represents the incremental substitution of TaskView when the maintainer
 upgrades TaskView to add coloring support for different task priorities
 (see section 
\begin_inset LatexCommand ref
reference "sub:Extending-Eclipse:-Adding"

\end_inset

).
 Base_D` represents a further incremental substitution (Base_D`) that resolves
 any conflicts from combining the two other substitutions.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Related-Work"

\end_inset

Related Work
\end_layout

\begin_layout Standard
Plugin architectures have been used successfully for many systems.
 Eclipse is based on the OSGi module system, which provides import / export
 constructs and full versioning of plugins (bundles)
\begin_inset LatexCommand cite
key "O.Gruber2005"

\end_inset

.
 Firefox has plugins for handling media types 
\begin_inset LatexCommand cite
key "Firefoxplugins2008"

\end_inset

 along with more general additions 
\begin_inset LatexCommand cite
key "Fireextensions2007"

\end_inset

.
\end_layout

\begin_layout Standard
COM provides a compositional component model for Microsoft Windows 
\begin_inset LatexCommand cite
key "Box1997"

\end_inset

.
 Applications are able to use this as an extension approach, as scripts
 loaded into the applications can call out to COM components.
 COM versions are held in a global registry, which leads to a situation
 called 
\begin_inset Quotes eld
\end_inset

DLL Hell
\begin_inset Quotes erd
\end_inset

, when multiple applications require different versions of the same component
 
\begin_inset LatexCommand cite
key "Stuckenholz2005"

\end_inset

.
 Even without a global registry, the problem still occurs, however, when
 combining multiple extensions into a single application.
\end_layout

\begin_layout Standard
Backbone is strongly influenced by architectural description languages,
 including Darwin 
\begin_inset LatexCommand cite
key "Magee1995"

\end_inset

, Koala 
\begin_inset LatexCommand cite
key "Ommering2000"

\end_inset

, UML2's composite structure model 
\begin_inset LatexCommand cite
key "Selic2003"

\end_inset

 and ROOM 
\begin_inset LatexCommand cite
key "Selic1994"

\end_inset

.
\end_layout

\begin_layout Standard
The Backbone approach is closely related to architectural configuration
 management (CM) 
\begin_inset LatexCommand cite
key "Roshandel2004"

\end_inset

.
 Backbone functions as a decentralized architectural CM system, preventing
 the need to share a common repository.
 Our approach also prevents the need to incorporate explicit extension points
 into a base architecture, unlike the plugin model and existing architectural
 approaches.
\end_layout

\begin_layout Standard
Product lines 
\begin_inset LatexCommand cite
key "Eriksson2006"

\end_inset

 provide a way to build up an application family from a set of related requireme
nts.
 The use of gluons in 
\begin_inset LatexCommand cite
key "Batory2002"

\end_inset

 provides several of the same features as our approach, but is not specifically
 concerned with extensible applications.
\end_layout

\begin_layout Standard
Extensibility is closely related to work on language-level reuse.
 Mixins are effectively abstract subclasses, allowing functionality to be
 
\begin_inset Quotes eld
\end_inset

mixed in
\begin_inset Quotes erd
\end_inset

 or reused by several classes 
\begin_inset LatexCommand cite
key "Bracha1990"

\end_inset

.
 However, the use of mixins must be pre-planned, as they call into methods
 of the superclass, and naming clashes can occur when combining multiple
 mixins into a single class.
 Aspects have been successfully used to extend systems via addition, providing
 a way to separate orthogonal implementation concerns 
\begin_inset LatexCommand cite
key "kiczales97aspectoriented"

\end_inset

.
 Units and mixins are used in 
\begin_inset LatexCommand cite
key "Findler1998"

\end_inset

 to separate component creation and dependency binding.
 Once a binding is made, it cannot be replaced or removed, limiting the
 applicability for extensible systems.
\end_layout

\begin_layout Standard
UML2 contains the package merge construct, which allows packages to be added
 together, via an additive union 
\begin_inset LatexCommand cite
key "OMGUML"

\end_inset

.
 The specification of this presents several problems 
\begin_inset LatexCommand cite
key "Zito2006"

\end_inset

, and no replacement or deletion facilities limit its utility for extensible
 systems.
 UML2 also contains the notion of redefinition.
 This is used in conjunction with inheritance, where the inheriting element
 can covariantly override the features of the base.
 This is closely related to resemblance, but does not allow deletion or
 arbitrary replacement.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Conclusions-and-Future"

\end_inset

Conclusions and Future Work
\end_layout

\begin_layout Standard
Component substitution architectures offer a more flexible alternative to
 plugin architectures, ameliorating or directly addressing the limitations
 of the plugin model.
 The foundation of the approach is to allow an extension to substitute any
 component in an application with one of its own.
 Combined with resemblance, which allows a component to structurally inherit
 from others, an extension can incrementally modify any part of the base
 application.
 Substitution and resemblance also apply to interfaces, providing a way
 to gracefully evolve the service capabilities of components.
\end_layout

\begin_layout Standard
A key issue with the plugin model is the lack of a composition hierarchy.
 Plugins cannot currently contain or nest other plugins -- they all exist
 at the same level.
 Without the ability to nest, a fine-grained model of the Eclipse architecture
 would involve many thousands of plugins at the top level, and become extremely
 difficult to manage.
 As a consequence, a plugin in Eclipse must be relatively coarse-grained.
\end_layout

\begin_layout Standard
A further problem is that the plugin model primarily facilitates additive
 change, via plugging into existing extension points.
 If modification of existing plugins is required, because the required extension
 points are not present, then a new version must be created.
 This characteristic of turning notional additive change into replacement
 interacts badly with the coarse-grained nature of the plugins, leading
 to a disproportionate effort for simple changes.
 Further, distributing a new version of a plugin can be impractical particularly
 if others (including the primary source) are also releasing independently
 updated versions.
\end_layout

\begin_layout Standard
The Backbone substitution and resemblance constructs, coupled with a hierarchica
l component model, allow for fine-grained substitution at the appropriate
 level of abstraction.
 The constructs form a simple, but effective, decentralized configuration
 management system for an architecture.
 The keeping of changes as deltas allows multiple substitutions to be combined
 at the architectural level, without requiring the implementation source
 code.
\end_layout

\begin_layout Standard
It is not necessary to have the implementation source code to extend an
 application written using Backbone, unlike in the plugin model which resorts
 to implementation source editing when replacement is required.
 Since all component instantiation is performed in Backbone rather than
 code, any component can be substituted using the constructs purely at the
 architectural description level.
\end_layout

\begin_layout Standard
In Backbone every constituent of every component is a potential extension
 point.
 This leads to systems which are extensible without placing the burden on
 the application designer to try to predict and factor in every possible
 extension point.
 Compared to plugin architectures, component substitution has been found
 to result in simpler architectures, whilst simultaneously offering more
 power to extension developers.
\end_layout

\begin_layout Standard
The component substitution approach gives more flexibility, but introduces
 an obvious issue compared to plugin architectures: we can no longer guarantee
 that combining independently developed, but potentially structurally overlappin
g, extensions into a single application will not produce some conflicts.
 To address this, we showed that a further extension can be used to rectify
 issues introduced in this way.
\end_layout

\begin_layout Standard
The current status of the work is as follows.
 The formal model has been completed and used to implement a UML2-based
 case tool, where modeling with deltas is handled by always showing the
 expanded structure of each component.
 This leads to a situation where component extension is as straightforward
 as initial component modeling.
 The previous Backbone interpreter is currently being rewritten to conform
 to the formal model.
\end_layout

\begin_layout Standard
Future work will focus on expressing the behavioral properties of components
 in an extension setting.
 We plan to express protocols using sequence diagrams (with operators) which
 we will process into the FSP process algebra 
\begin_inset LatexCommand cite
key "Magee1999"

\end_inset

.
 The individual protocols of each part of a component will be composed to
 detect any protocol violations that occur when substituting components.
 Other work includes a baselining facility where progressive deltas from
 layered extensions can be compressed into a new base system without deltas.
 This will overcome the limitation of dealing with an ever increasing set
 of deltas.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "plain"
bibfiles "../../read papers/references"

\end_inset


\end_layout

\end_body
\end_document
